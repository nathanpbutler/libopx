namespace nathanbutlerDEV.libopx.SMPTE;

/// <summary>
/// Contains SMPTE metadata element definitions and constants for MXF processing.
/// This class provides element identifiers, types, and structure definitions used in SMPTE standards.
/// </summary>
public class Elements
{
    /// <summary>
    /// AAC Channel Configuration
    /// </summary>
    /// <remarks>
    /// Low order 4 bits of Channel Configuration.  Upper 4 bits are zeros
    /// </remarks>
    private static readonly byte[] AACChannelConfiguration = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x02, 0x04, 0x03, 0x01, 0x03, 0x00, 0x00];
    /// <summary>
    /// AAC Sampling Frequency
    /// </summary>
    /// <remarks>
    /// Low order 4 bits of Sampling Frequency Index.  Upper 4 bits are zeros
    /// </remarks>
    private static readonly byte[] AACSamplingFrequency = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x02, 0x04, 0x03, 0x01, 0x04, 0x00, 0x00];
    /// <summary>
    /// AAF Association
    /// </summary>
    /// <remarks>
    /// Metadata registered by the AAF Association for public use
    /// </remarks>
    private static readonly byte[] AAFAssociation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// AAF Attributes
    /// </summary>
    /// <remarks>
    /// AAF Attributes
    /// </remarks>
    private static readonly byte[] AAFAttributes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// AAF Information Attributes
    /// </summary>
    /// <remarks>
    /// AAF Information Attributes
    /// </remarks>
    private static readonly byte[] AAFInformationAttributes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// AAF Information Attributes Version 1.x
    /// </summary>
    /// <remarks>
    /// AAF Information Attributes Version 1.x
    /// </remarks>
    private static readonly byte[] AAFInformationAttributesVersion1X = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// AAF Manufacturer ID
    /// </summary>
    /// <remarks>
    /// The AAF registered ID for a particular manufacturer.
    /// </remarks>
    private static readonly byte[] AAFManufacturerID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x0A, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Absolute Dates and Times
    /// </summary>
    /// <remarks>
    /// Absolute date and time information
    /// </remarks>
    private static readonly byte[] AbsoluteDatesAndTimes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Absolute Durations
    /// </summary>
    /// <remarks>
    /// Absolute time duration information
    /// </remarks>
    private static readonly byte[] AbsoluteDurations = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Absolute Position
    /// </summary>
    /// <remarks>
    /// Absolute positional information
    /// </remarks>
    private static readonly byte[] AbsolutePosition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Absolute Rate and Direction of Positional Change
    /// </summary>
    /// <remarks>
    /// Information about the absolute rate and direction of positional change
    /// </remarks>
    private static readonly byte[] AbsoluteRateAndDirectionOfPositionalChange = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Abstract
    /// </summary>
    /// <remarks>
    /// A brief narrative summary of the data set.
    /// </remarks>
    private static readonly byte[] Abstract = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x01, 0x06, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Abstract
    /// </summary>
    /// <remarks>
    /// A brief narrative summary of the data set.
    /// </remarks>
    private static readonly byte[] Abstract_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x01, 0x06, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Abstract Locations
    /// </summary>
    /// <remarks>
    /// Abstract information about position
    /// </remarks>
    private static readonly byte[] AbstractLocations = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Abstract Names
    /// </summary>
    /// <remarks>
    /// Abstract place information
    /// </remarks>
    private static readonly byte[] AbstractNames = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Hardware Accelerator Flag
    /// </summary>
    /// <remarks>
    /// Plugin capable of using hardware accelerator
    /// </remarks>
    private static readonly byte[] Accelerator = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x09, 0x0C, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Access Control
    /// </summary>
    /// <remarks>
    /// Details of permitted access to the media product
    /// </remarks>
    private static readonly byte[] AccessControl = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Accounting Reference Number
    /// </summary>
    /// <remarks>
    /// Reference number for accounting purposes
    /// </remarks>
    private static readonly byte[] AccountingReferenceNumber_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// ACES Authoring Information
    /// </summary>
    /// <remarks>
    /// Human readable information on the system used to author the ACES image essence contained in the track file
    /// </remarks>
    private static readonly byte[] ACESAuthoringInformation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x0A, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// ACES Coding Parameters
    /// </summary>
    /// <remarks>
    /// Information about ACES picture coding
    /// </remarks>
    private static readonly byte[] ACESCodingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x0A, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// ACES Mastering Display Maximum Luminance
    /// </summary>
    /// <remarks>
    /// Maximum Display Mastering Luminance metadata as specified in ST 2086
    /// </remarks>
    private static readonly byte[] ACESMasteringDisplayMaximumLuminance = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x0A, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// ACES Mastering Display Minimum Luminance
    /// </summary>
    /// <remarks>
    /// Minimum Display Mastering Luminance metadata as specified in ST 2086
    /// </remarks>
    private static readonly byte[] ACESMasteringDisplayMinimumLuminance = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x0A, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// ACES Mastering Display Primaries
    /// </summary>
    /// <remarks>
    /// Display Primaries metadata as specified in ST 2086
    /// </remarks>
    private static readonly byte[] ACESMasteringDisplayPrimaries = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x0A, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// ACES Mastering Display White Point Chromaticity
    /// </summary>
    /// <remarks>
    /// Chromaticity of White Point metadata as specified in ST 2086
    /// </remarks>
    private static readonly byte[] ACESMasteringDisplayWhitePointChromaticity = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x0A, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// ACES Picture SubDescriptor Instance ID
    /// </summary>
    /// <remarks>
    /// Specifies the Instance ID of an ACES Picture Essence SubDescriptor
    /// </remarks>
    private static readonly byte[] ACESPictureSubDescriptorInstanceID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x09, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Acquisition Characteristics
    /// </summary>
    /// <remarks>
    /// The specific category of Acquisition
    /// </remarks>
    private static readonly byte[] AcquisitionCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Acquisition Setting Procedure
    /// </summary>
    /// <remarks>
    /// Explanation of acquisition setting procedure for retaking or for post production
    /// </remarks>
    private static readonly byte[] AcquisitionSettingProcedure = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x01, 0x03, 0x01, 0x13, 0x00, 0x00];
    /// <summary>
    /// Active Format Descriptor
    /// </summary>
    /// <remarks>
    /// Specifies the intended framing of the content within the displayed image (4:3 in 16:9 etc.)
    /// </remarks>
    private static readonly byte[] ActiveFormatDescriptor = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x01, 0x03, 0x02, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Active Height
    /// </summary>
    /// <remarks>
    /// Specifies the height of the Active Area Rectangle
    /// </remarks>
    private static readonly byte[] ActiveHeight = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x05, 0x01, 0x13, 0x00, 0x00, 0x00];
    /// <summary>
    /// Active Lines per Frame
    /// </summary>
    /// <remarks>
    /// Specifies the total number of lines (rows) in the active portion of a frame in the video pixel matrix.
    /// </remarks>
    private static readonly byte[] ActiveLinesPerFrame = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x03, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Active Samples per Line
    /// </summary>
    /// <remarks>
    /// Total number of samples (columns) in the active portion of a line in the video pixel matrix.
    /// </remarks>
    private static readonly byte[] ActiveSamplesPerLine = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Active State
    /// </summary>
    /// <remarks>
    /// Specifies whether the device is active or not as a result of the event (Inactive = False)
    /// </remarks>
    private static readonly byte[] ActiveState = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x30, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Active Width
    /// </summary>
    /// <remarks>
    /// Specifies the width of the Active Area Rectangle
    /// </remarks>
    private static readonly byte[] ActiveWidth = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x05, 0x01, 0x14, 0x00, 0x00, 0x00];
    /// <summary>
    /// Active X Offset
    /// </summary>
    /// <remarks>
    /// Specifies the horizontal offset of the Active Area Rectangle from the left side of the Display Rectangle
    /// </remarks>
    private static readonly byte[] ActiveXOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x05, 0x01, 0x15, 0x00, 0x00, 0x00];
    /// <summary>
    /// Active Y Offset
    /// </summary>
    /// <remarks>
    /// Specifies the vertical offset of the Active Area Rectangle from the upper side of the Display Rectangle.
    /// </remarks>
    private static readonly byte[] ActiveYOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x05, 0x01, 0x16, 0x00, 0x00, 0x00];
    /// <summary>
    /// Ad-ID
    /// </summary>
    /// <remarks>
    /// Metadata registered by Ad-ID, LLC for public use
    /// </remarks>
    private static readonly byte[] Ad_ID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x0D, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// ad_title
    /// </summary>
    /// <remarks>
    /// Alpha-numeric combination that follows the prefix
    /// </remarks>
    private static readonly byte[] ad_title = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x0D, 0x0D, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Address
    /// </summary>
    /// <remarks>
    /// The postal address of a contact or organization
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] address_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x26, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Address
    /// </summary>
    /// <remarks>
    /// Information about the address
    /// Namespace: http://www.smpte-ra.org/reg/335/2012/13/11
    /// </remarks>
    private static readonly byte[] address_11 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Addresses
    /// </summary>
    /// <remarks>
    /// Information about Addresses
    /// </remarks>
    private static readonly byte[] Addresses = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Address Line
    /// </summary>
    /// <remarks>
    /// The address line as a single string
    /// </remarks>
    private static readonly byte[] AddressLine = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x13, 0x01];
    /// <summary>
    /// Address Line
    /// </summary>
    /// <remarks>
    /// The address line as a single string
    /// </remarks>
    private static readonly byte[] AddressLine_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x13, 0x00];
    /// <summary>
    /// Address Line Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to  address lines
    /// </remarks>
    private static readonly byte[] addressLineObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x26, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Address Name-Value Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Name-Value sets
    /// </remarks>
    private static readonly byte[] AddressNameValueObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x1F, 0x04];
    /// <summary>
    /// Address Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an address object
    /// </remarks>
    private static readonly byte[] addressObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x25, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Address Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Address sets
    /// </remarks>
    private static readonly byte[] AddressObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x17, 0x00];
    /// <summary>
    /// adid_code
    /// </summary>
    /// <remarks>
    /// The unique identifier for the advertising asset encoded in the file
    /// </remarks>
    private static readonly byte[] adid_code = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x0D, 0x0D, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// adid_prefix
    /// </summary>
    /// <remarks>
    /// The four character prefix of the advertising asset encoded in the file
    /// </remarks>
    private static readonly byte[] adid_prefix = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x0D, 0x0D, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Adjustment
    /// </summary>
    /// <remarks>
    /// Includes items for making detailed image adjustments.
    /// </remarks>
    private static readonly byte[] Adjustment = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x01, 0x03, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Adjustment Status
    /// </summary>
    /// <remarks>
    /// Error Code
    /// </remarks>
    private static readonly byte[] AdjustmentStatus = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x0A, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// ADM Audio Content ID
    /// </summary>
    /// <remarks>
    /// Specifies the ADM Audio Content ID
    /// </remarks>
    private static readonly byte[] ADMAudioContentID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x02, 0x03, 0x06, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// ADM Audio Object ID
    /// </summary>
    /// <remarks>
    /// Specifies the ADM Audio Object ID
    /// </remarks>
    private static readonly byte[] ADMAudioObjectID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x02, 0x03, 0x06, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// ADM Audio Programme ID
    /// </summary>
    /// <remarks>
    /// Specifies the ADM Audio Programme ID
    /// </remarks>
    private static readonly byte[] ADMAudioProgrammeID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x02, 0x03, 0x06, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// ADMINISTRATION
    /// </summary>
    /// <remarks>
    /// Class 2 is reserved for administrative and business related metadata
    /// </remarks>
    private static readonly byte[] ADMINISTRATION = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Administrative Date-Time
    /// </summary>
    /// <remarks>
    /// Date and Time information relating to Process
    /// </remarks>
    private static readonly byte[] AdministrativeDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x07, 0x02, 0x01, 0x20, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Administrative Identifiers
    /// </summary>
    /// <remarks>
    /// Identifiers relating to Business and Administration
    /// </remarks>
    private static readonly byte[] AdministrativeIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Advertiser
    /// </summary>
    /// <remarks>
    /// The company or the agency's client that is advertising
    /// </remarks>
    private static readonly byte[] advertiser = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x0D, 0x0D, 0x01, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Advertising Material Reference
    /// </summary>
    /// <remarks>
    /// eg printed advertising material
    /// </remarks>
    private static readonly byte[] AdvertisingMaterialReference_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x06, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// AES
    /// </summary>
    /// <remarks>
    /// Metadata registered by the Audio Engineering Society for public use
    /// </remarks>
    private static readonly byte[] AES = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x0D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// AES-3 Processing Parameters
    /// </summary>
    /// <remarks>
    /// Parameters required for AES-3 processing
    /// </remarks>
    private static readonly byte[] AES3ProcessingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Aesthetic Value
    /// </summary>
    /// <remarks>
    /// Assessment of the asthetic quality
    /// </remarks>
    private static readonly byte[] AestheticValue_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x02, 0x02, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// AFD and Bar Data
    /// </summary>
    /// <remarks>
    /// The Active Format Description and Bar Data is a concatenated series of codes, flags, and values that signal the active image area being used for program content. The content and structure of the payload information value shall be coded as described in SMPTE 2016-3.
    /// </remarks>
    private static readonly byte[] AFDBarData = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x04, 0x01, 0x01, 0x01, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Affiliation
    /// </summary>
    /// <remarks>
    /// To provideo information about the affiliation of a contact/person.
    /// </remarks>
    private static readonly byte[] affiliation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6E, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Affiliation Sets
    /// </summary>
    /// <remarks>
    /// To provide a list of present and past affiliations.
    /// </remarks>
    private static readonly byte[] affiliationObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x22, 0x19, 0x00, 0x00, 0x00];
    /// <summary>
    /// Affiliation Organization Set
    /// </summary>
    /// <remarks>
    /// The organization of the affiliation.
    /// </remarks>
    private static readonly byte[] affiliationOrganizationObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6E, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Affiliation Period Of Time Set
    /// </summary>
    /// <remarks>
    /// The period of time during which the affiliation was valid.
    /// </remarks>
    private static readonly byte[] affiliationPeriodOfTimeObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6E, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// agency_office_location
    /// </summary>
    /// <remarks>
    /// The agency working with the advertiser and their office location
    /// </remarks>
    private static readonly byte[] agency_office_location = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x0D, 0x0D, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// AGICOA ID
    /// </summary>
    /// <remarks>
    /// The Association of International Collective Management of Audio Visual Works (AGICOA) register ID.
    /// </remarks>
    private static readonly byte[] AGICOAID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x10, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// AGICOA Identifers
    /// </summary>
    /// <remarks>
    /// Unique Identifiers allocated by AGICOA
    /// </remarks>
    private static readonly byte[] AGICOAIdentifers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x10, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// AICI
    /// </summary>
    /// <remarks>
    /// ANSI/NISO Audio-Visual Item and Component Identifier [proposed]
    /// </remarks>
    private static readonly byte[] AICI = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x13, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// AIFC Summary
    /// </summary>
    /// <remarks>
    /// Summary info according to AIFC Chunk format
    /// </remarks>
    private static readonly byte[] AIFCSummary = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x03, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Alpha Maximum Ref
    /// </summary>
    /// <remarks>
    /// Maximum value for alpha component e.g. 235 or 940 (8 or 10 bits)
    /// </remarks>
    private static readonly byte[] AlphaMaxRef = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x01, 0x05, 0x03, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Alpha Minimum Ref
    /// </summary>
    /// <remarks>
    /// Minumum value for alpha components e.g. 16 or 64 (8 or 10-bits)
    /// </remarks>
    private static readonly byte[] AlphaMinRef = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x01, 0x05, 0x03, 0x0E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Alpha Sample Depth
    /// </summary>
    /// <remarks>
    /// Specifies the number of bits in the alpha signal.
    /// </remarks>
    private static readonly byte[] AlphaSampleDepth = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x01, 0x05, 0x03, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Alpha Transparency
    /// </summary>
    /// <remarks>
    /// Zero if the minimum value of an alpha sample specifies full transparency and the maximum value specifies full opacity, one if vice versa.
    /// </remarks>
    private static readonly byte[] AlphaTransparency = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Alternate Name
    /// </summary>
    /// <remarks>
    /// Alternate name for an individual
    /// </remarks>
    private static readonly byte[] AlternateName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x30, 0x06, 0x03, 0x01, 0x09, 0x01, 0x00];
    /// <summary>
    /// Alternate Name
    /// </summary>
    /// <remarks>
    /// Alternate name for an individual
    /// </remarks>
    private static readonly byte[] AlternateName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x30, 0x06, 0x03, 0x01, 0x09, 0x00, 0x00];
    /// <summary>
    /// Alternates
    /// </summary>
    /// <remarks>
    /// Specifies a vector of references to alternate segments available to the editor
    /// </remarks>
    private static readonly byte[] AlternateSegments = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x06, 0x08, 0x00, 0x00];
    /// <summary>
    /// Alternative Center Cuts
    /// </summary>
    /// <remarks>
    /// Specifies the alternate aspect ratio subset(s) of the active area, containing all of the critical action and centered on the active area.
    /// </remarks>
    private static readonly byte[] AlternativeCenterCuts = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x03, 0x02, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Alternative Date Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to custom dates which purpose/type is indicated using a type group
    /// </remarks>
    private static readonly byte[] alternativeDateObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0C, 0x0E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Alternative Title
    /// </summary>
    /// <remarks>
    /// A set of attributes to qualify an alternative title by which a resource is known
    /// </remarks>
    private static readonly byte[] alternativeTitle = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Alternative Title Attribution Date
    /// </summary>
    /// <remarks>
    /// The date when the alternative title was attributed to the resource
    /// </remarks>
    private static readonly byte[] alternativeTitleAttributionDate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x06, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Alternative Title Geographical Exclusion Scope
    /// </summary>
    /// <remarks>
    /// The geographical scope within which the alternative title does not apply
    /// </remarks>
    private static readonly byte[] alternativeTitleGeographicalExclusionScope = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x06, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Alternative Title Geographical Scope
    /// </summary>
    /// <remarks>
    /// The geographical scope within which the alternative title applies
    /// </remarks>
    private static readonly byte[] alternativeTitleGeographicalScope = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x06, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Alternative Title Length
    /// </summary>
    /// <remarks>
    /// The length of the alternative title
    /// </remarks>
    private static readonly byte[] alternativeTitleLength = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x06, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Alternative Title Note
    /// </summary>
    /// <remarks>
    /// A note to provide additional contextual information
    /// </remarks>
    private static readonly byte[] alternativeTitleNote = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x06, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Alternative Title Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to one or more alternative titles
    /// </remarks>
    private static readonly byte[] alternativeTitleObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Alternative Title Status Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group to specify the status of the alternative title (e.g. "working")
    /// </remarks>
    private static readonly byte[] alternativeTitleStatusGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x06, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Alternative Title Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group to specify the type of the alternative title (e.g. "secondary")
    /// </remarks>
    private static readonly byte[] alternativeTitleTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x06, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Alternative Title Value Sets
    /// </summary>
    /// <remarks>
    /// A set of alternative titles of a resource e.g. in different languages
    /// </remarks>
    private static readonly byte[] alternativeTitleValueObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x06, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// AMIA
    /// </summary>
    /// <remarks>
    /// Metadata registered by the Association of Moving Image Archivists for public use
    /// </remarks>
    private static readonly byte[] AMIA = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x0D, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// AMWA Application Specifications
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] AMWAApplicationSpecifications = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// AMWA Rules Based Specifications
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] AMWARulesBasedSpecifications = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Analog Audio Coding Parameters
    /// </summary>
    /// <remarks>
    /// Information about the original analogue coding of the essence
    /// </remarks>
    private static readonly byte[] AnalogAudioCodingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Analog Data Coding Kind
    /// </summary>
    /// <remarks>
    /// eg.  Teletext
    /// </remarks>
    private static readonly byte[] AnalogDataCodingKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x03, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Analog Data Essence Coding Parameters
    /// </summary>
    /// <remarks>
    /// Information about the analogue coding of the data essence
    /// </remarks>
    private static readonly byte[] AnalogDataEssenceCodingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Analog Metadata Carrier
    /// </summary>
    /// <remarks>
    /// eg. Teletext
    /// </remarks>
    private static readonly byte[] AnalogMetadataCarrier_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Analog Metadata Coding Characteristics
    /// </summary>
    /// <remarks>
    /// Information about the analogue coding of the metadata
    /// </remarks>
    private static readonly byte[] AnalogMetadataCodingCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Analog Monitoring and Control Coding Characteristics
    /// </summary>
    /// <remarks>
    /// Information about the original analog coding of the data
    /// </remarks>
    private static readonly byte[] AnalogMonitoringAndControlCodingCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x05, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Analog Monitoring and Control Coding Kind
    /// </summary>
    /// <remarks>
    /// eg. Teletext
    /// </remarks>
    private static readonly byte[] AnalogMonitoringAndControlCodingKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x05, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Analog System
    /// </summary>
    /// <remarks>
    /// Flat, Dolby-A etc
    /// </remarks>
    private static readonly byte[] AnalogSystem_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Analog Video Coding Characteristics
    /// </summary>
    /// <remarks>
    /// Information about the analogue coding of the essence
    /// </remarks>
    private static readonly byte[] AnalogVideoCodingCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Analog Video System Name
    /// </summary>
    /// <remarks>
    /// PAL, NTSC etc
    /// </remarks>
    private static readonly byte[] AnalogVideoSystemName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Anamorphic Lens Characteristic
    /// </summary>
    /// <remarks>
    /// Examples: Flat, anamorphic
    /// </remarks>
    private static readonly byte[] AnamorphicLensCharacteristic_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x20, 0x02, 0x01, 0x01, 0x09, 0x00, 0x00];
    /// <summary>
    /// Anamorphic Lens Squeeze Ratio
    /// </summary>
    /// <remarks>
    /// Anamorphic aspect ratio with a special lens for widescreen movie. 100 is for normal lens
    /// </remarks>
    private static readonly byte[] AnamorphicLensSqueezeRatio = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x02, 0x02, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Ancillary Data
    /// </summary>
    /// <remarks>
    /// A set of attributes to describe ancillary data in the material
    /// </remarks>
    private static readonly byte[] ancillaryData = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x38, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Ancillary Data Format Id
    /// </summary>
    /// <remarks>
    /// An identifier associated with the data format
    /// </remarks>
    private static readonly byte[] ancillaryDataFormatId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x38, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Ancillary Data Format Name
    /// </summary>
    /// <remarks>
    /// A name associated with the data format
    /// </remarks>
    private static readonly byte[] ancillaryDataFormatName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x38, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Ancillary Data Format Profile
    /// </summary>
    /// <remarks>
    /// To specify an encoding profile
    /// </remarks>
    private static readonly byte[] ancillaryDataFormatProfile = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x38, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Ancillary Data  Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to ancillary data objects
    /// </remarks>
    private static readonly byte[] ancillaryDataObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Ancillary Resource ID
    /// </summary>
    /// <remarks>
    /// A UUID value that identifies the ancillary resource.
    /// </remarks>
    private static readonly byte[] AncillaryResourceID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x01, 0x01, 0x15, 0x13, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// ANC Packet Count
    /// </summary>
    /// <remarks>
    /// Number of ANC packets stored in a Data Element
    /// </remarks>
    private static readonly byte[] ANCPacketCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x05, 0x02, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// ANC Payload Byte Array
    /// </summary>
    /// <remarks>
    /// An array of Uint8 samples containing the coded ANC data
    /// </remarks>
    private static readonly byte[] ANCPayloadByteArray = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x05, 0x02, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// ANC Payload Sample Coding
    /// </summary>
    /// <remarks>
    /// Enumerated sample coding of ANC payload
    /// </remarks>
    private static readonly byte[] ANCPayloadSampleCoding = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x05, 0x03, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// ANC Payload Sample Count
    /// </summary>
    /// <remarks>
    /// A count of the number of samples stored in the payload byte array
    /// </remarks>
    private static readonly byte[] ANCPayloadSampleCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x05, 0x02, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// ANC Wrapping Type
    /// </summary>
    /// <remarks>
    /// Enumerated wrapping type of the VBI data payload
    /// </remarks>
    private static readonly byte[] ANCWrappingType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x05, 0x02, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// ANC Wrapping Type Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group to define the type of ANC wrapping
    /// </remarks>
    private static readonly byte[] ANCWrappingTypeObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x38, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Angles
    /// </summary>
    /// <remarks>
    /// Descriptive information about Angles (Default is Degrees)
    /// </remarks>
    private static readonly byte[] Angles = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Angle to North
    /// </summary>
    /// <remarks>
    /// Angle in degrees from the first row of the image to true north.
    /// </remarks>
    private static readonly byte[] AngleToNorth = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x10, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Angular Specifications
    /// </summary>
    /// <remarks>
    /// Information regarding angles related to positioning information
    /// </remarks>
    private static readonly byte[] AngularSpecifications = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Angular Unit Kind
    /// </summary>
    /// <remarks>
    /// Degrees, Radians, Grads etc
    /// </remarks>
    private static readonly byte[] AngularUnitKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x03, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Annotation Cue Words Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a Cue Words set
    /// </remarks>
    private static readonly byte[] AnnotationCueWordsObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x02, 0x40, 0x23, 0x01];
    /// <summary>
    /// Annotation Description
    /// </summary>
    /// <remarks>
    /// A free-form textual description of the A/V content
    /// </remarks>
    private static readonly byte[] AnnotationDescription = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x02, 0x01, 0x06, 0x0A, 0x01, 0x00, 0x00];
    /// <summary>
    /// Annotation Description
    /// </summary>
    /// <remarks>
    /// A free-form textual description of the A/V content
    /// </remarks>
    private static readonly byte[] AnnotationDescription_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x02, 0x01, 0x06, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Annotation Kind
    /// </summary>
    /// <remarks>
    /// Specifies the kind of annotation, e.g. Technical, Editorial, Archival etc.
    /// </remarks>
    private static readonly byte[] AnnotationKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x02, 0x01, 0x06, 0x0E, 0x01, 0x00, 0x00];
    /// <summary>
    /// Annotation Kind
    /// </summary>
    /// <remarks>
    /// Specifies the kind of annotation, e.g. Technical, Editorial, Archival etc.
    /// </remarks>
    private static readonly byte[] AnnotationKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x02, 0x01, 0x06, 0x0E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Annotation Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Annotation sets
    /// </remarks>
    private static readonly byte[] AnnotationObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x0D, 0x00];
    /// <summary>
    /// Annotation Participant Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of generalized weak (global) references to Participant sets for Annotation
    /// </remarks>
    private static readonly byte[] AnnotationParticipants = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x06, 0x01, 0x01, 0x04, 0x03, 0x40, 0x13, 0x03];
    /// <summary>
    /// Annotation
    /// </summary>
    /// <remarks>
    /// Specifies a reference to an annotation which is stored as essence
    /// </remarks>
    private static readonly byte[] AnnotationSource = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x02, 0x0A, 0x00, 0x00];
    /// <summary>
    /// Annotation Synopsis
    /// </summary>
    /// <remarks>
    /// Synopsis of the A/V content
    /// </remarks>
    private static readonly byte[] AnnotationSynopsis = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x02, 0x01, 0x06, 0x09, 0x01, 0x00, 0x00];
    /// <summary>
    /// Annotation Synopsis
    /// </summary>
    /// <remarks>
    /// Synopsis of the A/V content
    /// </remarks>
    private static readonly byte[] AnnotationSynopsis_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x02, 0x01, 0x06, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// APP Accession Number
    /// </summary>
    /// <remarks>
    /// The accession number identifies a number given to an item being added to the library's long term store system. This number equates to a space on a storage shelf and is therefore a reusable storage identifier.E.g. 'DA 018820'(Infax table T_SPOOL, item acc_prefix and acc_num)
    /// </remarks>
    private static readonly byte[] APP_AccessionNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x00];
    /// <summary>
    /// APP Catalogue Detail
    /// </summary>
    /// <remarks>
    /// A code which allows the user to retrieve catalogue entries by a category. It is a subcatalogue within the catalogue.E.g. 'LONPROG' (Infax table T_CAT_ITEM, item cat_recall)
    /// </remarks>
    private static readonly byte[] APP_CatalogueDetail = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x01, 0x0E, 0x00];
    /// <summary>
    /// APP Descriptive Frameworks
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] APP_DescriptiveFrameworks = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// APP DigiBeta Dropout Count
    /// </summary>
    /// <remarks>
    /// Total number of DigiBeta dropouts detected
    /// </remarks>
    private static readonly byte[] APP_DigiBetaDropoutCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x40, 0x01, 0x03, 0x00];
    /// <summary>
    /// APP DigiBeta Dropout Framework
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] APP_DigiBetaDropoutFramework = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x04, 0x00, 0x00];
    /// <summary>
    /// APP Duration
    /// </summary>
    /// <remarks>
    /// The amount of material used. This is recorded as duration in number of seconds. E.g. 4145 (Infax table T_RECORDING, item rec_duration)
    /// </remarks>
    private static readonly byte[] APP_Duration = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x01, 0x0B, 0x00];
    /// <summary>
    /// APP Episode Title
    /// </summary>
    /// <remarks>
    /// The title of this programme. E.g. 'PICK OF THE YEAR'(Infax table T_PROGRAMME, item core_title)
    /// </remarks>
    private static readonly byte[] APP_EpisodeTitle = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x01, 0x03, 0x00];
    /// <summary>
    /// APP Extended Failure
    /// </summary>
    /// <remarks>
    /// The extended warning failure flag
    /// </remarks>
    private static readonly byte[] APP_ExtendedFailure = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x02, 0x04, 0x00];
    /// <summary>
    /// APP Format
    /// </summary>
    /// <remarks>
    /// The technical code describing the method or recording of this element. E.g. 'LTO', 'D3' (Infax table T_RECORDING, item tech_code)
    /// </remarks>
    private static readonly byte[] APP_Format = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00];
    /// <summary>
    /// APP Infax Framework
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] APP_InfaxFramework = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// APP Item Number
    /// </summary>
    /// <remarks>
    /// Index of the item on the videotape containing multiple items E.g. 1
    /// </remarks>
    private static readonly byte[] APP_ItemNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x01, 0x10, 0x00];
    /// <summary>
    /// APP Luminance Flash
    /// </summary>
    /// <remarks>
    /// The value of the luminance flash analysis, scaled by a factor of 1000
    /// </remarks>
    private static readonly byte[] APP_LuminanceFlash = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x02, 0x03, 0x00];
    /// <summary>
    /// APP Magazine Prefix
    /// </summary>
    /// <remarks>
    /// Programmes are identified by a programme number and optionally a magazine prefix, which consists of a letter, ranging from A to Z. E.g. 'A'(Infax table T_PROGRAMME, item mag_prefix)
    /// </remarks>
    private static readonly byte[] APP_MagazinePrefix = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x01, 0x05, 0x00];
    /// <summary>
    /// APP Memo
    /// </summary>
    /// <remarks>
    /// The catalogue description of the recording. (Infax table T_RECORDING, item rec_cat_desc)
    /// </remarks>
    private static readonly byte[] APP_Memo = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x01, 0x0A, 0x00];
    /// <summary>
    /// APP Preface Additions
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] APP_PrefaceAdditions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x40, 0x00, 0x00, 0x00];
    /// <summary>
    /// APP Preface Additions Version 1
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] APP_PrefaceAdditionsVersion1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x40, 0x01, 0x00, 0x00];
    /// <summary>
    /// APP Production Code
    /// </summary>
    /// <remarks>
    /// The production code assigned to the programme. E.g. 70
    /// </remarks>
    private static readonly byte[] APP_ProductionCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x01, 0x0F, 0x00];
    /// <summary>
    /// APP Programme  Number
    /// </summary>
    /// <remarks>
    /// A number, which in conjunction with the magazine prefix, uniquely identifies a programme. It never changes and stays with the programme throughout its life.E.g. LNF2073N (Infax table T_PROGRAMME, item prog_num)
    /// </remarks>
    private static readonly byte[] APP_ProgrammeNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x01, 0x06, 0x00];
    /// <summary>
    /// APP Programme Title
    /// </summary>
    /// <remarks>
    /// Indicates the series the programme is related to. E.g. 'OLD GREY WHISTLE TEST' (Infax table T_PROGRAMME, item series_title)
    /// </remarks>
    private static readonly byte[] APP_ProgrammeTitle = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x01, 0x02, 0x00];
    /// <summary>
    /// APP PSE Analysis Framework
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] APP_PSEAnalysisFramework = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x02, 0x00, 0x00];
    /// <summary>
    /// APP PSE Failure Count
    /// </summary>
    /// <remarks>
    /// Total number of PSE analysis failures
    /// </remarks>
    private static readonly byte[] APP_PSEFailureCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x40, 0x01, 0x02, 0x00];
    /// <summary>
    /// APP Red Flash
    /// </summary>
    /// <remarks>
    /// The value of the red flash analysis, scaled by a factor of 1000.
    /// </remarks>
    private static readonly byte[] APP_RedFlash = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x02, 0x01, 0x00];
    /// <summary>
    /// APP Spatial Pattern
    /// </summary>
    /// <remarks>
    /// The value of the spatial analysis, scaled by a factor of 1000.
    /// </remarks>
    private static readonly byte[] APP_SpatialPattern = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x02, 0x02, 0x00];
    /// <summary>
    /// APP Spool Descriptor
    /// </summary>
    /// <remarks>
    /// A free format text containing a technical description of the recording. E.g. 'PROGRAMME (DUB OF 005123) (Infax table T_RECORDING, item rec_vt_desc)
    /// </remarks>
    private static readonly byte[] APP_SpoolDescriptor = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x01, 0x09, 0x00];
    /// <summary>
    /// APP Spool Number
    /// </summary>
    /// <remarks>
    /// The numeric component of a spool number. The number and prefix form a spool-number which is usually issued when the material is created. The spool number equates to a gap in the short term store. The number on the spool identifies the last current number for the spool. E.g. 'DA 005123'(Infax table T_SPOOL, item spl_prefix and spl_num)
    /// </remarks>
    private static readonly byte[] APP_SpoolNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x01, 0x0C, 0x00];
    /// <summary>
    /// APP Spool Status
    /// </summary>
    /// <remarks>
    /// This is a code to describe the recording status of spool items.E.g. 'M'(Infax table T_RECORDING, item rec_status
    /// </remarks>
    private static readonly byte[] APP_SpoolStatus = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x01, 0x07, 0x00];
    /// <summary>
    /// APP Stock Date
    /// </summary>
    /// <remarks>
    /// The date on which this element was recorded onto the spool item. E.g. 2008-04-17 (Infax table T_RECORDING, item rec_date)
    /// </remarks>
    private static readonly byte[] APP_StockDate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x01, 0x08, 0x00];
    /// <summary>
    /// APP Strength
    /// </summary>
    /// <remarks>
    /// Normalised Digibeta dropout strength
    /// </remarks>
    private static readonly byte[] APP_Strength = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x04, 0x01, 0x00];
    /// <summary>
    /// APP Timecode Break Count
    /// </summary>
    /// <remarks>
    /// Total number of Timecode break events
    /// </remarks>
    private static readonly byte[] APP_TimecodeBreakCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x40, 0x01, 0x04, 0x00];
    /// <summary>
    /// APP Timecode Break Framework
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] APP_TimecodeBreakFramework = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x05, 0x00, 0x00];
    /// <summary>
    /// APP Timecode Type
    /// </summary>
    /// <remarks>
    /// Flags which timecode types are associated with this event
    /// </remarks>
    private static readonly byte[] APP_TimecodeType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x05, 0x01, 0x00];
    /// <summary>
    /// APP Transmission Date
    /// </summary>
    /// <remarks>
    /// Earliest transmission date E.g. 1978-01-05 (Infax table T_PROGRAMME, item fst_aptx_date)
    /// </remarks>
    private static readonly byte[] APP_TransmissionDate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x01, 0x04, 0x00];
    /// <summary>
    /// APP VTR Error Code
    /// </summary>
    /// <remarks>
    /// Error code reported by the VTR
    /// </remarks>
    private static readonly byte[] APP_VTRErrorCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x03, 0x01, 0x00];
    /// <summary>
    /// APP VTR Error Count
    /// </summary>
    /// <remarks>
    /// Total number of VTR replay errors
    /// </remarks>
    private static readonly byte[] APP_VTRErrorCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x40, 0x01, 0x01, 0x00];
    /// <summary>
    /// APP VTR Replay Error Framework
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] APP_VTRReplayErrorFramework = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x01, 0x03, 0x00, 0x00];
    /// <summary>
    /// Apple Inc.
    /// </summary>
    /// <remarks>
    /// Metadata registered by Apple Inc. for private use
    /// </remarks>
    private static readonly byte[] Apple_Inc = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x0E, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Application Environment ID
    /// </summary>
    /// <remarks>
    /// Identifies the application to which the information in this Plug-In Object applies.
    /// </remarks>
    private static readonly byte[] ApplicationEnvironmentID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x05, 0x20, 0x07, 0x01, 0x0F, 0x00, 0x00, 0x00];
    /// <summary>
    /// Application Identifier
    /// </summary>
    /// <remarks>
    /// Identifying an application and its defining document in the SMPTE ST 2094 suite
    /// </remarks>
    private static readonly byte[] ApplicationIdentifier = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Application Information Array
    /// </summary>
    /// <remarks>
    /// This field is an informative listing of some known applications that use a particular data element.
    /// </remarks>
    private static readonly byte[] ApplicationInformationArray = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x06, 0x01, 0x01, 0x04, 0x06, 0x13, 0x00, 0x00];
    /// <summary>
    /// Application Name
    /// </summary>
    /// <remarks>
    /// Specifies the name of the application product
    /// </remarks>
    private static readonly byte[] ApplicationName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x07, 0x01, 0x03, 0x01, 0x00, 0x00];
    /// <summary>
    /// Application Name
    /// </summary>
    /// <remarks>
    /// Specifies the name of the application product
    /// </remarks>
    private static readonly byte[] ApplicationName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x07, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Application Platform
    /// </summary>
    /// <remarks>
    /// Specifies the platform on which the application was run
    /// </remarks>
    private static readonly byte[] ApplicationPlatform = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x07, 0x01, 0x06, 0x01, 0x00, 0x00];
    /// <summary>
    /// Application Platform
    /// </summary>
    /// <remarks>
    /// Specifies the platform on which the application was run
    /// </remarks>
    private static readonly byte[] ApplicationPlatform_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x07, 0x01, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Application Plug-In Instance ID
    /// </summary>
    /// <remarks>
    /// UUID of this application metadata plug-in.
    /// </remarks>
    private static readonly byte[] ApplicationPluginInstanceID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x05, 0x20, 0x07, 0x01, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Application Plug-In Batch
    /// </summary>
    /// <remarks>
    /// A batch of strong references to Application Plug-In Objects
    /// </remarks>
    private static readonly byte[] ApplicationPlugInObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x06, 0x01, 0x01, 0x04, 0x02, 0x0E, 0x00, 0x00];
    /// <summary>
    /// Application Product ID
    /// </summary>
    /// <remarks>
    /// Specifies a reference to the application product definition
    /// </remarks>
    private static readonly byte[] ApplicationProductID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x07, 0x01, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Application Scheme
    /// </summary>
    /// <remarks>
    /// Contains the Universal Label of the Application Metadata scheme contained in this Plug-In Object.
    /// </remarks>
    private static readonly byte[] ApplicationScheme = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x04, 0x06, 0x08, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Application Scheme Batch
    /// </summary>
    /// <remarks>
    /// A batch of Universal Labels of all the Application Metadata schemes used in a file.
    /// </remarks>
    private static readonly byte[] ApplicationSchemes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x01, 0x02, 0x02, 0x10, 0x02, 0x03, 0x00, 0x00];
    /// <summary>
    /// Application Specifications Version 1
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] ApplicationSpecificationsVersion1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Application Supplier Name
    /// </summary>
    /// <remarks>
    /// Specifies the name of the application provider
    /// </remarks>
    private static readonly byte[] ApplicationSupplierName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x07, 0x01, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Application Supplier Name
    /// </summary>
    /// <remarks>
    /// Specifies the name of the application provider
    /// </remarks>
    private static readonly byte[] ApplicationSupplierName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x07, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Application Version Number
    /// </summary>
    /// <remarks>
    /// Specifies version information for the application
    /// </remarks>
    private static readonly byte[] ApplicationVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x07, 0x01, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Application Version Number
    /// </summary>
    /// <remarks>
    /// The Application Version of the identified SMPTE ST 2094 application
    /// </remarks>
    private static readonly byte[] ApplicationVersionNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Application Version String
    /// </summary>
    /// <remarks>
    /// Specifies version information for the application in textual form
    /// </remarks>
    private static readonly byte[] ApplicationVersionString = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x07, 0x01, 0x05, 0x01, 0x00, 0x00];
    /// <summary>
    /// Application Version String
    /// </summary>
    /// <remarks>
    /// Specifies version information for the application in textual form
    /// </remarks>
    private static readonly byte[] ApplicationVersionString_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x07, 0x01, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Approximate Image Container Size
    /// </summary>
    /// <remarks>
    /// Identifies, to an order of magnitude, the size of the image
    /// </remarks>
    private static readonly byte[] ApproxImageContainerSize = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x04, 0x06, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Archive ID
    /// </summary>
    /// <remarks>
    /// Identifier for archival purposes
    /// </remarks>
    private static readonly byte[] ArchiveID_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Archive Preservation Project
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] ArchivePreservationProject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Archive Preservation Project Version 1
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] ArchivePreservationProjectVersion1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// ARIB
    /// </summary>
    /// <remarks>
    /// Metadata registered by the Association of Radio Industries and Businesses (Japan) for public use
    /// </remarks>
    private static readonly byte[] ARIB = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x0D, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// ARRI
    /// </summary>
    /// <remarks>
    /// Metadata registered by Arnold &amp; Richter Cine Technik GmbH for private use
    /// </remarks>
    private static readonly byte[] ARRI = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// AS-03 Identifier
    /// </summary>
    /// <remarks>
    /// The program identifier as a text string, e.g. P900000HD
    /// </remarks>
    private static readonly byte[] AS_03_Identifier = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x04, 0x01, 0x03, 0x01, 0x02, 0x00];
    /// <summary>
    /// AS-03 Identifier Kind
    /// </summary>
    /// <remarks>
    /// A controlled-vocabulary string value indicating the kind of program identifier, e.g. PBS PackageID
    /// </remarks>
    private static readonly byte[] AS_03_IdentifierKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x04, 0x01, 0x03, 0x01, 0x01, 0x00];
    /// <summary>
    /// AS-03 Intended AFD
    /// </summary>
    /// <remarks>
    /// A string value indicating the intended display format for the program, per SMPTE 2016-1 table 1 a3 a2 a1 a0 with optional informative appended text e.g. 1001 Pillarbox, 0100 Letterbox, 1000 FullHD
    /// </remarks>
    private static readonly byte[] AS_03_IntendedAFD = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x04, 0x01, 0x03, 0x01, 0x05, 0x00];
    /// <summary>
    /// AS-03 Nielsen Stream Identifier
    /// </summary>
    /// <remarks>
    /// A string that specifies Nielsen stream identifier for the program
    /// </remarks>
    private static readonly byte[] AS_03_NielsenStreamIdentifier = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x04, 0x01, 0x03, 0x01, 0x09, 0x00];
    /// <summary>
    /// AS-03 NOLA Code
    /// </summary>
    /// <remarks>
    /// A string that specifies the program series code and episode number, e.g. SESA 4187
    /// </remarks>
    private static readonly byte[] AS_03_NOLACode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x04, 0x01, 0x03, 0x01, 0x07, 0x00];
    /// <summary>
    /// AS-03 Rating
    /// </summary>
    /// <remarks>
    /// A controlled-vocabulary string that specifies the V-Chip rating of the program, e.g. TV-G
    /// </remarks>
    private static readonly byte[] AS_03_Rating = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x04, 0x01, 0x03, 0x01, 0x08, 0x00];
    /// <summary>
    /// AS-03 Shim Name
    /// </summary>
    /// <remarks>
    /// A controlled-vocabulary string value indicating the AS-03 Shim Name, e.g. PBS NGIS HD Playout
    /// </remarks>
    private static readonly byte[] AS_03_ShimName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x04, 0x01, 0x03, 0x01, 0x03, 0x00];
    /// <summary>
    /// AS-03 Signal Standard
    /// </summary>
    /// <remarks>
    /// A controlled-vocabulary string value indicating the signal standard of video contained in this AS-03 file
    /// </remarks>
    private static readonly byte[] AS_03_SignalStandard = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x04, 0x01, 0x03, 0x01, 0x04, 0x00];
    /// <summary>
    /// AS-03 Slate Title
    /// </summary>
    /// <remarks>
    /// A string that specifies a program title to be displayed to traffic and master control operators, e.g. Sesame Street
    /// </remarks>
    private static readonly byte[] AS_03_SlateTitle = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x04, 0x01, 0x03, 0x01, 0x06, 0x00];
    /// <summary>
    /// AS_07
    /// </summary>
    /// <remarks>
    /// AS-07 Archiving and Preservation Format
    /// </remarks>
    private static readonly byte[] AS_07 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// AS_07_Core_DMS_AudioTrackLayout
    /// </summary>
    /// <remarks>
    /// Appropriate values in AS-07 Appendix E
    /// </remarks>
    private static readonly byte[] AS_07_Core_DMS_AudioTrackLayout = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x01, 0x0E];
    /// <summary>
    /// AS_07_Core_DMS_AudioTrackLayoutComment
    /// </summary>
    /// <remarks>
    /// Free text comment to augment AS_07_Core_DMS_AudioTrackLayout. This is for track tagging information and is not to be used for descriptive essays. Robust descriptive data can be held in Supplemental Metadata in GSPs.
    /// </remarks>
    private static readonly byte[] AS_07_Core_DMS_AudioTrackLayoutComment = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x01, 0x0F];
    /// <summary>
    /// AS_07_Core_DMS_AudioTrackPrimaryLanguage
    /// </summary>
    /// <remarks>
    /// The primary language in audio track by codes as defined by RFC5646. Use only when language is known.
    /// </remarks>
    private static readonly byte[] AS_07_Core_DMS_AudioTrackPrimaryLanguage = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x01, 0x0C];
    /// <summary>
    /// AS_07_Core_DMS_AudioTrackSecondaryLanguage
    /// </summary>
    /// <remarks>
    /// The secondary language in audio track by codes as defined by RFC5646.  If multiple secondary language are present the RFC tags in white space separated list. Use only when secondary languages are present and language is known
    /// </remarks>
    private static readonly byte[] AS_07_Core_DMS_AudioTrackSecondaryLanguage = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x01, 0x0D];
    /// <summary>
    /// AS_07_Core_DMS_Captions
    /// </summary>
    /// <remarks>
    /// Y/N value to indicate if  captions are present in the encoded file
    /// </remarks>
    private static readonly byte[] AS_07_Core_DMS_Captions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x01, 0x0B];
    /// <summary>
    /// AS_07_Core_DMS_DeviceManufacturer
    /// </summary>
    /// <remarks>
    /// The manufacturer or maker of the device
    /// </remarks>
    private static readonly byte[] AS_07_Core_DMS_DeviceManufacturer = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x02, 0x03];
    /// <summary>
    /// AS_07_Core_DMS_DeviceModel
    /// </summary>
    /// <remarks>
    /// Identifies the device model used in capturing or generating the essence.
    /// </remarks>
    private static readonly byte[] AS_07_Core_DMS_DeviceModel = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x02, 0x04];
    /// <summary>
    /// AS_07_Core_DMS_Devices
    /// </summary>
    /// <remarks>
    /// strong references to all AS_07_Core_DMS_Device objects used in this file
    /// </remarks>
    private static readonly byte[] AS_07_Core_DMS_Devices = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x01, 0x10];
    /// <summary>
    /// AS_07_Core_DMS_DeviceSerialNumber
    /// </summary>
    /// <remarks>
    /// Alphanumeric serial number identifying the individual device
    /// </remarks>
    private static readonly byte[] AS_07_Core_DMS_DeviceSerialNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x02, 0x05];
    /// <summary>
    /// AS_07_Core_DMS_DeviceType
    /// </summary>
    /// <remarks>
    /// the kind of device used to capture or create the content (as either a commonly known name or as a locally defined name; e.g., Radio-camera)
    /// </remarks>
    private static readonly byte[] AS_07_Core_DMS_DeviceType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x02, 0x02];
    /// <summary>
    /// AS_07_Core_DMS_DeviceUsageDescription
    /// </summary>
    /// <remarks>
    /// Free text description of the function or use of the device in the production of a specific content item
    /// </remarks>
    private static readonly byte[] AS_07_Core_DMS_DeviceUsageDescription = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x02, 0x06];
    /// <summary>
    /// AS_07_Core_DMS_Identifiers
    /// </summary>
    /// <remarks>
    /// Unordered list of strong references to all AS_07_DMS_Identifier sets. At least one AS_07_DMS_Identifier Objects set is required with the IdentifierRole = Main. Other AS_07_DMSIdentifierObjects sets are optional.
    /// </remarks>
    private static readonly byte[] AS_07_Core_DMS_Identifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x01, 0x02];
    /// <summary>
    /// AS_07_Core_DMS_IntendedAFD
    /// </summary>
    /// <remarks>
    /// String value indicating the intended display format for the program, per SMPTE 2016-1 table 1 a3 a2 a1 a0 with optional informative appended text e.g. 1001 Pillarbox, 0100 Letterbox, 1000 FullHD
    /// </remarks>
    private static readonly byte[] AS_07_Core_DMS_IntendedAFD = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x01, 0x0A];
    /// <summary>
    /// AS_07_Core_DMS_NatureOfOrganization
    /// </summary>
    /// <remarks>
    /// The nature of an organization (e.g., limited company, government department, etc.)
    /// </remarks>
    private static readonly byte[] AS_07_Core_DMS_NatureOfOrganization = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x01, 0x06];
    /// <summary>
    /// AS_07_Core_DMS_PictureFormat
    /// </summary>
    /// <remarks>
    /// The signal standard (frame resolution and aspect ratio) of the encoded file.
    /// </remarks>
    private static readonly byte[] AS_07_Core_DMS_PictureFormat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x01, 0x09];
    /// <summary>
    /// AS_07_Core_DMS_ResponsibleOrganizationCode
    /// </summary>
    /// <remarks>
    /// A familiar abbreviation of entity name.
    /// </remarks>
    private static readonly byte[] AS_07_Core_DMS_ResponsibleOrganizationCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x01, 0x05];
    /// <summary>
    /// AS_07_Core_DMS_ResponsibleOrganizationName
    /// </summary>
    /// <remarks>
    /// The main name for the entity responsible for the creation, maintenance, preservation of this digital item
    /// </remarks>
    private static readonly byte[] AS_07_Core_DMS_ResponsibleOrganizationName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x01, 0x03];
    /// <summary>
    /// AS_07_Core_DMS_SecondaryTitle
    /// </summary>
    /// <remarks>
    /// Free text Secondary title of the production or production component
    /// </remarks>
    private static readonly byte[] AS_07_Core_DMS_SecondaryTitle = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x01, 0x08];
    /// <summary>
    /// AS_07_Core_DMS_ShimName
    /// </summary>
    /// <remarks>
    /// Controlled vocabulary string value indicating the AS-07 Shim Name, e.g., Derived-from-video-serial-interface
    /// </remarks>
    private static readonly byte[] AS_07_Core_DMS_ShimName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x01, 0x01];
    /// <summary>
    /// AS_07_Core_DMS_WorkingTitle
    /// </summary>
    /// <remarks>
    /// Free text: Best known or working title of the production or production component
    /// </remarks>
    private static readonly byte[] AS_07_Core_DMS_WorkingTitle = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x01, 0x07];
    /// <summary>
    /// AS_07_DateTimeChannelID
    /// </summary>
    /// <remarks>
    /// The numerical channel identifier within the essence, if applicable.
    /// </remarks>
    private static readonly byte[] AS_07_DateTimeChannelID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x04, 0x01, 0x03];
    /// <summary>
    /// AS_07_DateTimeDescription
    /// </summary>
    /// <remarks>
    /// Additional optional text description of the timecode origin or role or details
    /// </remarks>
    private static readonly byte[] AS_07_DateTimeDescription = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x04, 0x01, 0x04];
    /// <summary>
    /// AS_07_DateTimeEssenceTrackID
    /// </summary>
    /// <remarks>
    /// Link to (value of) the Track ID of the audio track where the timecode data is stored in a Top Level Source Package
    /// </remarks>
    private static readonly byte[] AS_07_DateTimeEssenceTrackID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x04, 0x01, 0x02];
    /// <summary>
    /// AS_07_DateTimeSymbol
    /// </summary>
    /// <remarks>
    /// Symbol that specifies the timecode, values listed in the SMPTE Labels Register as defined by SMPTE ST 400
    /// </remarks>
    private static readonly byte[] AS_07_DateTimeSymbol = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x04, 0x01, 0x01];
    /// <summary>
    /// AS_07_DMS_Elements
    /// </summary>
    /// <remarks>
    /// AS-07 Archiving and Preservation Format Descriptive Metadata Elements
    /// </remarks>
    private static readonly byte[] AS_07_DMS_Elements = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x00, 0x00];
    /// <summary>
    /// AS_07_DMS_IdentifierComment
    /// </summary>
    /// <remarks>
    /// Free text comment pertaining to the additional identifier
    /// </remarks>
    private static readonly byte[] AS_07_DMS_IdentifierComment = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x03, 0x05];
    /// <summary>
    /// AS_07_DMS_IdentifierRole
    /// </summary>
    /// <remarks>
    /// Controlled vocabulary string value identifying the role of identifier
    /// </remarks>
    private static readonly byte[] AS_07_DMS_IdentifierRole = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x03, 0x03];
    /// <summary>
    /// AS_07_DMS_IdentifierType
    /// </summary>
    /// <remarks>
    /// Controlled vocabulary string value identifying the type of identifier
    /// </remarks>
    private static readonly byte[] AS_07_DMS_IdentifierType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x03, 0x04];
    /// <summary>
    /// AS_07_DMS_IdentifierValue
    /// </summary>
    /// <remarks>
    /// Identifier Value
    /// </remarks>
    private static readonly byte[] AS_07_DMS_IdentifierValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x03, 0x02];
    /// <summary>
    /// AS_07_Elements
    /// </summary>
    /// <remarks>
    /// AS-07 Archiving and Preservation Format Elements
    /// </remarks>
    private static readonly byte[] AS_07_Elements = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// AS_07_GSP_DMS_DataDescription
    /// </summary>
    /// <remarks>
    /// Controlled vocabulary string identifying the role of the data within the AS-07 file
    /// </remarks>
    private static readonly byte[] AS_07_GSP_DMS_DataDescription = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x04, 0x03];
    /// <summary>
    /// AS_07_GSP_DMS_Identifiers
    /// </summary>
    /// <remarks>
    /// Unordered list of strong references to all AS_07_DMS_Identifier sets. At least one AS_07_DMS_Identifier Objects set is required with the IdentifierRole = Main. Other AS_07_DMSIdentifierObjects sets are optional.
    /// </remarks>
    private static readonly byte[] AS_07_GSP_DMS_Identifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x04, 0x01];
    /// <summary>
    /// AS_07_GSP_DMS_MIMEMediaType
    /// </summary>
    /// <remarks>
    /// Text string that defines the data type of the text. A value shall be selected from the values listed at the following web site. http://www.iana.org/assignments/media-types/text/
    /// </remarks>
    private static readonly byte[] AS_07_GSP_DMS_MIMEMediaType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x04, 0x02];
    /// <summary>
    /// AS_07_GSP_DMS_Note
    /// </summary>
    /// <remarks>
    /// Free text note pertaining to the GSP data payload.
    /// </remarks>
    private static readonly byte[] AS_07_GSP_DMS_Note = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x01, 0x04, 0x04];
    /// <summary>
    /// AS_07_GSP_Elements
    /// </summary>
    /// <remarks>
    /// AS-07 Archiving and Preservation Format Generic Stream Partition Elements
    /// </remarks>
    private static readonly byte[] AS_07_GSP_Elements = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x02, 0x00, 0x00];
    /// <summary>
    /// AS_07_GSP_TD_DMS_PrimaryRFC5646LanguageCode
    /// </summary>
    /// <remarks>
    /// Identifies the primary language in Timed Text by codes defined by RFC5646
    /// </remarks>
    private static readonly byte[] AS_07_GSP_TD_DMS_PrimaryRFC5646LanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x02, 0x03, 0x01];
    /// <summary>
    /// AS_07_GSP_TD_DMS_SecondaryRFC5646LanguageCode
    /// </summary>
    /// <remarks>
    /// Identifies the secondary language in Timed Text by codes defined by RFC5646.  If multiple secondary languages are present, the RFC tags in white space separated list. Use only when secondary languages are present and language is known.
    /// </remarks>
    private static readonly byte[] AS_07_GSP_TD_DMS_SecondaryRFC5646LanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x02, 0x03, 0x02];
    /// <summary>
    /// AS_07_Segmentation_DMS_PartNumber
    /// </summary>
    /// <remarks>
    /// Identifier for the part number. Combined with AS_07_Segmentation_DMS_PartTotal, these metadata items represent part numbers of the form 1 of 3, 2 of 3, 3 of 3 with AS_07_Segmentation_DMS_PartNumber being the first integer.
    /// </remarks>
    private static readonly byte[] AS_07_Segmentation_DMS_PartNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x03, 0x01, 0x01];
    /// <summary>
    /// AS_07_Segmentation_DMS_PartTotal
    /// </summary>
    /// <remarks>
    /// The total number of parts in the program. Combined with AS_07_Segmentation_DMS_PartNumber, these metadata items represent part numbers of the form 1 of 3, 2 of 3, 3 of 3 with AS_07_Segmentation_DMS_PartTotal being the second integer.
    /// </remarks>
    private static readonly byte[] AS_07_Segmentation_DMS_PartTotal = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x03, 0x01, 0x02];
    /// <summary>
    /// AS_07_Segmentation_Elements
    /// </summary>
    /// <remarks>
    /// AS-07 Archiving and Preservation Format SegmentationElements
    /// </remarks>
    private static readonly byte[] AS_07_Segmentation_Elements = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x03, 0x00, 0x00];
    /// <summary>
    /// AS-10
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] AS_10 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// AS-10 Common Spanning ID
    /// </summary>
    /// <remarks>
    /// UMID for the total spanning clips
    /// </remarks>
    private static readonly byte[] AS_10_Common_Spanning_ID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0A, 0x01, 0x01, 0x09];
    /// <summary>
    /// AS-10 Cumulative Duration
    /// </summary>
    /// <remarks>
    /// Cumulative Duration of preceding spanning clips in this set (spanning number 0 up to this-1), in Edit Units
    /// </remarks>
    private static readonly byte[] AS_10_Cumulative_Duration = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0A, 0x01, 0x01, 0x0B];
    /// <summary>
    /// AS-10 Location Description
    /// </summary>
    /// <remarks>
    /// The text description of a location
    /// </remarks>
    private static readonly byte[] AS_10_Location_Description = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0A, 0x01, 0x01, 0x08];
    /// <summary>
    /// AS-10 Main Title
    /// </summary>
    /// <remarks>
    /// Main title associated with the clip
    /// </remarks>
    private static readonly byte[] AS_10_Main_Title = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0A, 0x01, 0x01, 0x03];
    /// <summary>
    /// AS-10 Organization Name
    /// </summary>
    /// <remarks>
    /// The name of a Organization
    /// </remarks>
    private static readonly byte[] AS_10_Organization_Name = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0A, 0x01, 0x01, 0x06];
    /// <summary>
    /// AS-10 Person Name
    /// </summary>
    /// <remarks>
    /// The name of a Person
    /// </remarks>
    private static readonly byte[] AS_10_Person_Name = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0A, 0x01, 0x01, 0x07];
    /// <summary>
    /// AS-10 Shim Name
    /// </summary>
    /// <remarks>
    /// The name of the AS_10 shim
    /// </remarks>
    private static readonly byte[] AS_10_Shim_Name = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0A, 0x01, 0x01, 0x01];
    /// <summary>
    /// AS-10 Spanning Number
    /// </summary>
    /// <remarks>
    /// Identifier for the spanning number (1st clip: 00 01)
    /// </remarks>
    private static readonly byte[] AS_10_Spanning_Number = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0A, 0x01, 0x01, 0x0A];
    /// <summary>
    /// AS-10 Sub Title
    /// </summary>
    /// <remarks>
    /// Sub title associated with the clip
    /// </remarks>
    private static readonly byte[] AS_10_Sub_Title = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0A, 0x01, 0x01, 0x04];
    /// <summary>
    /// AS-10 Title Description
    /// </summary>
    /// <remarks>
    /// Title description associated with the clip
    /// </remarks>
    private static readonly byte[] AS_10_Title_Description = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0A, 0x01, 0x01, 0x05];
    /// <summary>
    /// AS-10 Type
    /// </summary>
    /// <remarks>
    /// Type that describes the production category of clip
    /// </remarks>
    private static readonly byte[] AS_10_Type = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0A, 0x01, 0x01, 0x02];
    /// <summary>
    /// AS-11
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] AS_11 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Track Layout
    /// </summary>
    /// <remarks>
    /// A code to identify the scheme that describes the usage of the audio channels encoded in the file.
    /// </remarks>
    private static readonly byte[] AS_11_Audio_Track_Layout = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0B, 0x01, 0x01, 0x05];
    /// <summary>
    /// Closed Captions Language
    /// </summary>
    /// <remarks>
    /// A code to identify the main language used in the closed captions.
    /// </remarks>
    private static readonly byte[] AS_11_Caption_Language = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0B, 0x01, 0x01, 0x09];
    /// <summary>
    /// Closed Captions Present
    /// </summary>
    /// <remarks>
    /// A flag to indicate whether the programme contains embedded (out of vision) subtitling information.
    /// </remarks>
    private static readonly byte[] AS_11_Closed_Captions_Present = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0B, 0x01, 0x01, 0x07];
    /// <summary>
    /// Closed Captions Type
    /// </summary>
    /// <remarks>
    /// A code to identify the editorial description of the closed captions.
    /// </remarks>
    private static readonly byte[] AS_11_Closed_Captions_Type = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0B, 0x01, 0x01, 0x08];
    /// <summary>
    /// Episode Title/Episode No.
    /// </summary>
    /// <remarks>
    /// The final name of the programme used to identify it as an editorially distinct member of a series i.e. an episode. This name may include a number (or consist only of a number) indicating the position of the episode within the series.
    /// </remarks>
    private static readonly byte[] AS_11_Episode_Title_Number = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0B, 0x01, 0x01, 0x03];
    /// <summary>
    /// Part Number
    /// </summary>
    /// <remarks>
    /// A number that both: uniquely identifies the part / segment within the programme; and identifies the position of the part / segment within the programme.
    /// </remarks>
    private static readonly byte[] AS_11_Part_Number = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0B, 0x02, 0x01, 0x01];
    /// <summary>
    /// Part Total
    /// </summary>
    /// <remarks>
    /// The count of parts / segments in the entire programme.
    /// </remarks>
    private static readonly byte[] AS_11_Part_Total = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0B, 0x02, 0x01, 0x02];
    /// <summary>
    /// Primary Audio Language
    /// </summary>
    /// <remarks>
    /// A code to identify the main language used on primary audio channels.
    /// </remarks>
    private static readonly byte[] AS_11_Primary_Audio_Language = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0B, 0x01, 0x01, 0x06];
    /// <summary>
    /// Programme Title
    /// </summary>
    /// <remarks>
    /// The final name of the programme used to identify it as a version of an episode. This name indicates the specific purpose for which the version was created.
    /// </remarks>
    private static readonly byte[] AS_11_Programme_Title = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0B, 0x01, 0x01, 0x02];
    /// <summary>
    /// Series Title
    /// </summary>
    /// <remarks>
    /// The final name of a "group" of episodes to which the programme belongs. These episodes have a shared identification and branding and are linked by common characters, subject matter, style or story.
    /// </remarks>
    private static readonly byte[] AS_11_Series_Title = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0B, 0x01, 0x01, 0x01];
    /// <summary>
    /// Shim Name
    /// </summary>
    /// <remarks>
    /// The name of the AS-11 shim specification to which the MXF file conforms.
    /// </remarks>
    private static readonly byte[] AS_11_Shim_Name = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0B, 0x01, 0x01, 0x04];
    /// <summary>
    /// Shim Version
    /// </summary>
    /// <remarks>
    /// The version of the AS-11 shim specification to which the MXF file conforms.
    /// </remarks>
    private static readonly byte[] AS_11_Shim_Version = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0B, 0x01, 0x01, 0x0A];
    /// <summary>
    /// AS-12
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] AS_12 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// AS_12_ShimName
    /// </summary>
    /// <remarks>
    /// An informative shim name that identifies the specification for provider dependent metadata that may be shimmed into this file. E.g. "Ad-ID Digital Identification". Note, this string is informative therefore should not be considered to be a definitive indication that additional, shimmed, metadata is present in the file. The definitive indication is the presence of a shim's concrete subclass of "AS_12_DescriptiveObject".
    /// </remarks>
    private static readonly byte[] AS_12_ShimName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0C, 0x01, 0x01, 0x01];
    /// <summary>
    /// AS_12_Slate
    /// </summary>
    /// <remarks>
    /// A Strong Reference to the provider dependent metadata contained in a Descriptive Object as defined by the provider dependent shim
    /// </remarks>
    private static readonly byte[] AS_12_Slate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0C, 0x01, 0x01, 0x02];
    /// <summary>
    /// ASC
    /// </summary>
    /// <remarks>
    /// Metadata registered by the American Society of Cinematographers for public use
    /// </remarks>
    private static readonly byte[] ASC = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x0D, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// ASC CDL V1.2
    /// </summary>
    /// <remarks>
    /// 10 parameters of ASC Color Decision List V1.2.
    /// </remarks>
    private static readonly byte[] ASCCDLV12 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x01, 0x03, 0x02, 0x08, 0x00, 0x00];
    /// <summary>
    /// Ascent Media Group, Inc.
    /// </summary>
    /// <remarks>
    /// Metadata registered by Ascent Media Group, Inc. for private use
    /// </remarks>
    private static readonly byte[] AscentMediaGroupInc = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// ASM Bad Request Copy
    /// </summary>
    /// <remarks>
    /// A copy of the ASM request KLV pack that was misunderstood.
    /// </remarks>
    private static readonly byte[] ASMBadRequestCopy = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x07, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// ASM Buffer Overflow Flag
    /// </summary>
    /// <remarks>
    /// A boolean value indicating whether the key buffer would have overflowed.
    /// </remarks>
    private static readonly byte[] ASMBufferOverflowFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// ASM Current Time
    /// </summary>
    /// <remarks>
    /// The current UTC time expressed as a 64-bit integer representing the number of seconds elapsed since midnight, January 1, 1970.
    /// </remarks>
    private static readonly byte[] ASMCurrentTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x07, 0x02, 0x01, 0x01, 0x01, 0x08, 0x00, 0x00];
    /// <summary>
    /// ASM Event ID
    /// </summary>
    /// <remarks>
    /// An identifier associated with the Auditorium Security Message log record item.
    /// </remarks>
    private static readonly byte[] ASMEventID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x03, 0x08, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// ASM Event ID Batch
    /// </summary>
    /// <remarks>
    /// An unordered batch of ASM event identifiers.
    /// </remarks>
    private static readonly byte[] ASMEventIDBatch = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x06, 0x01, 0x01, 0x03, 0x0F, 0x00, 0x00, 0x00];
    /// <summary>
    /// ASM Event List Start Time
    /// </summary>
    /// <remarks>
    /// Start of the event list period.
    /// </remarks>
    private static readonly byte[] ASMEventListStartTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x07, 0x02, 0x01, 0x02, 0x07, 0x03, 0x00, 0x00];
    /// <summary>
    /// ASM Event List Stop Time
    /// </summary>
    /// <remarks>
    /// Stop of the event list period.
    /// </remarks>
    private static readonly byte[] ASMEventListStopTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x07, 0x02, 0x01, 0x02, 0x0A, 0x02, 0x00, 0x00];
    /// <summary>
    /// ASM Key Not Present Flag
    /// </summary>
    /// <remarks>
    /// A boolean value indicating that the identified key to be purged was not present.
    /// </remarks>
    private static readonly byte[] ASMKeyNotPresentFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x07, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// ASM Key Present Flag
    /// </summary>
    /// <remarks>
    /// A boolean value indicating whether the encryption key is present.
    /// </remarks>
    private static readonly byte[] ASMKeyPresentFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x07, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// ASM Link Encryption Key Batch
    /// </summary>
    /// <remarks>
    /// An unordered batch of link encryption key ID, encryption key, expiration time, and attribute data.
    /// </remarks>
    private static readonly byte[] ASMLinkEncryptionKeyBatch = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x06, 0x01, 0x01, 0x03, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// ASM Link Encryption Key ID
    /// </summary>
    /// <remarks>
    /// An identifier associated with the link encryption key.
    /// </remarks>
    private static readonly byte[] ASMLinkEncryptionKeyID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x03, 0x08, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// ASM Link Encryption Key ID Batch
    /// </summary>
    /// <remarks>
    /// An unordered batch of ASM encryption key identifiers.
    /// </remarks>
    private static readonly byte[] ASMLinkEncryptionKeyIDBatch = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x06, 0x01, 0x01, 0x03, 0x11, 0x00, 0x00, 0x00];
    /// <summary>
    /// ASM Log Record
    /// </summary>
    /// <remarks>
    /// The logged information associated with a specific event expressed as XML.
    /// </remarks>
    private static readonly byte[] ASMLogRecord = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x07, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// ASM Playout Status
    /// </summary>
    /// <remarks>
    /// An enumerated value that describes whether a security playout function is being performed.
    /// </remarks>
    private static readonly byte[] ASMPlayoutStatus = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// ASM Projector Certificate Data
    /// </summary>
    /// <remarks>
    /// Projector certificate coded using Distinguished Encoding Rules (DER) encoding
    /// </remarks>
    private static readonly byte[] ASMProjectorCertificateData = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x07, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// ASM Protocol Version
    /// </summary>
    /// <remarks>
    /// A value indicating the protocol suite version in use.
    /// </remarks>
    private static readonly byte[] ASMProtocolVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x07, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// ASM Request ID
    /// </summary>
    /// <remarks>
    /// An identifier associated with the Auditorium Security Message request.
    /// </remarks>
    private static readonly byte[] ASMRequestID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x03, 0x08, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// ASM Response
    /// </summary>
    /// <remarks>
    /// An enumerated value that describes the result of the request.
    /// </remarks>
    private static readonly byte[] ASMResponse = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// ASPA
    /// </summary>
    /// <remarks>
    /// Unclassified metadata registered by MISB (Motion Imagery Standards Board) for ASPA
    /// </remarks>
    private static readonly byte[] ASPA = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Aspect Ratio
    /// </summary>
    /// <remarks>
    /// A set of attributes to define an aspect ratio
    /// </remarks>
    private static readonly byte[] aspectRatio = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Aspect Ratio Factor Denominator
    /// </summary>
    /// <remarks>
    /// The denominator
    /// </remarks>
    private static readonly byte[] aspectRatioDenominator = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x40, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Aspect Ratio Factor Numerator
    /// </summary>
    /// <remarks>
    /// The numerator
    /// </remarks>
    private static readonly byte[] aspectRatioNumerator = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x40, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Aspect Ratios
    /// </summary>
    /// <remarks>
    /// Specifies the horizontal to vertical aspect ratio of the image.
    /// </remarks>
    private static readonly byte[] AspectRatios = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Aspect Ratio Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group to specify the type of aspect ratio being described
    /// </remarks>
    private static readonly byte[] aspectRatioTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x40, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Assessments
    /// </summary>
    /// <remarks>
    /// Assesments of editorial, technical etc aspects of the content and contributors to it
    /// </remarks>
    private static readonly byte[] Assessments = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// AssetIntegrityHash Batch
    /// </summary>
    /// <remarks>
    /// An unordered batch of Asset ID and associated Asset Hash values
    /// </remarks>
    private static readonly byte[] AssetIntegrityHashBatch = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x0F, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Asset Value
    /// </summary>
    /// <remarks>
    /// Assessment of the program quality
    /// </remarks>
    private static readonly byte[] AssetValue_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Assigned Category Name
    /// </summary>
    /// <remarks>
    /// Freeform textual name assigned by the user to a category - as in, for example, a column header
    /// </remarks>
    private static readonly byte[] AssignedCategoryName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x01, 0x02, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Assigned Category Value
    /// </summary>
    /// <remarks>
    /// Freeform textual value for an assigned category
    /// </remarks>
    private static readonly byte[] AssignedCategoryValue_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x01, 0x02, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Content Classification
    /// </summary>
    /// <remarks>
    /// Content classification
    /// </remarks>
    private static readonly byte[] AssignedContentClassification = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Astronomical Body Name
    /// </summary>
    /// <remarks>
    /// The name of the astronomical body as a string
    /// </remarks>
    private static readonly byte[] AstronomicalBodyName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x16, 0x01];
    /// <summary>
    /// Astronomical Body Name
    /// </summary>
    /// <remarks>
    /// The name of the astronomical body as a string
    /// </remarks>
    private static readonly byte[] AstronomicalBodyName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x16, 0x00];
    /// <summary>
    /// Attribute groups
    /// </summary>
    /// <remarks>
    /// The definitions of attribute groups used in EBUCore
    /// </remarks>
    private static readonly byte[] attributeGroups = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audience
    /// </summary>
    /// <remarks>
    /// To define an audience.
    /// </remarks>
    private static readonly byte[] audience = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5D, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audience Adult Content Flag
    /// </summary>
    /// <remarks>
    /// A flag to indicate that the media resource contains adult content.
    /// </remarks>
    private static readonly byte[] audienceAdultContentFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5D, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audience Appreciation
    /// </summary>
    /// <remarks>
    /// The appeciation index of the program, expressed as points out of 100.
    /// </remarks>
    private static readonly byte[] AudienceAppreciation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x02, 0x20, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audience Exclusion Region Sets
    /// </summary>
    /// <remarks>
    /// To define regions where the defined audience doesn't apply
    /// </remarks>
    private static readonly byte[] audienceExclusionRegionObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5D, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audience Format group Set
    /// </summary>
    /// <remarks>
    /// To define the audience definition system used.
    /// </remarks>
    private static readonly byte[] audienceFormatGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5D, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audience Level Sets
    /// </summary>
    /// <remarks>
    /// To define the level of destined audience.
    /// </remarks>
    private static readonly byte[] audienceLevelObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0E, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audience Link To Logo
    /// </summary>
    /// <remarks>
    /// To provide a link to a logo associated with the audience.
    /// </remarks>
    private static readonly byte[] audienceLinkToLogo = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5D, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audience Not rated Flag
    /// </summary>
    /// <remarks>
    /// A flag to indicate that content was not rated.
    /// </remarks>
    private static readonly byte[] audienceNotRatedFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5D, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audience Rating
    /// </summary>
    /// <remarks>
    /// Audience rating as number of viewers
    /// </remarks>
    private static readonly byte[] AudienceRating = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x20, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audience Rating Sets
    /// </summary>
    /// <remarks>
    /// The audience rating for a media resource.
    /// </remarks>
    private static readonly byte[] audienceRatingObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x02, 0x16, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audience Reach
    /// </summary>
    /// <remarks>
    /// The audience reach of the production
    /// </remarks>
    private static readonly byte[] AudienceReach = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x20, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audience Reason
    /// </summary>
    /// <remarks>
    /// The reason hy this audience has been selected.
    /// </remarks>
    private static readonly byte[] audienceReason = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5D, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audience Region Sets
    /// </summary>
    /// <remarks>
    /// To define regions where the defined audience applies.
    /// </remarks>
    private static readonly byte[] audienceRegionObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5D, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audience Share
    /// </summary>
    /// <remarks>
    /// The audience share expressed as a percentage
    /// </remarks>
    private static readonly byte[] AudienceShare = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x02, 0x20, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audience Type Group Set
    /// </summary>
    /// <remarks>
    /// To define the audience definition system used.
    /// </remarks>
    private static readonly byte[] audienceTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5D, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Average Bit Rate
    /// </summary>
    /// <remarks>
    /// The Average bit rate in bits per second
    /// </remarks>
    private static readonly byte[] AudioAverageBitRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x02, 0x03, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Bit Rate Mode
    /// </summary>
    /// <remarks>
    /// The audio bit rate mode: constant, variable, or none if unknown
    /// </remarks>
    private static readonly byte[] audioBitRateMode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Bit Rate Set
    /// </summary>
    /// <remarks>
    /// The average bit rate in bits per second
    /// </remarks>
    private static readonly byte[] audioBitRateObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Cartesian
    /// </summary>
    /// <remarks>
    /// A flag set to true if cartesian coordinates used, false (default) for spherical.
    /// </remarks>
    private static readonly byte[] audioBlockCartesian = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x51, 0x11, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Channel Lock
    /// </summary>
    /// <remarks>
    /// If set to 1 a renderer can lock the object to the nearest channel or speaker, rather than normal rendering
    /// </remarks>
    private static readonly byte[] audioBlockChannelLock = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x51, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Degree
    /// </summary>
    /// <remarks>
    /// Degree for the ambisonic component
    /// </remarks>
    private static readonly byte[] audioBlockDegree = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x51, 0x0F, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Depth
    /// </summary>
    /// <remarks>
    /// Depth of object along a distance line as a normalised distance
    /// </remarks>
    private static readonly byte[] audioBlockDepth = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x51, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Diffuse
    /// </summary>
    /// <remarks>
    /// Set to 1 if diffuse, 0 if direct
    /// </remarks>
    private static readonly byte[] audioBlockDiffuse = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x51, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Divergence
    /// </summary>
    /// <remarks>
    /// Sets the divergence of an object where 0.0 means all sound in the direction of the object and 1.0 means all sound from the virtual objects placed at an angle set by the azimuthRange attribute value.
    /// </remarks>
    private static readonly byte[] audioBlockDivergence = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x68, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Divergence Azimuth Range
    /// </summary>
    /// <remarks>
    /// Set the azimuth angle from the actual object's position to the two virtual positions each side of it.
    /// </remarks>
    private static readonly byte[] audioBlockDivergenceAzimuthRange = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x68, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Object Divergence Set
    /// </summary>
    /// <remarks>
    /// Sets the divergence of an object where 0.0 means all sound in the direction of the object and 1.0 means all sound from the virtual objects placed at an angle set by the azimuthRange attribute value.
    /// </remarks>
    private static readonly byte[] audioBlockDivergenceObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x51, 0x12, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Divergence Value
    /// </summary>
    /// <remarks>
    /// The value of divergence.
    /// </remarks>
    private static readonly byte[] audioBlockDivergenceValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x68, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Duration Timecode
    /// </summary>
    /// <remarks>
    /// The duration of an audio block in timecode
    /// </remarks>
    private static readonly byte[] audioBlockDurationTimecode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x51, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Equation
    /// </summary>
    /// <remarks>
    /// To provide an equation
    /// </remarks>
    private static readonly byte[] audioBlockEquation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x51, 0x0E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Format
    /// </summary>
    /// <remarks>
    /// A set of attributes to describe an audio block format
    /// </remarks>
    private static readonly byte[] audioBlockFormat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x51, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Format Id
    /// </summary>
    /// <remarks>
    /// An identifier associated with the audio block format
    /// </remarks>
    private static readonly byte[] audioBlockFormatId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x51, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Format Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to audio blocks
    /// </remarks>
    private static readonly byte[] audioBlockFormatObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x49, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Gain
    /// </summary>
    /// <remarks>
    /// Set a gain value for the audio samples in the audio block
    /// </remarks>
    private static readonly byte[] audioBlockGain = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x51, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Height
    /// </summary>
    /// <remarks>
    /// Height of object in degrees along elevation axis
    /// </remarks>
    private static readonly byte[] audioBlockHeight = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x51, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Importance
    /// </summary>
    /// <remarks>
    /// A value from 0 to 10 (most) to indicate the importance of the object.
    /// </remarks>
    private static readonly byte[] audioBlockImportance = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x51, 0x15, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Jump Position Flag
    /// </summary>
    /// <remarks>
    /// Jump position flag value.
    /// </remarks>
    private static readonly byte[] audioBlockJumPositionFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6B, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Jump Position Interpolation Length
    /// </summary>
    /// <remarks>
    /// The interpolation length in seconds.
    /// </remarks>
    private static readonly byte[] audioBlockJumPositionInterpolationLength = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6B, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Jump Position
    /// </summary>
    /// <remarks>
    /// If set to 1 the position will be interpolated over a period set by the attribute interpolationLength. If set to 0 then interpolation will take the entire length of the block. An interpolationLength value of zero will mean the object jumps without interpolation.
    /// </remarks>
    private static readonly byte[] audioBlockJumpPos = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6B, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Jump Position
    /// </summary>
    /// <remarks>
    /// If set to 1 the position will not be interpolated with the previous block
    /// </remarks>
    private static readonly byte[] audioBlockJumpPosition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x51, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Blcok Jump Position Set
    /// </summary>
    /// <remarks>
    /// If set to 1 the position will be interpolated over a period set by the attribute interpolationLength. If set to 0 then interpolation will take the entire length of the block. An interpolationLength value of zero will mean the object jumps without interpolation.
    /// </remarks>
    private static readonly byte[] audioBlockJumpPositionObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x51, 0x17, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Matrix
    /// </summary>
    /// <remarks>
    /// A set of attributes to describe an audio block matrix
    /// </remarks>
    private static readonly byte[] audioBlockMatrix = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x57, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Matrix Coefficient
    /// </summary>
    /// <remarks>
    /// A set of attributes to describe an audio block matrix coefficient
    /// </remarks>
    private static readonly byte[] audioBlockMatrixCoefficient = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x52, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Matrix Coefficient Channel Format IDRef Set
    /// </summary>
    /// <remarks>
    /// Sets a multiplication coefficient (value attrib) with the ID of another channel.
    /// </remarks>
    private static readonly byte[] audioBlockMatrixCoefficientChannelFormatIDRefObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x52, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Matrix Coefficient Gain
    /// </summary>
    /// <remarks>
    /// Coefficient value
    /// </remarks>
    private static readonly byte[] audioBlockMatrixCoefficientGain = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x52, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Matrix Coefficient Gain Var
    /// </summary>
    /// <remarks>
    /// A flag to indicate if the gain is variable
    /// </remarks>
    private static readonly byte[] audioBlockMatrixCoefficientGainVar = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x52, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Matrix Coefficient Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to audio block matrix coefficients
    /// </remarks>
    private static readonly byte[] audioBlockMatrixCoefficientObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x57, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Matrix Coefficient Phase
    /// </summary>
    /// <remarks>
    /// Phase shift value
    /// </remarks>
    private static readonly byte[] audioBlockMatrixCoefficientPhase = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x52, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Matrix Coefficient Phase Var
    /// </summary>
    /// <remarks>
    /// A flag to indicate if the phase is variable
    /// </remarks>
    private static readonly byte[] audioBlockMatrixCoefficientPhaseVar = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x52, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Matrix Coefficient Value
    /// </summary>
    /// <remarks>
    /// The value of an audio block matrix coefficient
    /// </remarks>
    private static readonly byte[] audioBlockMatrixCoefficientValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x52, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Matrix Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an audio block matrix
    /// </remarks>
    private static readonly byte[] audioBlockMatrixObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x51, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Order
    /// </summary>
    /// <remarks>
    /// Order for the ambisonic component
    /// </remarks>
    private static readonly byte[] audioBlockOrder = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x51, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Position
    /// </summary>
    /// <remarks>
    /// A set of user defined parameters to define a block location in space.
    /// </remarks>
    private static readonly byte[] audioBlockPos = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x67, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Position
    /// </summary>
    /// <remarks>
    /// A location in space
    /// </remarks>
    private static readonly byte[] audioBlockPosition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x51, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Position Bound
    /// </summary>
    /// <remarks>
    /// Set to "min" or "max" to set the bound of the position.
    /// </remarks>
    private static readonly byte[] audioBlockPositionBound = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x67, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Position Coordinate
    /// </summary>
    /// <remarks>
    /// The axis used, either azimuth, elevation or distance (for polar); or X, Y or Z (for Cartesian).
    /// </remarks>
    private static readonly byte[] audioBlockPositionCoordinate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x67, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Position Sets
    /// </summary>
    /// <remarks>
    /// A set of user defined parameters to define a location in space.
    /// </remarks>
    private static readonly byte[] audioBlockPositionObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x51, 0x16, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Position Edge Lock
    /// </summary>
    /// <remarks>
    /// Set to "left", "right", "top" or "bottom" to indicate which edge of the screen to lock the position to.
    /// </remarks>
    private static readonly byte[] audioBlockPositionScreenEdgeLock = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x67, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Position Value
    /// </summary>
    /// <remarks>
    /// The position as a single value.
    /// </remarks>
    private static readonly byte[] audioBlockPositionValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x67, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block RTimecode
    /// </summary>
    /// <remarks>
    /// Start time of the block expressed as a timecode
    /// </remarks>
    private static readonly byte[] audioBlockRTimecode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x51, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Screen reference Flag
    /// </summary>
    /// <remarks>
    /// A flag set to true if the object is related to the screen. false otherwise.
    /// </remarks>
    private static readonly byte[] audioBlockScreenReferenceFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x51, 0x14, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Speaker Label
    /// </summary>
    /// <remarks>
    /// A label associated with a speaker.
    /// </remarks>
    private static readonly byte[] audioBlockSpeakerLabel = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x51, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Width
    /// </summary>
    /// <remarks>
    /// Width of object in degrees along azimuth axis
    /// </remarks>
    private static readonly byte[] audioBlockWidth = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x51, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Zone
    /// </summary>
    /// <remarks>
    /// Specifies the corner points of a cuboid in the 3D space that will be excluded from rendering. Multiple zone elements can be used to specify more complex exclusion shapes.
    /// </remarks>
    private static readonly byte[] audioBlockZone = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6A, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Zone Exclusion
    /// </summary>
    /// <remarks>
    /// Allows 3D zones to be exluded from rendering. So any speakers that exist within the excluded zone will not be used.
    /// </remarks>
    private static readonly byte[] audioBlockZoneExclusion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x69, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Zone Exclusion Set
    /// </summary>
    /// <remarks>
    /// Allows 3D zones to be excluded from rendering. So any speakers that exist within the excluded zone will not be used.
    /// </remarks>
    private static readonly byte[] audioBlockZoneExclusionObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x51, 0x13, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Zone Max X
    /// </summary>
    /// <remarks>
    /// Max X
    /// </remarks>
    private static readonly byte[] audioBlockZoneMaxX = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6A, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Zone Max Y
    /// </summary>
    /// <remarks>
    /// Max Y
    /// </remarks>
    private static readonly byte[] audioBlockZoneMaxY = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6A, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Zone Max Z
    /// </summary>
    /// <remarks>
    /// Max Z
    /// </remarks>
    private static readonly byte[] audioBlockZoneMaxZ = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6A, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Zone Min X
    /// </summary>
    /// <remarks>
    /// Min X
    /// </remarks>
    private static readonly byte[] audioBlockZoneMinX = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6A, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Zone Min Y
    /// </summary>
    /// <remarks>
    /// Min Y
    /// </remarks>
    private static readonly byte[] audioBlockZoneMinY = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6A, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Zone Min Z
    /// </summary>
    /// <remarks>
    /// Min Z
    /// </remarks>
    private static readonly byte[] audioBlockZoneMinZ = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6A, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Zone Sets
    /// </summary>
    /// <remarks>
    /// Specifies the corner points of a cuboid in the 3D space that will be excluded from rendering. Multiple zone elements can be used to specify more complex exclusion shapes.
    /// </remarks>
    private static readonly byte[] audioBlockZoneObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x69, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Block Zone Value
    /// </summary>
    /// <remarks>
    /// The definition of a zone.
    /// </remarks>
    private static readonly byte[] audioBlockZoneValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6A, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Capture Process
    /// </summary>
    /// <remarks>
    /// Information about how audio content was captured
    /// </remarks>
    private static readonly byte[] AudioCaptureProcess = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Channel Audio Block Format IDRef Sets
    /// </summary>
    /// <remarks>
    /// A batch of references to related audio block formats
    /// </remarks>
    private static readonly byte[] audioChannelAudioBlockFormatObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x50, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Channel Format
    /// </summary>
    /// <remarks>
    /// A set of attributes to describe an audio channel
    /// </remarks>
    private static readonly byte[] audioChannelFormat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x50, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Channel Format Id
    /// </summary>
    /// <remarks>
    /// An identifier associated with the audio channel
    /// </remarks>
    private static readonly byte[] audioChannelFormatId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x50, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Channel Format Name
    /// </summary>
    /// <remarks>
    /// A name associated with the audio channel
    /// </remarks>
    private static readonly byte[] audioChannelFormatName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x50, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Channel Format Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to audio channels
    /// </remarks>
    private static readonly byte[] audioChannelFormatObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x49, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Channel Frequency
    /// </summary>
    /// <remarks>
    /// Sets a high or low cut-off frequency for the audio in Hz
    /// </remarks>
    private static readonly byte[] audioChannelFrequency = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x50, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Channel Identifiers
    /// </summary>
    /// <remarks>
    /// Identifiers relating to audio channels.
    /// </remarks>
    private static readonly byte[] AudioChannelIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x01, 0x03, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Channel Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a type group to define the type of audio channel
    /// </remarks>
    private static readonly byte[] audioChannelTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x50, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Codec Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a codec object
    /// </remarks>
    private static readonly byte[] audioCodecObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x0E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Coding Scheme Code
    /// </summary>
    /// <remarks>
    /// Specifies the audio coding or compression scheme used as a code
    /// </remarks>
    private static readonly byte[] AudioCodingSchemeCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x02, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Coding Scheme Name
    /// </summary>
    /// <remarks>
    /// Specifies the audio coding or compression scheme used as a name
    /// </remarks>
    private static readonly byte[] AudioCodingSchemeName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x02, 0x04, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Complementary Object IDREF Sets
    /// </summary>
    /// <remarks>
    /// A set of reference to complementary audio objects
    /// </remarks>
    private static readonly byte[] audioComplementaryObjectIDRefObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4E, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Compression
    /// </summary>
    /// <remarks>
    /// Information about audio compression.
    /// </remarks>
    private static readonly byte[] AudioCompression = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Compression Algorithm
    /// </summary>
    /// <remarks>
    /// Algorithms used, bitrates used, modes used.
    /// </remarks>
    private static readonly byte[] AudioCompressionAlgorithm_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Compression History
    /// </summary>
    /// <remarks>
    /// Audit history of compression for audio payload.
    /// </remarks>
    private static readonly byte[] AudioCompressionHistory = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Content
    /// </summary>
    /// <remarks>
    /// A set of attributes to describe audio content
    /// </remarks>
    private static readonly byte[] audioContent = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4D, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Content Audio Object IDRef Sets
    /// </summary>
    /// <remarks>
    /// A batch of references to related audio objects
    /// </remarks>
    private static readonly byte[] audioContentAudioObjectIDRefObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4D, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Content Dialogue
    /// </summary>
    /// <remarks>
    /// To characterise the presence of a dialogue in a media resource and its type.
    /// </remarks>
    private static readonly byte[] audioContentDialogue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x63, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Content Dialogue Indicator
    /// </summary>
    /// <remarks>
    /// A flag to indicate the presence of dialogue
    /// </remarks>
    private static readonly byte[] audioContentDialogueIndicator = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4D, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Content Dialogue Set
    /// </summary>
    /// <remarks>
    /// A set of values to categorise the presence of dialogue and its type.
    /// </remarks>
    private static readonly byte[] audioContentDialogueObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4D, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Content Dialogue Value
    /// </summary>
    /// <remarks>
    /// A element to define the dialogue.
    /// </remarks>
    private static readonly byte[] audioContentDialogueValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x63, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Content Id
    /// </summary>
    /// <remarks>
    /// An identifier associated with the audio content
    /// </remarks>
    private static readonly byte[] audioContentId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4D, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Content Language Code
    /// </summary>
    /// <remarks>
    /// A language associated to the audio content based on RFC 5646/BCP 47
    /// </remarks>
    private static readonly byte[] audioContentLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4D, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Content Loudness Metadata Set
    /// </summary>
    /// <remarks>
    /// A strong reference to the loudness at the audio content level
    /// </remarks>
    private static readonly byte[] audioContentLoudnessMetadataObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4D, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Content Name
    /// </summary>
    /// <remarks>
    /// A name associated with the audio content
    /// </remarks>
    private static readonly byte[] audioContentName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4D, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Content Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to audio contents
    /// </remarks>
    private static readonly byte[] audioContentObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x49, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Description Presence Flag
    /// </summary>
    /// <remarks>
    /// To signal the presence of audioDescription
    /// </remarks>
    private static readonly byte[] audioDescriptionPresenceFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x21, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Device Kind
    /// </summary>
    /// <remarks>
    /// Specific description for a device - eg The Compressor, limiter, etc
    /// </remarks>
    private static readonly byte[] AudioDeviceKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x20, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Device Parameter
    /// </summary>
    /// <remarks>
    /// Specific parameter for the specified device  eg.  Attack, gating
    /// </remarks>
    private static readonly byte[] AudioDeviceParameter_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x20, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Device Parameter Setting
    /// </summary>
    /// <remarks>
    /// The setting of the specific parameter for the specified device
    /// </remarks>
    private static readonly byte[] AudioDeviceParameterSetting_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x20, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Durations
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] AudioDurations = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x02, 0x01, 0x01, 0x05, 0x00, 0x00];
    /// <summary>
    /// Audio Encoding Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an encoding object
    /// </remarks>
    private static readonly byte[] audioEncodingObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Enhancement or Modification Description
    /// </summary>
    /// <remarks>
    /// Description of how audio content was modified.
    /// </remarks>
    private static readonly byte[] AudioEnhancementOrModificationDescription_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x20, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Essence Characteristics
    /// </summary>
    /// <remarks>
    /// Operating characteristics of the device creating the audio essence.
    /// </remarks>
    private static readonly byte[] AudioEssenceCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Essence Processing
    /// </summary>
    /// <remarks>
    /// Enhamcement or modification to the audio essence
    /// </remarks>
    private static readonly byte[] AudioEssenceProcessing = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x20, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Filter Sets
    /// </summary>
    /// <remarks>
    /// To describe a filter applied to audio
    /// </remarks>
    private static readonly byte[] audioFilterObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x22, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio First Mix-Down Process
    /// </summary>
    /// <remarks>
    /// The way in which the first mix down was done
    /// </remarks>
    private static readonly byte[] AudioFirstMixDownProcess_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x20, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Fixed Bit Rate Flag
    /// </summary>
    /// <remarks>
    /// Fixed = TRUE, variable = FALSE
    /// </remarks>
    private static readonly byte[] AudioFixedBitRateFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x02, 0x03, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Format
    /// </summary>
    /// <remarks>
    /// A set of attributes defining the audio format of the material
    /// </remarks>
    private static readonly byte[] audioFormat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Format Definition
    /// </summary>
    /// <remarks>
    /// A definition associated with the audio format
    /// </remarks>
    private static readonly byte[] audioFormatDefinition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Format Extended
    /// </summary>
    /// <remarks>
    /// A set of attributes to describe an extended audio format
    /// </remarks>
    private static readonly byte[] audioFormatExtended = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x49, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Format Extended Definition
    /// </summary>
    /// <remarks>
    /// A definition associated with the audio format extended
    /// </remarks>
    private static readonly byte[] audioFormatExtendedDefinition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x49, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Format Extended Id
    /// </summary>
    /// <remarks>
    /// An identifier associated with the audio format extended
    /// </remarks>
    private static readonly byte[] audioFormatExtendedId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x49, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Format Extended Name
    /// </summary>
    /// <remarks>
    /// A name associated with the audio format extended
    /// </remarks>
    private static readonly byte[] audioFormatExtendedName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x49, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Format Extended Presence Flag
    /// </summary>
    /// <remarks>
    /// A flag to indicate the presence of extended audio
    /// </remarks>
    private static readonly byte[] audioFormatExtendedPresenceFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x49, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Format Extended Version
    /// </summary>
    /// <remarks>
    /// A version associated with the audio format extended
    /// </remarks>
    private static readonly byte[] audioFormatExtendedVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x49, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Format ID
    /// </summary>
    /// <remarks>
    /// An identifier attributed to the audio format
    /// </remarks>
    private static readonly byte[] audioFormatID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Format Name
    /// </summary>
    /// <remarks>
    /// A name attributed to the audio format
    /// </remarks>
    private static readonly byte[] audioFormatName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Format Profile
    /// </summary>
    /// <remarks>
    /// To define a profile of an audio format
    /// </remarks>
    private static readonly byte[] audioFormatProfile = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x11, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Format Profile Level
    /// </summary>
    /// <remarks>
    /// To define a level of an audio format
    /// </remarks>
    private static readonly byte[] audioFormatProfileLevel = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x12, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Format Version ID
    /// </summary>
    /// <remarks>
    /// An identifier attributed to the version of the audio format
    /// </remarks>
    private static readonly byte[] audioFormatVersionId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Formulation
    /// </summary>
    /// <remarks>
    /// number of recording channels used, analogue or digital recording device, analog or digital mixing console
    /// </remarks>
    private static readonly byte[] AudioFormulation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Max Bit Rate Set
    /// </summary>
    /// <remarks>
    /// The maximum bit rate in bits per second
    /// </remarks>
    private static readonly byte[] audioMaxBitRateObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Metadata Elements
    /// </summary>
    /// <remarks>
    /// ST 2109 Audio Metadata Pack
    /// </remarks>
    private static readonly byte[] AudioMetadataElements = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x02, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Mix
    /// </summary>
    /// <remarks>
    /// The number of audio channels in the mix
    /// </remarks>
    private static readonly byte[] AudioMix = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x01, 0x01, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Mono Channel Count
    /// </summary>
    /// <remarks>
    /// The number of mono channels in the mix
    /// </remarks>
    private static readonly byte[] AudioMonoChannelCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x01, 0x01, 0x10, 0x01, 0x00, 0x00];
    /// <summary>
    /// Audio MXF Lookup
    /// </summary>
    /// <remarks>
    /// A set of attributes to describe an audio MXF lookup
    /// </remarks>
    private static readonly byte[] audioMXFLookup = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x56, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio MXF Lookup Channel IDRef Set
    /// </summary>
    /// <remarks>
    /// A reference to a channel
    /// </remarks>
    private static readonly byte[] audioMXFLookupChannelIDRefObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x56, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio MXF Lookup Package UIDRef Set
    /// </summary>
    /// <remarks>
    /// A reference to a package
    /// </remarks>
    private static readonly byte[] audioMXFLookupPackageUIDRefObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x56, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio MXF LookupTrack IDRef Set
    /// </summary>
    /// <remarks>
    /// A reference to a track
    /// </remarks>
    private static readonly byte[] audioMXFLookupTrackIDRefObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x56, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Noise Reduction
    /// </summary>
    /// <remarks>
    /// Information about any video noise reduction process
    /// </remarks>
    private static readonly byte[] AudioNoiseReduction = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Noise Reduction Algorithm
    /// </summary>
    /// <remarks>
    /// Algorithm used in a noise reduction process - eg Dolby SR, Telcom, other
    /// </remarks>
    private static readonly byte[] AudioNoiseReductionAlgorithm_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x03, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Note
    /// </summary>
    /// <remarks>
    /// A contextual information note
    /// </remarks>
    private static readonly byte[] audioNote = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x13, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Object
    /// </summary>
    /// <remarks>
    /// A set of attributes to describe an audio object
    /// </remarks>
    private static readonly byte[] audioObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4E, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Object Audio Object IDRef Sets
    /// </summary>
    /// <remarks>
    /// A batch of references to related audio objects
    /// </remarks>
    private static readonly byte[] audioObjectAudioObjectIDRefObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4E, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Object Audio Pack Format IDRef Sets
    /// </summary>
    /// <remarks>
    /// A batch of references to related audio pack formats
    /// </remarks>
    private static readonly byte[] audioObjectAudioPackFormatIDRefObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4E, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Object Audio Track UIDRef Sets
    /// </summary>
    /// <remarks>
    /// A batch of references to related audio track UIDs
    /// </remarks>
    private static readonly byte[] audioObjectAudioTrackUIDRefObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4E, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Object Dialogue Indicator
    /// </summary>
    /// <remarks>
    /// A flag to indicate the presence of dialogue
    /// </remarks>
    private static readonly byte[] audioObjectDialogueIndicator = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4E, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Object Disable Ducking
    /// </summary>
    /// <remarks>
    /// A flag to disable ducking.
    /// </remarks>
    private static readonly byte[] audioObjectDisableDucking = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4E, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Object Duration Timecode
    /// </summary>
    /// <remarks>
    /// A duration in timecode from the start point and during which the audio object exists
    /// </remarks>
    private static readonly byte[] audioObjectDurationTimecode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4E, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Object Id
    /// </summary>
    /// <remarks>
    /// An identifier associated with the audio object
    /// </remarks>
    private static readonly byte[] audioObjectId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4E, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Object Importance
    /// </summary>
    /// <remarks>
    /// A ranking indicator of importance allowing a renderer to discard an audio object below a certain threshold
    /// </remarks>
    private static readonly byte[] audioObjectImportance = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4E, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Object Interact
    /// </summary>
    /// <remarks>
    /// A flag to indicate if user interaction is allowed
    /// </remarks>
    private static readonly byte[] audioObjectInteract = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4E, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Object Interaction
    /// </summary>
    /// <remarks>
    /// Set of parameters for limiting the amount of interaction of an object.
    /// </remarks>
    private static readonly byte[] audioObjectInteraction = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x64, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Object Interaction Sets
    /// </summary>
    /// <remarks>
    /// Set of parameters for limiting the amount of interaction of an object.
    /// </remarks>
    private static readonly byte[] audioObjectInteractionObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4E, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Object Name
    /// </summary>
    /// <remarks>
    /// A name associated with the audio object
    /// </remarks>
    private static readonly byte[] audioObjectName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4E, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Object Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to audio objects
    /// </remarks>
    private static readonly byte[] audioObjectObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x49, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Object Start Timecode
    /// </summary>
    /// <remarks>
    /// A start timecode point when the audio object occurs
    /// </remarks>
    private static readonly byte[] audioObjectStartTimecode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4E, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Pack Absolute Distance
    /// </summary>
    /// <remarks>
    /// The absolute distance in meters
    /// </remarks>
    private static readonly byte[] audioPackAbsoluteDistance = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4F, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Pack Audio Channel Format IDRef Sets
    /// </summary>
    /// <remarks>
    /// A batch of references to related audio channel formats
    /// </remarks>
    private static readonly byte[] audioPackAudioChannelFormatIDRefObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4F, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Pack Audio Pack Format IDRef Sets
    /// </summary>
    /// <remarks>
    /// A batch of references to related audio pack formats
    /// </remarks>
    private static readonly byte[] audioPackAudioPackFormatIDRefObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4F, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Pack Format
    /// </summary>
    /// <remarks>
    /// A set of attributes to describe an audio pack
    /// </remarks>
    private static readonly byte[] audioPackFormat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4F, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Pack Format Id
    /// </summary>
    /// <remarks>
    /// An identifier associated with the audio pack
    /// </remarks>
    private static readonly byte[] audioPackFormatId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4F, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Pack Format Name
    /// </summary>
    /// <remarks>
    /// A name associated with the audio pack
    /// </remarks>
    private static readonly byte[] audioPackFormatName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4F, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Pack Format Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to audio packs
    /// </remarks>
    private static readonly byte[] audioPackFormatObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x49, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Pack Importance
    /// </summary>
    /// <remarks>
    /// A ranking indicator of importance allowing a renderer to discard an audio pack below a certain threshold
    /// </remarks>
    private static readonly byte[] audioPackImportance = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4F, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Pack Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a type group to define the type of audio pack
    /// </remarks>
    private static readonly byte[] audioPackTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4F, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Parameters
    /// </summary>
    /// <remarks>
    /// Information about audio parameters
    /// </remarks>
    private static readonly byte[] AudioParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Presence Flag
    /// </summary>
    /// <remarks>
    /// A flag to indicate the presence of audio
    /// </remarks>
    private static readonly byte[] audioPresenceFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Processor Settings
    /// </summary>
    /// <remarks>
    /// The settings of a specific device in the system
    /// </remarks>
    private static readonly byte[] AudioProcessorSettings = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x20, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Programme
    /// </summary>
    /// <remarks>
    /// A set of attributes to describe an audio programme
    /// </remarks>
    private static readonly byte[] audioProgramme = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4A, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Programme Audio Content IDRef Sets
    /// </summary>
    /// <remarks>
    /// A batch of references to related audio content
    /// </remarks>
    private static readonly byte[] audioProgrammeAudioContentIDRefObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4A, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Programme End Timecode
    /// </summary>
    /// <remarks>
    /// A end timecode point within the audio programme
    /// </remarks>
    private static readonly byte[] audioProgrammeEndTimecode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4A, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Programme Format Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a format group to define the format of audio programme
    /// </remarks>
    private static readonly byte[] audioProgrammeFormatGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4A, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Programme Id
    /// </summary>
    /// <remarks>
    /// An identifier associated with the audio programme
    /// </remarks>
    private static readonly byte[] audioProgrammeId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4A, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Programme Language Code
    /// </summary>
    /// <remarks>
    /// A language associated to the audio programme based on RFC 5646/BCP 47
    /// </remarks>
    private static readonly byte[] audioProgrammeLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4A, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Programme Loudness Metadata Set
    /// </summary>
    /// <remarks>
    /// A strong reference to the loudness at the audio programme level
    /// </remarks>
    private static readonly byte[] audioProgrammeLoudnessMetadataObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4A, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Programme Max Ducking Depth
    /// </summary>
    /// <remarks>
    /// The maximum level (in dB) any audio object in the programme can be reduced by when ducking is invoked.
    /// </remarks>
    private static readonly byte[] audioProgrammeMaxDuckingDepth = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4A, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Programme Name
    /// </summary>
    /// <remarks>
    /// A name associated with the audio programme
    /// </remarks>
    private static readonly byte[] audioProgrammeName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4A, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Programme Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to audio programmes
    /// </remarks>
    private static readonly byte[] audioProgrammeObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x49, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Programme Reference Screen Set
    /// </summary>
    /// <remarks>
    /// To define the coordinates of a reference screen.
    /// </remarks>
    private static readonly byte[] audioProgrammeReferenceScreenObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4A, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Programme Start Timecode
    /// </summary>
    /// <remarks>
    /// A start timecode point within the audio programme
    /// </remarks>
    private static readonly byte[] audioProgrammeStartTimecode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4A, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Programme Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a type group to define the type of audio programme
    /// </remarks>
    private static readonly byte[] audioProgrammeTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4A, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Reference Level
    /// </summary>
    /// <remarks>
    /// Number of Dbm for 0VU
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] AudioReferenceLevel_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Reference Level
    /// </summary>
    /// <remarks>
    /// A description of the audio reference level, e.g. dBm, dBfs, +9dBm, 0dBfs, +15dBu etc.
    /// Namespace: http://www.smpte-ra.org/reg/335/2012/13/11
    /// </remarks>
    private static readonly byte[] AudioReferenceLevel_11 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Sample Rate
    /// </summary>
    /// <remarks>
    /// The reference sampling clock frequency as a rational number
    /// </remarks>
    private static readonly byte[] AudioSampleRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x03, 0x01, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Audio Sample Rate
    /// </summary>
    /// <remarks>
    /// The tabulated reference clock frequency
    /// </remarks>
    private static readonly byte[] AudioSampleRate_UInt8 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Sampling Rate Set
    /// </summary>
    /// <remarks>
    /// A strong reference toa rational to express the rate at which audio is sampled (in samples per second)
    /// </remarks>
    private static readonly byte[] audioSamplingRateObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Sampling Size
    /// </summary>
    /// <remarks>
    /// The maximum number of significant bits for the value without compression.
    /// </remarks>
    private static readonly byte[] audioSamplingSize = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Sampling Type
    /// </summary>
    /// <remarks>
    /// The type of samples
    /// </remarks>
    private static readonly byte[] audioSamplingType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Stereo Channel Count
    /// </summary>
    /// <remarks>
    /// The number of stereo channels in the mix
    /// </remarks>
    private static readonly byte[] AudioStereoChannelCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x01, 0x01, 0x10, 0x02, 0x00, 0x00];
    /// <summary>
    /// Audio Stream Audio Channel Format IDRef Sets
    /// </summary>
    /// <remarks>
    /// A batch of references to related audio channel formats
    /// </remarks>
    private static readonly byte[] audioStreamAudioChannelFormatIDRefObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x53, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Stream Format IDRef Sets
    /// </summary>
    /// <remarks>
    /// A batch of references to related audio stream formats
    /// </remarks>
    private static readonly byte[] audioStreamAudioPackFormatIDRefObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x53, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Stream Audio Track Format IDRef Sets
    /// </summary>
    /// <remarks>
    /// A batch of references to related audio track formats
    /// </remarks>
    private static readonly byte[] audioStreamAudioTrackFormatIDRefObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x53, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Stream Format
    /// </summary>
    /// <remarks>
    /// A set of attributes to describe an audio stream format
    /// </remarks>
    private static readonly byte[] audioStreamFormat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x53, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Stream Format Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a format group to define the type of audio stream format
    /// </remarks>
    private static readonly byte[] audioStreamFormatFormatGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x53, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Stream Format Id
    /// </summary>
    /// <remarks>
    /// An identifier associated with the audio stream format
    /// </remarks>
    private static readonly byte[] audioStreamFormatId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x53, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Stream Format Name
    /// </summary>
    /// <remarks>
    /// A name associated with the audio stream format
    /// </remarks>
    private static readonly byte[] audioStreamFormatName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x53, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Stream Format Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to audio streams
    /// </remarks>
    private static readonly byte[] audioStreamFormatObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x49, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Technical Attribute AnyURI Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type AnyURI
    /// </remarks>
    private static readonly byte[] audioTechnicalAttributeAnyURIObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x1F, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Technical Attribute Boolean Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Boolean
    /// </remarks>
    private static readonly byte[] audioTechnicalAttributeBooleanObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x20, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Technical Attribute Float Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Float
    /// </remarks>
    private static readonly byte[] audioTechnicalAttributeFloatObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x1D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Technical Attribute Int16 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int16
    /// </remarks>
    private static readonly byte[] audioTechnicalAttributeInt16Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x16, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Technical Attribute Int32 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int32
    /// </remarks>
    private static readonly byte[] audioTechnicalAttributeInt32Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x17, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Technical Attribute Int64 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int64
    /// </remarks>
    private static readonly byte[] audioTechnicalAttributeInt64Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x18, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Technical Attribute Int8 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int8
    /// </remarks>
    private static readonly byte[] audioTechnicalAttributeInt8Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x15, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Technical Attribute Rational Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Rational
    /// </remarks>
    private static readonly byte[] audioTechnicalAttributeRationalObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x1E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Technical Attribute String Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type string
    /// </remarks>
    private static readonly byte[] audioTechnicalAttributeStringObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x14, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Technical Attribute UInt16 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt16
    /// </remarks>
    private static readonly byte[] audioTechnicalAttributeUInt16Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x1A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Technical Attribute UInt32 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt32
    /// </remarks>
    private static readonly byte[] audioTechnicalAttributeUInt32Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x1B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Technical Attribute UInt64 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt64
    /// </remarks>
    private static readonly byte[] audioTechnicalAttributeUInt64Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x1C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Technical Attribute UInt8 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt8
    /// </remarks>
    private static readonly byte[] audioTechnicalAttributeUInt8Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x19, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Test Parameters
    /// </summary>
    /// <remarks>
    /// Audio test parameters from the original recording
    /// </remarks>
    private static readonly byte[] AudioTestParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Total Number Of Channels
    /// </summary>
    /// <remarks>
    /// The total number of audio channels/tracks
    /// </remarks>
    private static readonly byte[] audioTotalNumberOfChannels = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Track Audio Pack Format IDRef Sets
    /// </summary>
    /// <remarks>
    /// A batch of references to related audio pack formats
    /// </remarks>
    private static readonly byte[] audioTrackAudioPackFormatIDRefObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x55, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Track Audio Stream Format IDRef Sets
    /// </summary>
    /// <remarks>
    /// A batch of references to related audio stream formats
    /// </remarks>
    private static readonly byte[] audioTrackAudioStreamFormatIDRefObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x54, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Track Audio Track Format IDRef Sets
    /// </summary>
    /// <remarks>
    /// A batch of references to related audio track formats
    /// </remarks>
    private static readonly byte[] audioTrackAudioTrackFormatIDRefObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x55, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Track  Configuration
    /// </summary>
    /// <remarks>
    /// A description of the audio track configuration (e.g. R48 &amp; R123 EBU)
    /// </remarks>
    private static readonly byte[] audioTrackConfiguration = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Track Format
    /// </summary>
    /// <remarks>
    /// A set of attributes to describe an audio track format
    /// </remarks>
    private static readonly byte[] audioTrackFormat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x54, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Track Format Format Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a format group to define the format of audio track format
    /// </remarks>
    private static readonly byte[] audioTrackFormatFormatGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x54, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Track Format Id
    /// </summary>
    /// <remarks>
    /// An identifier associated with the audio track format
    /// </remarks>
    private static readonly byte[] audioTrackFormatId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x54, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Track Format Name
    /// </summary>
    /// <remarks>
    /// A name associated with the audio track format
    /// </remarks>
    private static readonly byte[] audioTrackFormatName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x54, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Track Format Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to audio tracks
    /// </remarks>
    private static readonly byte[] audioTrackFormatObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x49, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Track MXF Lookup Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an MXF lookup element
    /// </remarks>
    private static readonly byte[] audioTrackMXFLookupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x55, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Track  Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to track objects
    /// </remarks>
    private static readonly byte[] audioTrackObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x33, 0x0F, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Track UID
    /// </summary>
    /// <remarks>
    /// A set of attributes to describe an audio track UID
    /// </remarks>
    private static readonly byte[] audioTrackUID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x55, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Track UID Bit Depth
    /// </summary>
    /// <remarks>
    /// The bit depth
    /// </remarks>
    private static readonly byte[] audioTrackUIDBitDepth = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x55, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Track UID Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to audio track UIDs
    /// </remarks>
    private static readonly byte[] audioTrackUIDObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x49, 0x0E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Track UID Sample Rate
    /// </summary>
    /// <remarks>
    /// The sample rate of the audio track
    /// </remarks>
    private static readonly byte[] audioTrackUIDSampleRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x55, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Track UID Value
    /// </summary>
    /// <remarks>
    /// The value of the track UID
    /// </remarks>
    private static readonly byte[] audioTrackUIDValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x55, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Watermark Kind
    /// </summary>
    /// <remarks>
    /// Indicates the kind of audio watermark used
    /// </remarks>
    private static readonly byte[] AudioWatermarkKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Authentication Flag
    /// </summary>
    /// <remarks>
    /// Plugin supports authentication mechanism
    /// </remarks>
    private static readonly byte[] Authentication = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// AuthId Text
    /// </summary>
    /// <remarks>
    /// AuthId text
    /// </remarks>
    private static readonly byte[] AuthIdText = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x09, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// AuthId Text Length
    /// </summary>
    /// <remarks>
    /// AuthId text length
    /// </remarks>
    private static readonly byte[] AuthIdTextLength = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x08, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Auto Exposure Mode
    /// </summary>
    /// <remarks>
    /// Auto Exposure setup Mode
    /// </remarks>
    private static readonly byte[] AutoExposureMode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x01, 0x03, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Auto Focus Sensing Area Setting
    /// </summary>
    /// <remarks>
    /// Auto Focus Sensing Area setting defined as a registered code
    /// </remarks>
    private static readonly byte[] AutoFocusSensingAreaSetting = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x01, 0x03, 0x01, 0x02, 0x00, 0x00];
    /// <summary>
    /// Automated Cataloging and Indexing
    /// </summary>
    /// <remarks>
    /// Automated cataloguing and indexing by archival analysis of the essence
    /// </remarks>
    private static readonly byte[] AutomatedCatalogingAndIndexing = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Catalog Data Status
    /// </summary>
    /// <remarks>
    /// The current status of the catalogue as a freeform text string
    /// </remarks>
    private static readonly byte[] AutomatedCatalogingCatalogDataStatus_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Automated Categorization
    /// </summary>
    /// <remarks>
    /// Automated analytical categorization of the content
    /// </remarks>
    private static readonly byte[] AutomatedCategorization = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Automated Content Classification
    /// </summary>
    /// <remarks>
    /// Automated content classification
    /// </remarks>
    private static readonly byte[] AutomatedContentClassification = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Automated Stratum
    /// </summary>
    /// <remarks>
    /// Automatically derived descriptive stratum of the archival content analysis of the content
    /// </remarks>
    private static readonly byte[] AutomatedStratum = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Auto White Balance Mode
    /// </summary>
    /// <remarks>
    /// Auto White Balance Mode defined as a registered code
    /// </remarks>
    private static readonly byte[] AutoWhiteBalanceMode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x01, 0x03, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Auxiliary Bits Mode
    /// </summary>
    /// <remarks>
    /// Specifies the use of AES-3 Auxiliary Bits
    /// </remarks>
    private static readonly byte[] AuxBitsMode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x05, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Aux Data Block Edit Unit Edit Rate
    /// </summary>
    /// <remarks>
    /// Edit rate of the timeline Edit Unit
    /// </remarks>
    private static readonly byte[] AuxDataBlockEditUnitEditRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Aux Data Block Edit Unit Index
    /// </summary>
    /// <remarks>
    /// Index of the timeline Edit Unit
    /// </remarks>
    private static readonly byte[] AuxDataBlockEditUnitIndex = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Aux Data Block Source Cryptographic Context
    /// </summary>
    /// <remarks>
    /// Cryptographic Context Set, if any, associated with the Elements of the Data Item contained in Source Data Item element
    /// </remarks>
    private static readonly byte[] AuxDataBlockSourceCryptographicContext = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x01, 0x09, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Aux Data Block Source Cryptographic Context Length
    /// </summary>
    /// <remarks>
    /// Length in bytes of the Cryptographic Context Set
    /// </remarks>
    private static readonly byte[] AuxDataBlockSourceCryptographicContextLength = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Aux Data Block Source Data Essence Coding UL
    /// </summary>
    /// <remarks>
    /// Data Essence Coding UL of the source Aux Data Track File
    /// </remarks>
    private static readonly byte[] AuxDataBlockSourceDataEssenceCodingUL = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x01, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Aux Data Block Source Data Item
    /// </summary>
    /// <remarks>
    /// Data Item of the source Aux Data Track File
    /// </remarks>
    private static readonly byte[] AuxDataBlockSourceDataItem = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Aux Data Block Source Data Item Length
    /// </summary>
    /// <remarks>
    /// Length in bytes of the Source Data Item element
    /// </remarks>
    private static readonly byte[] AuxDataBlockSourceDataItemLength = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x01, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Aux Data Edit Unit Range Start Index
    /// </summary>
    /// <remarks>
    /// Index of the first Edit Unit of the timeline interval covered by the transfer
    /// </remarks>
    private static readonly byte[] AuxDataEditUnitRangeStartIndex = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Aux Data Transfer Protocol
    /// </summary>
    /// <remarks>
    /// Elements defined as part of the Aux Data Transfer protocol
    /// </remarks>
    private static readonly byte[] AuxDataTransferProtocol = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Aux Edit Unit Range Count
    /// </summary>
    /// <remarks>
    /// Number of Edit Units of the timeline interval covered by the transfer
    /// </remarks>
    private static readonly byte[] AuxEditUnitRangeCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// AVC Average Bit Rate
    /// </summary>
    /// <remarks>
    /// Average bit rate of the AVC stream in bit/s
    /// </remarks>
    private static readonly byte[] AVCAverageBitRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x01, 0x14, 0x00, 0x00];
    /// <summary>
    /// AVC Closed GOP Indicator
    /// </summary>
    /// <remarks>
    /// TRUE if all GOPs are started with IDR Picture.
    /// </remarks>
    private static readonly byte[] AVCClosedGOPIndicator = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x01, 0x06, 0x00, 0x00];
    /// <summary>
    /// AVC Coded Content Kind
    /// </summary>
    /// <remarks>
    /// Enumerated value specifying Picture type and Coding type.
    /// </remarks>
    private static readonly byte[] AVCCodedContentKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x01, 0x04, 0x00, 0x00];
    /// <summary>
    /// AVC Constant B Picture Flag
    /// </summary>
    /// <remarks>
    /// TRUE if the number of B Pictures is always constant.
    /// </remarks>
    private static readonly byte[] AVCConstantBPictureFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x01, 0x03, 0x00, 0x00];
    /// <summary>
    /// AVC Decoding Delay
    /// </summary>
    /// <remarks>
    /// Specifies the delay required for decoded pictures in number of access units.
    /// </remarks>
    private static readonly byte[] AVCDecodingDelay = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x01, 0x0E, 0x00, 0x00];
    /// <summary>
    /// AVC Identical GOP Indicator
    /// </summary>
    /// <remarks>
    /// TRUE if every GOP in the sequence has the same number of pictures and the same types of pictures in  the same order.
    /// </remarks>
    private static readonly byte[] AVCIdenticalGOPIndicator = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x01, 0x07, 0x00, 0x00];
    /// <summary>
    /// AVC Level
    /// </summary>
    /// <remarks>
    /// Specifies the AVC level.
    /// </remarks>
    private static readonly byte[] AVCLevel = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x01, 0x0D, 0x00, 0x00];
    /// <summary>
    /// AVC Maximum Bit Rate
    /// </summary>
    /// <remarks>
    /// Maximum bit rate of the AVC stream in bit/s
    /// </remarks>
    private static readonly byte[] AVCMaximumBitRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x01, 0x0B, 0x00, 0x00];
    /// <summary>
    /// AVC Maximum B-Picture Count
    /// </summary>
    /// <remarks>
    /// Specifies the maximum number of B Pictures between P or I Pictures.
    /// </remarks>
    private static readonly byte[] AVCMaximumBPictureCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x01, 0x09, 0x00, 0x00];
    /// <summary>
    /// AVC Maximum GOP Size
    /// </summary>
    /// <remarks>
    /// Specifies the maximum occurring spacing between I Pictures. A value of 0 or the absence of this property indicates either there is no limit to the maximum GOP or the maximum GOP is unknown.
    /// </remarks>
    private static readonly byte[] AVCMaximumGOPSize = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x01, 0x08, 0x00, 0x00];
    /// <summary>
    /// AVC Maximum Ref Frames
    /// </summary>
    /// <remarks>
    /// Specifies the maximum number of reference frames.
    /// </remarks>
    private static readonly byte[] AVCMaximumRefFrames = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x01, 0x0F, 0x00, 0x00];
    /// <summary>
    /// AVC Parameters
    /// </summary>
    /// <remarks>
    /// Parameters about AVC Picture Coding
    /// </remarks>
    private static readonly byte[] AVCParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// AVC Picture Parameter Set Flag
    /// </summary>
    /// <remarks>
    /// Specifies the location and the constancy of picture parameter sets
    /// </remarks>
    private static readonly byte[] AVCPictureParameterSetFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x01, 0x11, 0x00, 0x00];
    /// <summary>
    /// AVC Profile
    /// </summary>
    /// <remarks>
    /// Specifies the AVC video profile.
    /// </remarks>
    private static readonly byte[] AVCProfile = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x01, 0x0A, 0x00, 0x00];
    /// <summary>
    /// AVC Profile Constraint
    /// </summary>
    /// <remarks>
    /// Specifies the AVC video profile constraint flags.
    /// </remarks>
    private static readonly byte[] AVCProfileConstraint = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x01, 0x0C, 0x00, 0x00];
    /// <summary>
    /// AVC Sequence Parameter Set Flag
    /// </summary>
    /// <remarks>
    /// Specifies the location and the constancy of sequence parameter sets
    /// </remarks>
    private static readonly byte[] AVCSequenceParameterSetFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x01, 0x10, 0x00, 0x00];
    /// <summary>
    /// Average Bytes Per Second
    /// </summary>
    /// <remarks>
    /// The average number of Bytes per second at which the waveform data should be transferred
    /// </remarks>
    private static readonly byte[] AverageBytesPerSecond = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x03, 0x03, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Average MaxRGB
    /// </summary>
    /// <remarks>
    /// Average of linearized maxRGB values
    /// </remarks>
    private static readonly byte[] AverageMaxRGB = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x3B, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Average PQ-encoded maxRGB
    /// </summary>
    /// <remarks>
    /// The average of the PQ-encoded maxRGB values of the reduced pixel set
    /// </remarks>
    private static readonly byte[] AveragePqencodedMaxrgb = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x0E, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Average PQ-encoded maxRGB Offset
    /// </summary>
    /// <remarks>
    /// Offset to be added to Average PQ-encoded maxRGB
    /// </remarks>
    private static readonly byte[] AveragePqencodedMaxrgbOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x11, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Avid Technology, Inc.
    /// </summary>
    /// <remarks>
    /// Metadata registered by Avid Technology, Inc. for private use
    /// </remarks>
    private static readonly byte[] AvidTechnologyInc = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x06, 0x0E, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Award
    /// </summary>
    /// <remarks>
    /// To describe an award.
    /// </remarks>
    private static readonly byte[] award = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6D, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Award Category
    /// </summary>
    /// <remarks>
    /// Name of the award classification
    /// </remarks>
    private static readonly byte[] AwardCategory = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x03, 0x02, 0x02, 0x01, 0x05, 0x01, 0x00, 0x00];
    /// <summary>
    /// Award Category
    /// </summary>
    /// <remarks>
    /// Name of the award classification
    /// </remarks>
    private static readonly byte[] AwardCategory_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x03, 0x02, 0x02, 0x01, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Award Category Sets
    /// </summary>
    /// <remarks>
    /// The category of the award.
    /// </remarks>
    private static readonly byte[] awardCategoryObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6D, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Award Ceremony Sets
    /// </summary>
    /// <remarks>
    /// The ceremony of the award.
    /// </remarks>
    private static readonly byte[] awardCeremonyObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6D, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Award Date Sets
    /// </summary>
    /// <remarks>
    /// A set of dates associated with the award.
    /// </remarks>
    private static readonly byte[] awardDateObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6D, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Award Description Sets
    /// </summary>
    /// <remarks>
    /// To provide a set of descriptions of the award.
    /// </remarks>
    private static readonly byte[] awardDescriptionObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6D, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Award ID
    /// </summary>
    /// <remarks>
    /// An identifier associated with an award.
    /// </remarks>
    private static readonly byte[] awardId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6D, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Award Name
    /// </summary>
    /// <remarks>
    /// Name of the award
    /// </remarks>
    private static readonly byte[] AwardName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x03, 0x02, 0x02, 0x01, 0x04, 0x01, 0x00, 0x00];
    /// <summary>
    /// Award Name
    /// </summary>
    /// <remarks>
    /// Name of the award
    /// </remarks>
    private static readonly byte[] AwardName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x03, 0x02, 0x02, 0x01, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Award Name Sets
    /// </summary>
    /// <remarks>
    /// To provide the names by which the award is known.
    /// </remarks>
    private static readonly byte[] awardNameObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6D, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Award Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Award sets
    /// </remarks>
    private static readonly byte[] AwardObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x0B, 0x00];
    /// <summary>
    /// Award Official Sets
    /// </summary>
    /// <remarks>
    /// The personalities involved in the award ceremony.
    /// </remarks>
    private static readonly byte[] awardOfficialObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6D, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Award Participant Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of generalized weak (global) references to Participant sets for Awards
    /// </remarks>
    private static readonly byte[] AwardParticipants = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x03, 0x40, 0x13, 0x01];
    /// <summary>
    /// Awards
    /// </summary>
    /// <remarks>
    /// Awards relating to editorial, technical etc aspects of the content and contributors to it
    /// </remarks>
    private static readonly byte[] Awards = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Background Music Flag
    /// </summary>
    /// <remarks>
    /// Indicates that the usage of the music was either soley for the benefit of the audience or audible (or apparently audible) to performers.  True = Backgound, False = audible to performers
    /// </remarks>
    private static readonly byte[] BackgroundMusicFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x05, 0x01, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Backwards Version
    /// </summary>
    /// <remarks>
    /// The lowest Application Version for which this metadata set is valid
    /// </remarks>
    private static readonly byte[] BackwardsVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Bank Details Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a Bank Details set
    /// </remarks>
    private static readonly byte[] BankDetailsSet = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x02, 0x40, 0x1C, 0x00];
    /// <summary>
    /// Barco
    /// </summary>
    /// <remarks>
    /// Metadata registered by Barco, Inc. for private use
    /// </remarks>
    private static readonly byte[] Barco = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x0E, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Base Class
    /// </summary>
    /// <remarks>
    /// Class identifier of the immediate superclass defined in an MXF specification that this object extends.
    /// </remarks>
    private static readonly byte[] BaseClass = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x06, 0x01, 0x01, 0x04, 0x01, 0x0B, 0x00, 0x00];
    /// <summary>
    /// Qlty Basic Data
    /// </summary>
    /// <remarks>
    /// Basic Capture Data from the BWF &lt;qlty&gt; chunk
    /// </remarks>
    private static readonly byte[] BasicData = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x05, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Basic Link
    /// </summary>
    /// <remarks>
    /// A set of attributes to provide a a  link in the form of a URI such as a URL
    /// </remarks>
    private static readonly byte[] basicLink = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2F, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Basic Link Uri
    /// </summary>
    /// <remarks>
    /// The URI value
    /// </remarks>
    private static readonly byte[] basicLinkUri = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2F, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Basic Relation
    /// </summary>
    /// <remarks>
    /// A set of predefined basic relations
    /// </remarks>
    private static readonly byte[] basicRelation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Basic Relation Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to one or more basic relations to other resources
    /// </remarks>
    private static readonly byte[] basicRelationObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x02, 0x13, 0x00, 0x00, 0x00];
    /// <summary>
    /// BBC
    /// </summary>
    /// <remarks>
    /// Metadata registered by the British Broadcasting Corporation for public use
    /// </remarks>
    private static readonly byte[] BBC = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x0D, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Begin Anchor
    /// </summary>
    /// <remarks>
    /// Specifies the HTML Anchor at which this clip starts
    /// </remarks>
    private static readonly byte[] BeginAnchor = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x30, 0x06, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Begin Anchor
    /// </summary>
    /// <remarks>
    /// Specifies the HTML Anchor at which this clip starts
    /// </remarks>
    private static readonly byte[] BeginAnchor_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x30, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Bext Coding History
    /// </summary>
    /// <remarks>
    /// The Coding History from the BWF &lt;bext&gt; chunk
    /// </remarks>
    private static readonly byte[] BextCodingHistory = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x05, 0x02, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Bezier Curve Anchors
    /// </summary>
    /// <remarks>
    /// Intermediate anchor parameters, ordered P1 to PN-1
    /// </remarks>
    private static readonly byte[] BezierCurveAnchors = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// BICI
    /// </summary>
    /// <remarks>
    /// ANSI/NISO Book Item and Component Identifier
    /// </remarks>
    private static readonly byte[] BICI = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x13, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Birth date
    /// </summary>
    /// <remarks>
    /// The birth date of a contact/person
    /// </remarks>
    private static readonly byte[] birthDate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x22, 0x11, 0x00, 0x00, 0x00];
    /// <summary>
    /// Birth Place
    /// </summary>
    /// <remarks>
    /// The birth place of a contact/person
    /// </remarks>
    private static readonly byte[] birthPlace = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x22, 0x13, 0x00, 0x00, 0x00];
    /// <summary>
    /// Bit Rate
    /// </summary>
    /// <remarks>
    /// Maximum bit rate of MPEG video elementary stream in bit/s as defined in ISO-13818-2 bit_rate property
    /// </remarks>
    private static readonly byte[] BitRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x01, 0x06, 0x02, 0x01, 0x0B, 0x00, 0x00];
    /// <summary>
    /// Bits per Pixel
    /// </summary>
    /// <remarks>
    /// The maximum number of significant bits for the value in each band of each pixel without compression.
    /// </remarks>
    private static readonly byte[] BitsPerPixel = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x01, 0x05, 0x03, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Bits per Pixel
    /// </summary>
    /// <remarks>
    /// The maximum number of significant bits for the value in each band of each pixel without compression.
    /// </remarks>
    private static readonly byte[] BitsPerPixel_UInt8 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x03, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Bits Per Sample
    /// </summary>
    /// <remarks>
    /// The maximum number of significant bits for the value without compression.
    /// </remarks>
    private static readonly byte[] BitsPerSample = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Black Reference Level
    /// </summary>
    /// <remarks>
    /// Specifies digital luminance associated with black
    /// </remarks>
    private static readonly byte[] BlackRefLevel = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x03, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Block Align
    /// </summary>
    /// <remarks>
    /// The block alignment in Bytes - playback processes multiples of this value at a time.
    /// </remarks>
    private static readonly byte[] BlockAlign = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x03, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Block Continuity Count
    /// </summary>
    /// <remarks>
    /// Modulo 65536 count
    /// </remarks>
    private static readonly byte[] BlockContinuityCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x08, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Block Start Offset
    /// </summary>
    /// <remarks>
    /// Position of AES-3 first Z-pre-amble in the essence stream
    /// </remarks>
    private static readonly byte[] BlockStartOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x03, 0x02, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Body Offset
    /// </summary>
    /// <remarks>
    /// Byte offset of the start of the Essence Container segment in the Partition, relative to the start of the Essence Container
    /// </remarks>
    private static readonly byte[] BodyOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x08, 0x01, 0x02, 0x01, 0x03, 0x00, 0x00];
    /// <summary>
    /// Bounding Rectangle
    /// </summary>
    /// <remarks>
    /// Geographic rectangle specified by four corner points, coordinate system and datum
    /// </remarks>
    private static readonly byte[] Bounding_Rectangle = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x07, 0x01, 0x02, 0x01, 0x03, 0x0F, 0x00, 0x00];
    /// <summary>
    /// Brand
    /// </summary>
    /// <remarks>
    /// The advertiser brand that is associated to this product
    /// </remarks>
    private static readonly byte[] brand = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x0D, 0x0D, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Branding Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Branding sets
    /// </remarks>
    private static readonly byte[] BrandingObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x08, 0x00];
    /// <summary>
    /// Brand Main Title
    /// </summary>
    /// <remarks>
    /// Main Brand title (e.g. Horizon)
    /// </remarks>
    private static readonly byte[] BrandMainTitle = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x05, 0x0D, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Brand Main Title
    /// </summary>
    /// <remarks>
    /// Main Brand title (e.g. Horizon)
    /// </remarks>
    private static readonly byte[] BrandMainTitle_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x05, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Brand Original Title
    /// </summary>
    /// <remarks>
    /// Any original Brand title
    /// </remarks>
    private static readonly byte[] BrandOriginalTitle = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x05, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Brand Original Title
    /// </summary>
    /// <remarks>
    /// Any original Brand title
    /// </remarks>
    private static readonly byte[] BrandOriginalTitle_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x05, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Broadcast
    /// </summary>
    /// <remarks>
    /// Broadcast Outlet information
    /// </remarks>
    private static readonly byte[] Broadcast = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Broadcast and Repeat Information
    /// </summary>
    /// <remarks>
    /// Business information concerning the production
    /// </remarks>
    private static readonly byte[] BroadcastAndRepeatInformation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Broadcast Channel
    /// </summary>
    /// <remarks>
    /// Broadcast channel
    /// </remarks>
    private static readonly byte[] BroadcastChannel_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x10, 0x01, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Broadcast Date
    /// </summary>
    /// <remarks>
    /// The broadcast date of the program
    /// </remarks>
    private static readonly byte[] BroadcastDate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Broadcaster
    /// </summary>
    /// <remarks>
    /// The broadcasting organization
    /// </remarks>
    private static readonly byte[] Broadcaster = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x10, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Broadcaster Rights to Copy
    /// </summary>
    /// <remarks>
    /// Indicates whether the broadcaster has the rights to copy the program
    /// </remarks>
    private static readonly byte[] BroadcasterRightsToCopy = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x09, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Broadcast Flags
    /// </summary>
    /// <remarks>
    /// Flags concerning aspects of business or administration
    /// </remarks>
    private static readonly byte[] BroadcastFlags = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Broadcast Medium Code
    /// </summary>
    /// <remarks>
    /// Code defining the broadcast medium, including transmission (e.g., satellite, cable, terrestrial)
    /// </remarks>
    private static readonly byte[] BroadcastMediumCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x10, 0x01, 0x01, 0x03, 0x02, 0x00, 0x00];
    /// <summary>
    /// Broadcast Medium Kind
    /// </summary>
    /// <remarks>
    /// Publishing medium, including transmission (e.g., satellite, cable, terrestrial, ...)
    /// </remarks>
    private static readonly byte[] BroadcastMediumKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x10, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Broadcast Organization Name
    /// </summary>
    /// <remarks>
    /// Name of the broadcasting organization as text.
    /// </remarks>
    private static readonly byte[] BroadcastOrganizationName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Broadcast Organization Name
    /// </summary>
    /// <remarks>
    /// Name of the broadcasting organization
    /// </remarks>
    private static readonly byte[] BroadcastOrganizationName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x10, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Broadcast Region
    /// </summary>
    /// <remarks>
    /// Editorial target region of broadcast
    /// </remarks>
    private static readonly byte[] BroadcastRegion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x10, 0x01, 0x01, 0x04, 0x01, 0x00, 0x00];
    /// <summary>
    /// Broadcast Region
    /// </summary>
    /// <remarks>
    /// Target region of broadcast
    /// </remarks>
    private static readonly byte[] BroadcastRegion_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x10, 0x01, 0x01, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Broadcast Schedule Information
    /// </summary>
    /// <remarks>
    /// Information about the schedule information
    /// </remarks>
    private static readonly byte[] BroadcastScheduleInformation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Broadcast Service Name
    /// </summary>
    /// <remarks>
    /// The Broadcast Service - eg News 24
    /// </remarks>
    private static readonly byte[] BroadcastServiceName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x10, 0x01, 0x01, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Broadcast Time
    /// </summary>
    /// <remarks>
    /// The broadcast time of the program
    /// </remarks>
    private static readonly byte[] BroadcastTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Buffer Delay
    /// </summary>
    /// <remarks>
    /// Buffer delay per definition in SDTI-CP (E&amp;M)
    /// </remarks>
    private static readonly byte[] BufferDelay = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x03, 0x01, 0x03, 0x01, 0x00, 0x00];
    /// <summary>
    /// Building Name
    /// </summary>
    /// <remarks>
    /// The building name of an address.
    /// </remarks>
    private static readonly byte[] BuildingName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x12, 0x01];
    /// <summary>
    /// Building Name
    /// </summary>
    /// <remarks>
    /// The building name of an address.
    /// </remarks>
    private static readonly byte[] BuildingName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x12, 0x00];
    /// <summary>
    /// BWF Processing Parameters
    /// </summary>
    /// <remarks>
    /// Parameters required for BWF processing
    /// </remarks>
    private static readonly byte[] BWFProcessingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x05, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Bypass
    /// </summary>
    /// <remarks>
    /// Specifies default input to play
    /// </remarks>
    private static readonly byte[] Bypass = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x30, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Bypass Override
    /// </summary>
    /// <remarks>
    /// Specifies default input channel number to play in a specific instance  e.g input 24
    /// </remarks>
    private static readonly byte[] BypassOverride = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x30, 0x05, 0x0C, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Byte Offset
    /// </summary>
    /// <remarks>
    /// Byte offset from start of file  (byte 0)to 1st byte of partition pack key
    /// </remarks>
    private static readonly byte[] ByteOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x09, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Byte Order
    /// </summary>
    /// <remarks>
    /// Specifies the byte order of the metadata 'MM'=Big endian, 'II'=Little endian
    /// </remarks>
    private static readonly byte[] ByteOrder = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x02, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Camera Attributes
    /// </summary>
    /// <remarks>
    /// Informative description of the camera in use (as a text string).
    /// </remarks>
    private static readonly byte[] CameraAttributes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x03, 0x02, 0x03, 0x02, 0x02, 0x10, 0x02, 0x00];
    /// <summary>
    /// Camera Characteristics
    /// </summary>
    /// <remarks>
    /// Information about camera devices
    /// </remarks>
    private static readonly byte[] CameraCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Camera Knee Point
    /// </summary>
    /// <remarks>
    /// Level of the knee point in the camera transfer characteristic expressed as a percentage defined in 0.1 % units
    /// </remarks>
    private static readonly byte[] CameraKneePoint = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x01, 0x03, 0x02, 0x04, 0x00, 0x00];
    /// <summary>
    /// Camera Knee Slope
    /// </summary>
    /// <remarks>
    /// Slope of the transfer characteristic starting at the knee point.
    /// </remarks>
    private static readonly byte[] CameraKneeSlope = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x01, 0x03, 0x02, 0x05, 0x00, 0x00];
    /// <summary>
    /// Camera Luminance Dynamic Range
    /// </summary>
    /// <remarks>
    /// Luminance Dynamic Range expressed as a percentage defined in 0.1 % units.
    /// </remarks>
    private static readonly byte[] CameraLuminanceDynamicRange = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x01, 0x03, 0x02, 0x06, 0x00, 0x00];
    /// <summary>
    /// Camera Master Black Level
    /// </summary>
    /// <remarks>
    /// Level of the master black level of the camera expressed as a percentage defined in 0.1 % units
    /// </remarks>
    private static readonly byte[] CameraMasterBlackLevel = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x01, 0x03, 0x02, 0x03, 0x00, 0x00];
    /// <summary>
    /// Camera Master Gain Adjustment
    /// </summary>
    /// <remarks>
    /// Master Gain Control setting in 0.01 decibel units
    /// </remarks>
    private static readonly byte[] CameraMasterGainAdjustment = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x01, 0x03, 0x01, 0x09, 0x00, 0x00];
    /// <summary>
    /// CameraOperation
    /// </summary>
    /// <remarks>
    /// Includes items for camera operators to operate the camera.
    /// </remarks>
    private static readonly byte[] CameraOperation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Camera Setting File URI
    /// </summary>
    /// <remarks>
    /// The Uniform Resource Identifier (URI) of the file containing the camera setup parameters.
    /// </remarks>
    private static readonly byte[] CameraSettingFileURI = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x02, 0x01, 0x08, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Canonical DOI Name
    /// </summary>
    /// <remarks>
    /// Identifier of type CanonicalDOINameType
    /// </remarks>
    private static readonly byte[] CanonicalDOIName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x01, 0x01, 0x11, 0x0C, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Canonical EIDR Identifier
    /// </summary>
    /// <remarks>
    /// Identifier of type CanonicalEIDRIdentifierType
    /// </remarks>
    private static readonly byte[] CanonicalEIDRIdentifier = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x01, 0x01, 0x11, 0x0D, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Canonical Full Ad-ID Identifier
    /// </summary>
    /// <remarks>
    /// Identifier of type CanonicalFullAdIDIdentifierType
    /// </remarks>
    private static readonly byte[] CanonicalFullAdIDIdentifier = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x01, 0x01, 0x11, 0x0B, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Canon, Inc.
    /// </summary>
    /// <remarks>
    /// Metadata registered by Canon, Inc for private use
    /// </remarks>
    private static readonly byte[] CanonInc = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Captioning
    /// </summary>
    /// <remarks>
    /// A set of attributes to describe captioning  in the Material
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] captioning_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x36, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Caption Titles
    /// </summary>
    /// <remarks>
    /// Information about caption titling
    /// Namespace: http://www.smpte-ra.org/reg/335/2012/13/11
    /// </remarks>
    private static readonly byte[] captioning_11 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Captioning Format Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute format group to define the format of captioning being used
    /// </remarks>
    private static readonly byte[] captioningFormatGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x36, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Captioning Format ID
    /// </summary>
    /// <remarks>
    /// An Identifier attributed to the captioning format
    /// </remarks>
    private static readonly byte[] captioningFormatID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x36, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Captioning Format Name
    /// </summary>
    /// <remarks>
    /// A name attributed to the captioning format
    /// </remarks>
    private static readonly byte[] captioningFormatName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x36, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Captioning Format Profile
    /// </summary>
    /// <remarks>
    /// To specify an encoding profile
    /// </remarks>
    private static readonly byte[] captioningFormatProfile = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x36, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Captioning Language Code
    /// </summary>
    /// <remarks>
    /// Codes assigned by RFC 5646 / BCP 47 for the identification of languages
    /// </remarks>
    private static readonly byte[] captioningLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x36, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Captioning  Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to captioning objects
    /// </remarks>
    private static readonly byte[] captioningObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Captioning Presence Flag
    /// </summary>
    /// <remarks>
    /// A flag to indicate the presence of captioning
    /// </remarks>
    private static readonly byte[] captioningPresenceFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x36, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Captioning Source Uri
    /// </summary>
    /// <remarks>
    /// A URI from where a captioning  file (e.g. xml) can be accessed
    /// </remarks>
    private static readonly byte[] captioningSourceUri = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x36, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Captioning Track ID
    /// </summary>
    /// <remarks>
    /// An Identifier attributed to the captioning track
    /// </remarks>
    private static readonly byte[] captioningTrackID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x36, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Captioning Track Name
    /// </summary>
    /// <remarks>
    /// A name attributed to the captioning track
    /// </remarks>
    private static readonly byte[] captioningTrackName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x36, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Captioning Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group to define the type of captioning being used
    /// </remarks>
    private static readonly byte[] captioningTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x36, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Caption Kind
    /// </summary>
    /// <remarks>
    /// Specifies the kind of caption - e.g. teletext subtitles, closed captions subtitles, embedded sports scores, name captions etc.
    /// </remarks>
    private static readonly byte[] CaptionKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x04, 0x03, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Caption Kind
    /// </summary>
    /// <remarks>
    /// Specifies the kind of caption - e.g. teletext subtitles, closed captions subtitles, embedded sports scores, name captions etc.
    /// </remarks>
    private static readonly byte[] CaptionKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x04, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Caption Description Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Caption Description sets
    /// </remarks>
    private static readonly byte[] CaptionsDescriptionObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x0C, 0x00];
    /// <summary>
    /// Captions Description Participant Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of generalized weak (global) references to Participant sets for Captions Description
    /// </remarks>
    private static readonly byte[] CaptionsDescriptionParticipantSets = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x06, 0x01, 0x01, 0x04, 0x03, 0x40, 0x13, 0x04];
    /// <summary>
    /// Captions Via Teletext
    /// </summary>
    /// <remarks>
    /// Indicates that the program has teletext captions for the deaf or hearing-impaired
    /// </remarks>
    private static readonly byte[] CaptionsViaTeletext = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Caption Titles
    /// </summary>
    /// <remarks>
    /// Indicates that the program has caption titles
    /// </remarks>
    private static readonly byte[] CaptionTitles = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Capture Aspect Ratio
    /// </summary>
    /// <remarks>
    /// Specifies the horizontal to vertical aspect ratio of the image captured at the sensor - hence after the (possibly anamorphic) lens.
    /// </remarks>
    private static readonly byte[] CaptureAspectRatio_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x01, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Capture Film Frame Rate
    /// </summary>
    /// <remarks>
    /// eg 24.00 fps
    /// </remarks>
    private static readonly byte[] CaptureFilmFrameRate_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x08, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Capture Frame Rate
    /// </summary>
    /// <remarks>
    /// The rate that video images are captured expressed in frames per second (for example, 50:1, 60000:1001).
    /// </remarks>
    private static readonly byte[] CaptureFrameRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x03, 0x01, 0x03, 0x01, 0x00, 0x00];
    /// <summary>
    /// Capture Gamma Equation
    /// </summary>
    /// <remarks>
    /// Specifies the non-linear relationship between linear scene light levels and amplitude-compressed video signal levels at signal origination.
    /// </remarks>
    private static readonly byte[] CaptureGammaEquation_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Capture Gamma Equation
    /// </summary>
    /// <remarks>
    /// Specifies the non-linear relationship between linear scene light levels and amplitude-compressed video signal levels at signal origination.
    /// </remarks>
    private static readonly byte[] CaptureGammaEquation_Rational = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x00];
    /// <summary>
    /// Catalog Data Status
    /// </summary>
    /// <remarks>
    /// The current status of the catalogue as a freeform text string
    /// </remarks>
    private static readonly byte[] CatalogDataStatus_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Cataloging and Indexing
    /// </summary>
    /// <remarks>
    /// Archival analysis of the essence metadata
    /// </remarks>
    private static readonly byte[] CatalogingAndIndexing = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Cataloging System Name
    /// </summary>
    /// <remarks>
    /// The particular Cataloguing,  Indexing or Thesaurus system used by the automated system
    /// </remarks>
    private static readonly byte[] CatalogingSystemName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Catalog Prefix Number
    /// </summary>
    /// <remarks>
    /// The alphanumeric prefix to the Main catalogue number
    /// </remarks>
    private static readonly byte[] CatalogPrefixNumber_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x10, 0x03, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Categorization
    /// </summary>
    /// <remarks>
    /// Analytical categorisation of the content
    /// </remarks>
    private static readonly byte[] Categorization = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Security Classification Caveats
    /// </summary>
    /// <remarks>
    /// Marking of security exceptions or restrictions on the security classification
    /// </remarks>
    private static readonly byte[] Caveats = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x08, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Center Of Ellipse
    /// </summary>
    /// <remarks>
    /// Center position of the ellipses
    /// </remarks>
    private static readonly byte[] CenterOfEllipse = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x30, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Central Telephone Number
    /// </summary>
    /// <remarks>
    /// Telephone number of organization switchboard
    /// </remarks>
    private static readonly byte[] CentralTelephoneNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x07, 0x01, 0x20, 0x01, 0x10, 0x03, 0x04, 0x00];
    /// <summary>
    /// Certificate Data
    /// </summary>
    /// <remarks>
    /// Certificate chain
    /// </remarks>
    private static readonly byte[] CertificateData = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Certificate Kind
    /// </summary>
    /// <remarks>
    /// Certificate  Kind
    /// </remarks>
    private static readonly byte[] CertificateKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Certificate Length
    /// </summary>
    /// <remarks>
    /// Certificate chain length
    /// </remarks>
    private static readonly byte[] CertificateLength = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Channel Assignment
    /// </summary>
    /// <remarks>
    /// UL enumerating the channel assignment in use (e.g., SMPTE 320M-A)
    /// </remarks>
    private static readonly byte[] ChannelAssignment = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x04, 0x02, 0x01, 0x01, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Channel Count
    /// </summary>
    /// <remarks>
    /// The number of channels represented in the waveform data.
    /// </remarks>
    private static readonly byte[] ChannelCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x01, 0x01, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Channel Handle
    /// </summary>
    /// <remarks>
    /// Unique number identifying a channel number in a stream
    /// </remarks>
    private static readonly byte[] ChannelHandle = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x03, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Channel ID
    /// </summary>
    /// <remarks>
    /// Specifies the channel within the referenced precursor
    /// </remarks>
    private static readonly byte[] ChannelID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x06, 0x01, 0x01, 0x03, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Channel Identifiers
    /// </summary>
    /// <remarks>
    /// Identifiers relating to channels.
    /// </remarks>
    private static readonly byte[] ChannelIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x01, 0x03, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Channel IDs
    /// </summary>
    /// <remarks>
    /// Specifies an ordered array of channels within the referenced precursor
    /// </remarks>
    private static readonly byte[] ChannelIDs = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x06, 0x01, 0x01, 0x03, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Channel Status Mode
    /// </summary>
    /// <remarks>
    /// AES3 Enumerated mode for the carriage of channel status data
    /// </remarks>
    private static readonly byte[] ChannelStatusMode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x05, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// MIME Char Set
    /// </summary>
    /// <remarks>
    /// Specifies the registered character set used by both the internal and external representation of the data as defined by IETF RFC 2048 and http://www.iana.org/assignmnets/character-sets
    /// </remarks>
    private static readonly byte[] CharSet = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x04, 0x09, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Available Representations
    /// </summary>
    /// <remarks>
    /// Specifies a vector of references to available representations of the same original essence
    /// </remarks>
    private static readonly byte[] Choices = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x06, 0x01, 0x00, 0x00];
    /// <summary>
    /// Chroma Compensation Weight
    /// </summary>
    /// <remarks>
    /// Amount of chroma adjustment
    /// </remarks>
    private static readonly byte[] ChromaCompensationWeight = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x16, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Chromaticity Area Selector
    /// </summary>
    /// <remarks>
    /// True indicates the area of the Chromaticity Disk
    /// </remarks>
    private static readonly byte[] ChromaticityAreaSelector = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x1E, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Chromaticity Disk Center
    /// </summary>
    /// <remarks>
    /// Center of the Chromaticity Disk
    /// </remarks>
    private static readonly byte[] ChromaticityDiskCenter = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x1C, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Chromaticity Disk Radius
    /// </summary>
    /// <remarks>
    /// Radius of the Chromaticity Disk
    /// </remarks>
    private static readonly byte[] ChromaticityDiskRadius = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x1D, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// RIFF Chunk Data
    /// </summary>
    /// <remarks>
    /// The data bytes of a RIFF chunk
    /// </remarks>
    private static readonly byte[] ChunkData = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x04, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// RIFF Chunk ID
    /// </summary>
    /// <remarks>
    /// The code that identifies the data contained in a RIFF chunk
    /// </remarks>
    private static readonly byte[] ChunkID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x04, 0x06, 0x08, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// RIFF Chunk Length
    /// </summary>
    /// <remarks>
    /// Count of bytes in a RIFF chunk
    /// </remarks>
    private static readonly byte[] ChunkLength = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x04, 0x06, 0x09, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Cipher Algorithm
    /// </summary>
    /// <remarks>
    /// The cipher algorithm used for Digital Cinema encryption
    /// </remarks>
    private static readonly byte[] CipherAlgorithm = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x02, 0x09, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// CISAC Legal Entity ID
    /// </summary>
    /// <remarks>
    /// Natural person or legal entity ID in the International Confederation of Societies of Authors and Composers(CISAC) Interested Parties system
    /// </remarks>
    private static readonly byte[] CISACLegalEntityID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x10, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Citizenship
    /// </summary>
    /// <remarks>
    /// Citizenship of an individual with its attendant duties, rights, and privileges
    /// </remarks>
    private static readonly byte[] Citizenship = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x02, 0x30, 0x06, 0x03, 0x01, 0x0E, 0x01, 0x00];
    /// <summary>
    /// Citizenship
    /// </summary>
    /// <remarks>
    /// Citizenship of an individual with its attendant duties, rights, and privileges
    /// </remarks>
    private static readonly byte[] Citizenship_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x02, 0x30, 0x06, 0x03, 0x01, 0x0E, 0x00, 0x00];
    /// <summary>
    /// City Name
    /// </summary>
    /// <remarks>
    /// The city of the address.
    /// </remarks>
    private static readonly byte[] City = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x05, 0x01];
    /// <summary>
    /// City Name
    /// </summary>
    /// <remarks>
    /// The city of the address.
    /// </remarks>
    private static readonly byte[] CityName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x05, 0x00];
    /// <summary>
    /// Class Definitions
    /// </summary>
    /// <remarks>
    /// Specifies a set of unordered references to the Class Definition objects that define the objects that are used in the container
    /// </remarks>
    private static readonly byte[] ClassDefinitions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x07, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Classification
    /// </summary>
    /// <remarks>
    /// Details of permitted access to the technical system or platform
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] Classification_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x08, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Classification
    /// </summary>
    /// <remarks>
    /// Program classification information
    /// Namespace: http://www.smpte-ra.org/reg/335/2012/13/11
    /// </remarks>
    private static readonly byte[] Classification_11 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Classification and Marking System
    /// </summary>
    /// <remarks>
    /// Classification and marking system used
    /// </remarks>
    private static readonly byte[] ClassificationAndMarkingSystem_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x08, 0x02, 0x08, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Classification Comment
    /// </summary>
    /// <remarks>
    /// Narrative text further explaining the classification assignment
    /// </remarks>
    private static readonly byte[] ClassificationComment = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x02, 0x08, 0x02, 0x07, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Classification Comment
    /// </summary>
    /// <remarks>
    /// Narrative text further explaining the classification assignment
    /// </remarks>
    private static readonly byte[] ClassificationComment_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x08, 0x02, 0x07, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Classification Name-Value Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Name-Value sets (for categorising)
    /// </remarks>
    private static readonly byte[] ClassificationNameValueObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x1F, 0x01];
    /// <summary>
    /// Classification Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Classification sets
    /// </remarks>
    private static readonly byte[] ClassificationObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x10, 0x00];
    /// <summary>
    /// Classification Reason
    /// </summary>
    /// <remarks>
    /// Narrative text explaining the reason for assigning the classification
    /// </remarks>
    private static readonly byte[] ClassificationReason_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x08, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Classified By
    /// </summary>
    /// <remarks>
    /// Original classification authority name and position or personal identifier; the title of the document or security classification guide used to classify the information
    /// </remarks>
    private static readonly byte[] ClassifiedBy_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x08, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Classifying Country Code
    /// </summary>
    /// <remarks>
    /// ISO 3166 code of non-US country setting the security classification
    /// </remarks>
    private static readonly byte[] ClassifyingCountryCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x07, 0x01, 0x20, 0x01, 0x02, 0x08, 0x01, 0x00];
    /// <summary>
    /// Clip Creation Date-Time
    /// </summary>
    /// <remarks>
    /// Identifies date and time of creation of a clip
    /// </remarks>
    private static readonly byte[] ClipCreationDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x07, 0x02, 0x01, 0x10, 0x01, 0x04, 0x00, 0x00];
    /// <summary>
    /// Clip ID
    /// </summary>
    /// <remarks>
    /// Clip ID as a basic UMID. Note that the value includes the whole UMID including the first 12 UL bytes
    /// </remarks>
    private static readonly byte[] ClipID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x01, 0x15, 0x08, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Clip ID Array
    /// </summary>
    /// <remarks>
    /// An ordered  array of Basic UMIDs
    /// </remarks>
    private static readonly byte[] ClipIDArray = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x01, 0x01, 0x15, 0x0A, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Clip Kind
    /// </summary>
    /// <remarks>
    /// The kind of clip as an enumerated string (e.g., still, graphic, moving pictures, sound etc.)
    /// </remarks>
    private static readonly byte[] ClipKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x02, 0x05, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Clip Number
    /// </summary>
    /// <remarks>
    /// The alphanumeric number of the Clip
    /// </remarks>
    private static readonly byte[] ClipNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Clip Number
    /// </summary>
    /// <remarks>
    /// The alphanumeric number of the Clip
    /// </remarks>
    private static readonly byte[] ClipNumber_UTF16String = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x0C, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Clip Shot Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Shot  sets
    /// </remarks>
    private static readonly byte[] ClipShotObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x11, 0x02];
    /// <summary>
    /// Clone Count
    /// </summary>
    /// <remarks>
    /// The number of clones (i.e. digitally lossless copies)
    /// </remarks>
    private static readonly byte[] CloneCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Closed Captioning Flag
    /// </summary>
    /// <remarks>
    /// A flag signalling the presence of captioning
    /// </remarks>
    private static readonly byte[] closedCaptioningFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x36, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Closed Caption Subtitles Flag
    /// </summary>
    /// <remarks>
    /// Flag indicating that closed caption subtitles exist.
    /// </remarks>
    private static readonly byte[] ClosedCaptionSubtitlesFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Closed GOP Indicator
    /// </summary>
    /// <remarks>
    /// TRUE if closed_gop is set in all GOP Headers, per 13818-1 IBP descriptor
    /// </remarks>
    private static readonly byte[] ClosedGOP = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x01, 0x06, 0x02, 0x01, 0x06, 0x00, 0x00];
    /// <summary>
    /// Closed Subtitling Flag
    /// </summary>
    /// <remarks>
    /// A flag signalling the presence of closed subtitling
    /// </remarks>
    private static readonly byte[] closedSubtitlingFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x37, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// CNN
    /// </summary>
    /// <remarks>
    /// Metadata registered by CNN for private use
    /// </remarks>
    private static readonly byte[] CNN = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x06, 0x0E, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Codec Definition
    /// </summary>
    /// <remarks>
    /// Specifies a reference to the codec used to create Essence Data. Listed in SMPTE RP224
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] Codec_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x01, 0x03, 0x00, 0x00];
    /// <summary>
    /// Codec
    /// </summary>
    /// <remarks>
    /// A set of attributes used to described a codec (hardware/software)
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] Codec_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3E, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Codec Essence Kinds
    /// </summary>
    /// <remarks>
    /// Specifies references to the basic essence kinds supported by the codec
    /// </remarks>
    private static readonly byte[] CodecDataDefinitions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x03, 0x01, 0x00, 0x00];
    /// <summary>
    /// Codec Definition
    /// </summary>
    /// <remarks>
    /// UL to identify a codec compatible with this Essence Container. Listed in SMPTE RP224
    /// </remarks>
    private static readonly byte[] CodecDefinition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x01, 0x03, 0x01, 0x00];
    /// <summary>
    /// Codec Definitions
    /// </summary>
    /// <remarks>
    /// Specifies a unordered set of references to Codec Definitions
    /// </remarks>
    private static readonly byte[] CodecDefinitions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x05, 0x07, 0x00, 0x00];
    /// <summary>
    /// Codec Delay
    /// </summary>
    /// <remarks>
    /// Information about combined delay in encoding &amp; decoding processes
    /// </remarks>
    private static readonly byte[] CodecDelay = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Codec Family
    /// </summary>
    /// <remarks>
    /// The family of products to which the codec belongs
    /// </remarks>
    private static readonly byte[] codecfamily = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3E, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Codec Identifier
    /// </summary>
    /// <remarks>
    /// An identifier attributed to a codec
    /// </remarks>
    private static readonly byte[] codecIdentifier = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3E, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Codec Name
    /// </summary>
    /// <remarks>
    /// The name of the codec (hardware/software)
    /// </remarks>
    private static readonly byte[] codecName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3E, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Codec Type Group Set
    /// </summary>
    /// <remarks>
    /// To specify a kind of codec.
    /// </remarks>
    private static readonly byte[] codecTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3E, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Codec URL
    /// </summary>
    /// <remarks>
    /// A URL where more information can be found about the codec.
    /// </remarks>
    private static readonly byte[] codecUrl = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3E, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Codec Vendor
    /// </summary>
    /// <remarks>
    /// The name of the vendor
    /// </remarks>
    private static readonly byte[] codecVendor = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3E, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Codec Version
    /// </summary>
    /// <remarks>
    /// The version of the codec
    /// </remarks>
    private static readonly byte[] codecVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3E, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Coded Content Scanning Kind
    /// </summary>
    /// <remarks>
    /// The type of scanning used in MPEG video coded content as a code (e.g., 0=Unknown, 1=Progressive, 2=Interlaced, 3=Mixed)
    /// </remarks>
    private static readonly byte[] CodedContentScanning = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x01, 0x06, 0x02, 0x01, 0x04, 0x00, 0x00];
    /// <summary>
    /// Code Processor Settings
    /// </summary>
    /// <remarks>
    /// The settings of a effect or other plugin code object in the system
    /// </remarks>
    private static readonly byte[] CodeProcessorSettings = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Coding Equations
    /// </summary>
    /// <remarks>
    /// The fundamental color coding that relates the scene CIE tri-stimulus values (X, Y, Z) to the linear video levels (R, G, B).
    /// </remarks>
    private static readonly byte[] CodingEquations = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x01, 0x02, 0x01, 0x01, 0x03, 0x01, 0x00];
    /// <summary>
    /// Bext Coding History
    /// </summary>
    /// <remarks>
    /// The Coding History from the BWF &lt;bext&gt; chunk
    /// </remarks>
    private static readonly byte[] CodingHistory = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x05, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Coding Law Kind
    /// </summary>
    /// <remarks>
    /// Type of coding ( u-Law, A-law, block companding, G 711, G 722, MPEG type,  layer no, Dolby AC). Expessed as a code
    /// </remarks>
    private static readonly byte[] CodingLawKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x02, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Coding Law Name
    /// </summary>
    /// <remarks>
    /// Type of coding (e.g., u-Law, A-law, block companding, G 711, G 722, MPEG type,  layer no, Dolby AC). Expessed as a name.
    /// </remarks>
    private static readonly byte[] CodingLawName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x02, 0x04, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Coding Style Default
    /// </summary>
    /// <remarks>
    /// Default coding style for all components. Use this value only if static for all pictures in the Essence Container.The data format is as defined in ISO/IEC 15444-1, Annex A.6.1 and comprises the sequence of Scod (1 byte per table A-12), SGcod (4 bytes per table A.12) and Spcod (5 bytes plus 0 or more precinct size bytes per table A.12)
    /// </remarks>
    private static readonly byte[] CodingStyleDefault = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x06, 0x03, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Collection Name
    /// </summary>
    /// <remarks>
    /// Name of a published collection - e.g. 'Sinatra Live at the Sands'
    /// </remarks>
    private static readonly byte[] CollectionName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x10, 0x03, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Collection Name
    /// </summary>
    /// <remarks>
    /// Name of a published collection - e.g. 'Sinatra Live at the Sands'
    /// </remarks>
    private static readonly byte[] CollectionName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x10, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Color Correction Filter Wheel Setting
    /// </summary>
    /// <remarks>
    /// Color Compensation Filter Wheel setting defined as a registered code
    /// </remarks>
    private static readonly byte[] ColorCorrectionFilterWheelSetting = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x01, 0x03, 0x01, 0x03, 0x00, 0x00];
    /// <summary>
    /// Color Descriptor
    /// </summary>
    /// <remarks>
    /// eg. Black and white, tinted etc
    /// </remarks>
    private static readonly byte[] ColorDescriptor = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x01, 0x06, 0x04, 0x01, 0x00, 0x00];
    /// <summary>
    /// Color Descriptor
    /// </summary>
    /// <remarks>
    /// eg. Black and white, tinted etc
    /// </remarks>
    private static readonly byte[] ColorDescriptor_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x01, 0x06, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Color Field Code
    /// </summary>
    /// <remarks>
    /// Identifies the color field of the source video field for video derived from composite sources.
    /// </remarks>
    private static readonly byte[] ColorFieldCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Color for CDL
    /// </summary>
    /// <remarks>
    /// Enumerated code that represents the color primaries applied at the input to the ASC CDL.
    /// </remarks>
    private static readonly byte[] ColorForCDL = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x01, 0x03, 0x02, 0x0A, 0x00, 0x00];
    /// <summary>
    /// Colorimetry Code
    /// </summary>
    /// <remarks>
    /// The fundamental color coding that relates the scene CIE tri-stimulus values (X, Y, Z) to the linear video levels (R, G, B).
    /// </remarks>
    private static readonly byte[] ColorimetryCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x02, 0x01, 0x01, 0x03, 0x00, 0x00];
    /// <summary>
    /// Color Matrix
    /// </summary>
    /// <remarks>
    /// Specifies the setting of the color balance of the camera with the ordered elements (R to R, G to R, B to R, R to G, G to G, B to G, R to B, G to B, B to B).
    /// </remarks>
    private static readonly byte[] ColorMatrix = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x01, 0x03, 0x01, 0x0D, 0x00, 0x00];
    /// <summary>
    /// Color Primaries
    /// </summary>
    /// <remarks>
    /// The set of color primaries used
    /// </remarks>
    private static readonly byte[] ColorPrimaries = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x04, 0x01, 0x02, 0x01, 0x01, 0x06, 0x01, 0x00];
    /// <summary>
    /// Color Primaries
    /// </summary>
    /// <remarks>
    /// The set of color primaries used
    /// </remarks>
    private static readonly byte[] ColorPrimaries_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x04, 0x01, 0x02, 0x01, 0x01, 0x06, 0x00, 0x00];
    /// <summary>
    /// Color Range Levels
    /// </summary>
    /// <remarks>
    /// Specifies the range of the color levels.
    /// </remarks>
    private static readonly byte[] ColorRange = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x01, 0x05, 0x03, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Color Remapping Matrix
    /// </summary>
    /// <remarks>
    /// A 3x3 matrix between tone mapping stages
    /// </remarks>
    private static readonly byte[] ColorRemappingMatrix = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x2C, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Color Saturation Weight
    /// </summary>
    /// <remarks>
    /// Adjusts the color saturation gain
    /// </remarks>
    private static readonly byte[] ColorSaturationWeight = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x41, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Color Siting
    /// </summary>
    /// <remarks>
    /// Specifies how to compute subsampled chrominance values
    /// </remarks>
    private static readonly byte[] ColorSiting = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x01, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Color Transform Information
    /// </summary>
    /// <remarks>
    /// Color Transform Information
    /// </remarks>
    private static readonly byte[] ColorTransformInformation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Communication Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Communications sets
    /// </remarks>
    private static readonly byte[] CommunicationsObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x18, 0x00];
    /// <summary>
    /// Compact Ad-ID Identifier
    /// </summary>
    /// <remarks>
    /// Identifier of type CompactAdIDIdentifierType
    /// </remarks>
    private static readonly byte[] CompactAdIDIdentifier = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x01, 0x01, 0x11, 0x0E, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Component Attributes
    /// </summary>
    /// <remarks>
    /// Specifies a set of references to Tagged Values associated with a component within a package
    /// </remarks>
    private static readonly byte[] ComponentAttributes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x02, 0x10, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Component Data Definition
    /// </summary>
    /// <remarks>
    /// Specifies the basic essence type of a component
    /// </remarks>
    private static readonly byte[] ComponentDataDefinition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Component Depth
    /// </summary>
    /// <remarks>
    /// Specifies the number of active bits per sample (e.g. 8, 10, 16 etc)
    /// </remarks>
    private static readonly byte[] ComponentDepth = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x01, 0x05, 0x03, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Component KLV Data
    /// </summary>
    /// <remarks>
    /// Specifies a set of references to KLV data associated with a component within a package
    /// </remarks>
    private static readonly byte[] ComponentKLVData = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x02, 0x10, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Component Length
    /// </summary>
    /// <remarks>
    /// The absolute duration of a compositional component - eg clip, effect, sequence etc in units of edit rate
    /// </remarks>
    private static readonly byte[] ComponentLength = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x07, 0x02, 0x02, 0x01, 0x01, 0x03, 0x00, 0x00];
    /// <summary>
    /// Component Maximum Ref
    /// </summary>
    /// <remarks>
    /// Maximum value for RGB components e.g. 235 or 940 (8 or 10 bits)
    /// </remarks>
    private static readonly byte[] ComponentMaxRef = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x01, 0x05, 0x03, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Component Minimum Ref
    /// </summary>
    /// <remarks>
    /// Minumum value for RGB components e.g. 16 or 64 (8 or 10-bits)
    /// </remarks>
    private static readonly byte[] ComponentMinRef = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x01, 0x05, 0x03, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Components
    /// </summary>
    /// <remarks>
    /// Specifies a vector of references to the clips and transitions in the sequence
    /// </remarks>
    private static readonly byte[] ComponentObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x06, 0x09, 0x00, 0x00];
    /// <summary>
    /// Component User Comments
    /// </summary>
    /// <remarks>
    /// Specifies a vector of references to comments on a Component
    /// </remarks>
    private static readonly byte[] ComponentUserComments = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x02, 0x01, 0x02, 0x16, 0x00, 0x00, 0x00];
    /// <summary>
    /// Composition Rendering
    /// </summary>
    /// <remarks>
    /// Specifies a reference to a rendering of a composition
    /// </remarks>
    private static readonly byte[] CompositionRendering = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x06, 0x01, 0x01, 0x04, 0x01, 0x0A, 0x00, 0x00];
    /// <summary>
    /// Compound Name
    /// </summary>
    /// <remarks>
    /// A set of attributes to define a simple or compound name which purpose is defined by the type group and the format is defined by the format group
    /// </remarks>
    private static readonly byte[] compoundName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x28, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Compound Name Format Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a format group to define the format of composition of the compound name
    /// </remarks>
    private static readonly byte[] compoundNameFormatGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x28, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Compound Name Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a type group to define the purpose of use of the compound name
    /// </remarks>
    private static readonly byte[] compoundNameTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x28, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Compound Name Value
    /// </summary>
    /// <remarks>
    /// The value of the compound name
    /// </remarks>
    private static readonly byte[] compoundNameValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x28, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Compression Processing
    /// </summary>
    /// <remarks>
    /// Information about payload compression.
    /// </remarks>
    private static readonly byte[] CompressionProcessing = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Computed Key Data
    /// </summary>
    /// <remarks>
    /// Automatically derived freeform textual reference to a key piece of data or program in the data set
    /// </remarks>
    private static readonly byte[] ComputedKeyData_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x02, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Computed Key Frames
    /// </summary>
    /// <remarks>
    /// Automatically derived freeform textual reference to a key frame of video in the data set
    /// </remarks>
    private static readonly byte[] ComputedKeyFrames_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x02, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Computed Key Sounds
    /// </summary>
    /// <remarks>
    /// Automatically derived freeform textual reference to a key sound in the data set
    /// </remarks>
    private static readonly byte[] ComputedKeySounds_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x02, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Computed Keywords
    /// </summary>
    /// <remarks>
    /// Automatically derived words or phrases summarizing an aspect of the data set.
    /// </remarks>
    private static readonly byte[] ComputedKeywords = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x01, 0x02, 0x06, 0x01, 0x00, 0x00];
    /// <summary>
    /// Computed Keywords
    /// </summary>
    /// <remarks>
    /// Automatically derived words or phrases summarizing an aspect of the data set.
    /// </remarks>
    private static readonly byte[] ComputedKeywords_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x02, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Computed Object Comments and Descriptions
    /// </summary>
    /// <remarks>
    /// Comments or descriptions relating to objects
    /// </remarks>
    private static readonly byte[] ComputedObjectCommentsAndDescriptions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Computed Object Kind
    /// </summary>
    /// <remarks>
    /// Specifies the kind of object (e.g., a plugin)
    /// </remarks>
    private static readonly byte[] ComputedObjectKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x03, 0x01, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Computed Object Kind
    /// </summary>
    /// <remarks>
    /// Specifies the kind of object (e.g., a plugin)
    /// </remarks>
    private static readonly byte[] ComputedObjectKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Computed Stratum Kind
    /// </summary>
    /// <remarks>
    /// Automatically derived descriptive stratum of the content (e.g., background, action, sound nature)
    /// </remarks>
    private static readonly byte[] ComputedStratumKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x07, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Computed Technical Comments and Descriptions
    /// </summary>
    /// <remarks>
    /// Technical comments or descriptions relating to system
    /// </remarks>
    private static readonly byte[] ComputedTechnicalCommentsAndDescriptions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Computed Textual Description
    /// </summary>
    /// <remarks>
    /// Automated textual characterization of the data set.
    /// </remarks>
    private static readonly byte[] ComputedTextualDescription = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Conforms To Specifications
    /// </summary>
    /// <remarks>
    /// Identifies the specification(s) to which an MXF file conforms.
    /// </remarks>
    private static readonly byte[] ConformsToSpecifications = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x01, 0x02, 0x02, 0x10, 0x02, 0x04, 0x00, 0x00];
    /// <summary>
    /// Constant B Picture Flag
    /// </summary>
    /// <remarks>
    /// TRUE if the number of B frames is always constant
    /// </remarks>
    private static readonly byte[] ConstantBPictureCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x01, 0x06, 0x02, 0x01, 0x03, 0x00, 0x00];
    /// <summary>
    /// Consumer Rights to Copy
    /// </summary>
    /// <remarks>
    /// Indicates whether the consumer has the rights to copy the program
    /// </remarks>
    private static readonly byte[] ConsumerRightsToCopy = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x09, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contact
    /// </summary>
    /// <remarks>
    /// A set of attributes to provide personal information about a Contact / Person
    /// </remarks>
    private static readonly byte[] contact = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x22, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contact Department Name
    /// </summary>
    /// <remarks>
    /// Name information for a department within an organization where contact can be made
    /// </remarks>
    private static readonly byte[] ContactDepartment = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x30, 0x06, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contact Department Name
    /// </summary>
    /// <remarks>
    /// Name information for a department within an organization where contact can be made
    /// </remarks>
    private static readonly byte[] ContactDepartmentName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contact Details Sets
    /// </summary>
    /// <remarks>
    /// A strong reference to a details object
    /// </remarks>
    private static readonly byte[] contactDetailsObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x22, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contact ID
    /// </summary>
    /// <remarks>
    /// Unique identifier of a Contact set as the target of a generalized weak (global) reference
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] ContactID_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x01, 0x01, 0x15, 0x40, 0x01, 0x02, 0x00, 0x00];
    /// <summary>
    /// Contact ID
    /// </summary>
    /// <remarks>
    /// An identifier attributed to the contact / person
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] ContactID_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x22, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contact Information
    /// </summary>
    /// <remarks>
    /// Contact information for the participating party
    /// </remarks>
    private static readonly byte[] ContactInformation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contact Kind
    /// </summary>
    /// <remarks>
    /// Client, supplier, useful etc
    /// </remarks>
    private static readonly byte[] ContactKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x30, 0x06, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contact Kind
    /// </summary>
    /// <remarks>
    /// Client, supplier, useful etc
    /// </remarks>
    private static readonly byte[] ContactKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contact Last Update
    /// </summary>
    /// <remarks>
    /// The date when the contact information has been last updated
    /// </remarks>
    private static readonly byte[] contactLastUpdate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x22, 0x17, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contact Name Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to provide one or more compound names (family + given names + salutation...) or for other purposes
    /// </remarks>
    private static readonly byte[] contactNameObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x22, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contact Name-Value Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Name-Value sets
    /// </remarks>
    private static readonly byte[] ContactNameValueObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x1F, 0x02];
    /// <summary>
    /// Contact Related Contact Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to contact objects (entity)
    /// </remarks>
    private static readonly byte[] contactRelatedContactObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x22, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contact Related Information Link Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to links to e.g. a webpage where more information can be found about the contact/person
    /// </remarks>
    private static readonly byte[] contactRelatedInformationLinkObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x22, 0x0F, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contacts List Set
    /// </summary>
    /// <remarks>
    /// A strong reference to the Contacts List set
    /// </remarks>
    private static readonly byte[] ContactsListObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x02, 0x40, 0x22, 0x00];
    /// <summary>
    /// Contact Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group  to define the type of contact information (e.g. "business" or "private")
    /// </remarks>
    private static readonly byte[] contactTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x22, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// URL
    /// </summary>
    /// <remarks>
    /// The contact's web home page address
    /// </remarks>
    private static readonly byte[] ContactWebPage = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x07, 0x01, 0x20, 0x01, 0x10, 0x03, 0x06, 0x01];
    /// <summary>
    /// URL
    /// </summary>
    /// <remarks>
    /// Web home page URL
    /// </remarks>
    private static readonly byte[] ContactWebPage_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x07, 0x01, 0x20, 0x01, 0x10, 0x03, 0x06, 0x00];
    /// <summary>
    /// Container Codec Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a codec object
    /// </remarks>
    private static readonly byte[] containerCodecObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x48, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Container Definitions
    /// </summary>
    /// <remarks>
    /// Specifies a unordered set of references to Container Definitions
    /// </remarks>
    private static readonly byte[] ContainerDefinitions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x05, 0x08, 0x00, 0x00];
    /// <summary>
    /// Container Encoding Format Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a format group object
    /// </remarks>
    private static readonly byte[] containerEncodingFormatGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x48, 0x15, 0x00, 0x00, 0x00];
    /// <summary>
    /// Essence Container Format
    /// </summary>
    /// <remarks>
    /// Specifies a reference to the format of Container of Essence Data
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] ContainerFormat_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x01, 0x02, 0x00, 0x00];
    /// <summary>
    /// Container Format
    /// </summary>
    /// <remarks>
    /// A set of attributes to define the format of a container
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] ContainerFormat_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x48, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Container Format Id
    /// </summary>
    /// <remarks>
    /// An Id associated with a container format
    /// </remarks>
    private static readonly byte[] containerFormatId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x48, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Container Format Name
    /// </summary>
    /// <remarks>
    /// A strong reference to a format group to define the format of the container
    /// </remarks>
    private static readonly byte[] containerFormatName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x48, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Container Format Profile
    /// </summary>
    /// <remarks>
    /// A profile of a container format
    /// </remarks>
    private static readonly byte[] containerFormatProfile = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x48, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Container Format Profile Level
    /// </summary>
    /// <remarks>
    /// A level of a container format
    /// </remarks>
    private static readonly byte[] containerFormatProfileLevel = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x48, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Container Format Version Id
    /// </summary>
    /// <remarks>
    /// An Id associated with a container format version
    /// </remarks>
    private static readonly byte[] containerFormatVersionId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x48, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Container Note
    /// </summary>
    /// <remarks>
    /// A contextual information note
    /// </remarks>
    private static readonly byte[] containerNote = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x48, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Container Technical Attribute AnyURI Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type AnyURI
    /// </remarks>
    private static readonly byte[] containerTechnicalAttributeAnyURIObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x48, 0x13, 0x00, 0x00, 0x00];
    /// <summary>
    /// Container Technical Attribute Boolean Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Boolean
    /// </remarks>
    private static readonly byte[] containerTechnicalAttributeBooleanObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x48, 0x14, 0x00, 0x00, 0x00];
    /// <summary>
    /// Container Technical Attribute Float Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Float
    /// </remarks>
    private static readonly byte[] containerTechnicalAttributeFloatObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x48, 0x11, 0x00, 0x00, 0x00];
    /// <summary>
    /// Container Technical Attribute Int16 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int16
    /// </remarks>
    private static readonly byte[] containerTechnicalAttributeInt16Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x48, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Container Technical Attribute Int32 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int32
    /// </remarks>
    private static readonly byte[] containerTechnicalAttributeInt32Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x48, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Container Technical Attribute Int64 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int64
    /// </remarks>
    private static readonly byte[] containerTechnicalAttributeInt64Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x48, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Container Technical Attribute Int8 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int8
    /// </remarks>
    private static readonly byte[] containerTechnicalAttributeInt8Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x48, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Container Technical Attribute Rational Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Rational
    /// </remarks>
    private static readonly byte[] containerTechnicalAttributeRationalObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x48, 0x12, 0x00, 0x00, 0x00];
    /// <summary>
    /// Container Technical Attribute String Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type string
    /// </remarks>
    private static readonly byte[] containerTechnicalAttributeStringObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x48, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Container Technical Attribute UInt16 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt16
    /// </remarks>
    private static readonly byte[] containerTechnicalAttributeUInt16Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x48, 0x0E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Container Technical Attribute UInt32 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt32
    /// </remarks>
    private static readonly byte[] containerTechnicalAttributeUInt32Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x48, 0x0F, 0x00, 0x00, 0x00];
    /// <summary>
    /// Container Technical Attribute UInt64 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt64
    /// </remarks>
    private static readonly byte[] containerTechnicalAttributeUInt64Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x48, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// Container Technical Attribute UInt8 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt8
    /// </remarks>
    private static readonly byte[] containerTechnicalAttributeUInt8Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x48, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Container Version
    /// </summary>
    /// <remarks>
    /// Specifies the container version number
    /// </remarks>
    private static readonly byte[] ContainerVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x07, 0x01, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Content Capture
    /// </summary>
    /// <remarks>
    /// Information about how content was captured
    /// </remarks>
    private static readonly byte[] ContentCapture = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Content Classification
    /// </summary>
    /// <remarks>
    /// The value of the content classification as a (possibly subdivided) alphanumeric string
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] ContentClassification_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Content Classification
    /// </summary>
    /// <remarks>
    /// A textual description or for example a string of coded numbers as in the EBU Escort schema for classification
    /// Namespace: http://www.smpte-ra.org/reg/335/2012/13/11
    /// </remarks>
    private static readonly byte[] ContentClassification_11 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Content Coding System
    /// </summary>
    /// <remarks>
    /// The system of coding for program classification eg Escort 2.4
    /// </remarks>
    private static readonly byte[] ContentCodingSystem_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Content Maturity Description
    /// </summary>
    /// <remarks>
    /// Textual classification as used in "kijkwijzer" www.kijkwijzer.nl
    /// </remarks>
    private static readonly byte[] ContentMaturityDescription = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Content Maturity Graphic
    /// </summary>
    /// <remarks>
    /// Graphical claasification as used in "kijkwijzer" www.kijkwijzer.nl
    /// </remarks>
    private static readonly byte[] ContentMaturityGraphic = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x07, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Content Maturity Rating
    /// </summary>
    /// <remarks>
    /// Classification goepings as used in "kijkwijzer" www.kijkwijzer.nl
    /// </remarks>
    private static readonly byte[] ContentMaturityRating = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x07, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Content Package Index Array
    /// </summary>
    /// <remarks>
    /// An ordered array of index entries for each frame in this Content Package
    /// </remarks>
    private static readonly byte[] ContentPackageIndexArray = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x04, 0x04, 0x04, 0x02, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Content Package Metadata Link
    /// </summary>
    /// <remarks>
    /// Defines a local link between essence and its metadata
    /// </remarks>
    private static readonly byte[] ContentPackageMetadataLink = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x07, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Content
    /// </summary>
    /// <remarks>
    /// Specifes a reference to the packages and essence in a file
    /// </remarks>
    private static readonly byte[] ContentStorageObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Content Value
    /// </summary>
    /// <remarks>
    /// Assessment of the content value
    /// </remarks>
    private static readonly byte[] ContentValue_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Context Description
    /// </summary>
    /// <remarks>
    /// A textual anotation of the context of the production.
    /// </remarks>
    private static readonly byte[] ContextDescription_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Continuity Counts
    /// </summary>
    /// <remarks>
    /// Defines packet etc. sequences
    /// </remarks>
    private static readonly byte[] ContinuityCounts = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x08, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contract
    /// </summary>
    /// <remarks>
    /// Information about the program contract
    /// </remarks>
    private static readonly byte[] Contract = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contract Clause Description
    /// </summary>
    /// <remarks>
    /// The description given to a clause within a contract
    /// </remarks>
    private static readonly byte[] ContractClauseDescription = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contract Clause Description
    /// </summary>
    /// <remarks>
    /// The description given to a clause within a contract
    /// </remarks>
    private static readonly byte[] ContractClauseDescription_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contract Date-Time
    /// </summary>
    /// <remarks>
    /// Date and time of a contract.
    /// </remarks>
    private static readonly byte[] ContractDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x07, 0x02, 0x01, 0x20, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contract Descriptions
    /// </summary>
    /// <remarks>
    /// Detail descriptive information about a contract
    /// </remarks>
    private static readonly byte[] ContractDescriptions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contract Entity
    /// </summary>
    /// <remarks>
    /// The name of the party that signed the contract
    /// </remarks>
    private static readonly byte[] ContractEntity = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contract Installment Percentage
    /// </summary>
    /// <remarks>
    /// The value of a contract installment as a percentage of the total value
    /// </remarks>
    private static readonly byte[] ContractInstallmentPercentage = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x04, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contract Line Code
    /// </summary>
    /// <remarks>
    /// Description of the product or service covered by a line in the contract, as a code
    /// </remarks>
    private static readonly byte[] ContractLineCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contract Line Name
    /// </summary>
    /// <remarks>
    /// Description of the product or service covered by a line in the contract, as a name
    /// </remarks>
    private static readonly byte[] ContractLineName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x04, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contract Line Name
    /// </summary>
    /// <remarks>
    /// Description of the product or serve covered by a line in the contract, as a name
    /// </remarks>
    private static readonly byte[] ContractLineName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x04, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contract Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Contract sets
    /// </remarks>
    private static readonly byte[] ContractObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x19, 0x00];
    /// <summary>
    /// Contract Participant Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of generalized weak (global) references to Participant sets for Contract
    /// </remarks>
    private static readonly byte[] ContractParticipants = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x03, 0x40, 0x13, 0x02];
    /// <summary>
    /// Contract Terms of Business
    /// </summary>
    /// <remarks>
    /// The definition of the terms applying to the contract
    /// </remarks>
    private static readonly byte[] ContractTermsOfBusiness = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x04, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contract Terms of Business
    /// </summary>
    /// <remarks>
    /// The definition of the terms applying to the contract
    /// </remarks>
    private static readonly byte[] ContractTermsOfBusiness_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contract Type
    /// </summary>
    /// <remarks>
    /// Description of the contract type using terms agreed between the contracting parties
    /// </remarks>
    private static readonly byte[] ContractType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x04, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contract Type
    /// </summary>
    /// <remarks>
    /// Description of the contract type using terms agreed between the contracting parties
    /// </remarks>
    private static readonly byte[] ContractType_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contract Type Code
    /// </summary>
    /// <remarks>
    /// Description of the contract type using terms as a code
    /// </remarks>
    private static readonly byte[] ContractTypeCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x04, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contract Type Link
    /// </summary>
    /// <remarks>
    /// Contains a conditional access link to the program content.
    /// </remarks>
    private static readonly byte[] ContractTypeLink = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x08, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contribution Status
    /// </summary>
    /// <remarks>
    /// Performing talent, Non performing talent, Production Staff, Technical staff, Specialist etc
    /// </remarks>
    private static readonly byte[] ContributionStatus = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x30, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Contribution Status
    /// </summary>
    /// <remarks>
    /// Performing talent, Non performing talent, Production Staff, Technical staff, Specialist etc
    /// </remarks>
    private static readonly byte[] ContributionStatus_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contributor
    /// </summary>
    /// <remarks>
    /// A contributor to the resource optionally associated with a specific role
    /// </remarks>
    private static readonly byte[] contributor = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0B, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contributor Entity Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to one or more contributors with varying roles
    /// </remarks>
    private static readonly byte[] contributorEntityObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x02, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Control Point Time
    /// </summary>
    /// <remarks>
    /// Control Point Time Offset - expressed as proportion of the duration of the effect
    /// </remarks>
    private static readonly byte[] ControlPointTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x07, 0x02, 0x01, 0x03, 0x10, 0x02, 0x01, 0x00];
    /// <summary>
    /// Control Point Value
    /// </summary>
    /// <remarks>
    /// Effect or Transformation Value at specific time
    /// </remarks>
    private static readonly byte[] ControlPointValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x30, 0x05, 0x0D, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Coordinates
    /// </summary>
    /// <remarks>
    /// A set of attributes to define geographical coordinates
    /// </remarks>
    private static readonly byte[] coordinates = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x16, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Coordinates Format Group Set
    /// </summary>
    /// <remarks>
    /// A reference to an attribute format group to specify the format of coordinates being used
    /// </remarks>
    private static readonly byte[] coordinatesFormatGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x16, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Copy Count
    /// </summary>
    /// <remarks>
    /// The number of copies (i.e. not lossless clones)
    /// </remarks>
    private static readonly byte[] CopyCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x01, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Copyright
    /// </summary>
    /// <remarks>
    /// Copyright metadata
    /// </remarks>
    private static readonly byte[] Copyright = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Copyright License Country Code
    /// </summary>
    /// <remarks>
    /// The ISO code that represents a country where copyright is licensed
    /// </remarks>
    private static readonly byte[] CopyrightLicenseCountryCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x02, 0x04, 0x00, 0x00];
    /// <summary>
    /// Copyright License Region Code
    /// </summary>
    /// <remarks>
    /// The ISO code that represents a region of a country where copyright is licensed
    /// </remarks>
    private static readonly byte[] CopyrightLicenseRegionCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x03, 0x04, 0x00, 0x00];
    /// <summary>
    /// Copyright License Region Name
    /// </summary>
    /// <remarks>
    /// The region of a country where copyright is licensed
    /// </remarks>
    private static readonly byte[] CopyrightLicenseRegionName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x03, 0x04, 0x01, 0x00];
    /// <summary>
    /// Copyright Owner Name
    /// </summary>
    /// <remarks>
    /// The name of the person/organization who owns the copyright.
    /// </remarks>
    private static readonly byte[] CopyrightOwner = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x05, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Copyright Owner Name
    /// </summary>
    /// <remarks>
    /// The name of the person/organization who owns the copyright.
    /// </remarks>
    private static readonly byte[] CopyrightOwnerName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x05, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Copyright Statement Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to a textual annotation to express copyright statements
    /// </remarks>
    private static readonly byte[] copyrightStatementObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x19, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Copyright Status
    /// </summary>
    /// <remarks>
    /// Executive evaluation of copyright status
    /// </remarks>
    private static readonly byte[] CopyrightStatus = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x05, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Copyright Status
    /// </summary>
    /// <remarks>
    /// Executive evaluation of copyright status
    /// </remarks>
    private static readonly byte[] CopyrightStatus_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x05, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Core Metadata
    /// </summary>
    /// <remarks>
    /// EBUCore's core set of descriptive and technical metadata
    /// </remarks>
    private static readonly byte[] coreMetadata = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Core Metadata Set
    /// </summary>
    /// <remarks>
    /// A strong reference to EBUCore's core set of descriptive and technical metadata
    /// </remarks>
    private static readonly byte[] coreMetadataObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Corner Latitude Point 1
    /// </summary>
    /// <remarks>
    /// Latitude coordinate of corner 1 of an image or bounding rectangle
    /// </remarks>
    private static readonly byte[] CornerLatitudePoint1_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x02, 0x01, 0x03, 0x07, 0x00, 0x00];
    /// <summary>
    /// Corner Latitude Point 1 (Decimal Degrees)
    /// </summary>
    /// <remarks>
    /// Latitude coordinate of corner 1 of an image or bounding rectangle
    /// </remarks>
    private static readonly byte[] CornerLatitudePoint1DecimalDegrees = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x02, 0x01, 0x03, 0x07, 0x01, 0x00];
    /// <summary>
    /// Corner Latitude Point 2
    /// </summary>
    /// <remarks>
    /// Latitude coordinate of corner 2 of an image or bounding rectangle
    /// </remarks>
    private static readonly byte[] CornerLatitudePoint2_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x02, 0x01, 0x03, 0x08, 0x00, 0x00];
    /// <summary>
    /// Corner Latitude Point 2 (Decimal Degrees)
    /// </summary>
    /// <remarks>
    /// Latitude coordinate of corner 2 of an image or bounding rectangle
    /// </remarks>
    private static readonly byte[] CornerLatitudePoint2DecimalDegrees = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x02, 0x01, 0x03, 0x08, 0x01, 0x00];
    /// <summary>
    /// Corner Latitude Point 3
    /// </summary>
    /// <remarks>
    /// Latitude coordinate of corner 3 of an image or bounding rectangle
    /// </remarks>
    private static readonly byte[] CornerLatitudePoint3_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x02, 0x01, 0x03, 0x09, 0x00, 0x00];
    /// <summary>
    /// Corner Latitude Point 3 (Decimal Degrees)
    /// </summary>
    /// <remarks>
    /// Latitude coordinate of corner 3 of an image or bounding rectangle
    /// </remarks>
    private static readonly byte[] CornerLatitudePoint3DecimalDegrees = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x02, 0x01, 0x03, 0x09, 0x01, 0x00];
    /// <summary>
    /// Corner Latitude Point 4
    /// </summary>
    /// <remarks>
    /// Latitude coordinate of corner 4 of an image or bounding rectangle
    /// </remarks>
    private static readonly byte[] CornerLatitudePoint4_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x02, 0x01, 0x03, 0x0A, 0x00, 0x00];
    /// <summary>
    /// Corner Latitude Point 4 (Decimal Degrees)
    /// </summary>
    /// <remarks>
    /// Latitude coordinate of corner 4 of an image or bounding rectangle
    /// </remarks>
    private static readonly byte[] CornerLatitudePoint4DecimalDegrees = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x02, 0x01, 0x03, 0x0A, 0x01, 0x00];
    /// <summary>
    /// Corner Longitude Point 1
    /// </summary>
    /// <remarks>
    /// Longitude coordinate of corner 1 of an image or bounding rectangle
    /// </remarks>
    private static readonly byte[] CornerLongitudePoint1_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x02, 0x01, 0x03, 0x0B, 0x00, 0x00];
    /// <summary>
    /// Corner Longitude Point 1 (Decimal Degrees)
    /// </summary>
    /// <remarks>
    /// Longitude coordinate of corner 1 of an image or bounding rectangle
    /// </remarks>
    private static readonly byte[] CornerLongitudePoint1DecimalDegrees = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x02, 0x01, 0x03, 0x0B, 0x01, 0x00];
    /// <summary>
    /// Corner Longitude Point 2
    /// </summary>
    /// <remarks>
    /// Longitude coordinate of corner 2 of an image or bounding rectangle
    /// </remarks>
    private static readonly byte[] CornerLongitudePoint2_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x02, 0x01, 0x03, 0x0C, 0x00, 0x00];
    /// <summary>
    /// Corner Longitude Point 2 (Decimal Degrees)
    /// </summary>
    /// <remarks>
    /// Longitude coordinate of corner 2 of an image or bounding rectangle
    /// </remarks>
    private static readonly byte[] CornerLongitudePoint2DecimalDegrees = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x02, 0x01, 0x03, 0x0C, 0x01, 0x00];
    /// <summary>
    /// Corner Longitude Point 3
    /// </summary>
    /// <remarks>
    /// Longitude coordinate of corner 3 of an image or bounding rectangle
    /// </remarks>
    private static readonly byte[] CornerLongitudePoint3_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x02, 0x01, 0x03, 0x0D, 0x00, 0x00];
    /// <summary>
    /// Corner Longitude Point 3 (Decimal Degrees)
    /// </summary>
    /// <remarks>
    /// Longitude coordinate of corner 3 of an image or bounding rectangle
    /// </remarks>
    private static readonly byte[] CornerLongitudePoint3DecimalDegrees = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x02, 0x01, 0x03, 0x0D, 0x01, 0x00];
    /// <summary>
    /// Corner Longitude Point 4
    /// </summary>
    /// <remarks>
    /// Longitude coordinate of corner 4 of an image or bounding rectangle
    /// </remarks>
    private static readonly byte[] CornerLongitudePoint4_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x02, 0x01, 0x03, 0x0E, 0x00, 0x00];
    /// <summary>
    /// Corner Longitude Point 4 (Decimal Degrees)
    /// </summary>
    /// <remarks>
    /// Longitude coordinate of corner 4 of an image or bounding rectangle
    /// </remarks>
    private static readonly byte[] CornerLongitudePoint4DecimalDegrees = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x02, 0x01, 0x03, 0x0E, 0x01, 0x00];
    /// <summary>
    /// Cost Center Reference
    /// </summary>
    /// <remarks>
    /// The cost center reference against which activities associated to the role / job are being billed
    /// </remarks>
    private static readonly byte[] costCenterReference = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x29, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Countries and Languages
    /// </summary>
    /// <remarks>
    /// Defining information about Countries and languages
    /// </remarks>
    private static readonly byte[] CountriesAndLanguages = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Country Name
    /// </summary>
    /// <remarks>
    /// The country of the address.
    /// </remarks>
    private static readonly byte[] Country = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x08, 0x01];
    /// <summary>
    /// Country Name
    /// </summary>
    /// <remarks>
    /// The country of the address.
    /// </remarks>
    private static readonly byte[] Country_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x08, 0x00];
    /// <summary>
    /// Country and Region Codes
    /// </summary>
    /// <remarks>
    /// Country Codes and Region Codes
    /// </remarks>
    private static readonly byte[] CountryAndRegionCodes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Country and Region Names
    /// </summary>
    /// <remarks>
    /// Country Names and Region Names
    /// </remarks>
    private static readonly byte[] CountryAndRegionNames = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x01, 0x01, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// Country Code Method
    /// </summary>
    /// <remarks>
    /// The coding method used to identify the Non-US classifying country and countries in the releasing instructions
    /// </remarks>
    private static readonly byte[] CountryCodeMethod = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x07, 0x01, 0x20, 0x01, 0x02, 0x07, 0x01, 0x00];
    /// <summary>
    /// Country Codes
    /// </summary>
    /// <remarks>
    /// Country code information
    /// </remarks>
    private static readonly byte[] CountryCodes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Country Name
    /// </summary>
    /// <remarks>
    /// The ISO name for a Region or Territory
    /// </remarks>
    private static readonly byte[] CountryName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x01, 0x01, 0x10, 0x01, 0x01, 0x00];
    /// <summary>
    /// Country Name
    /// </summary>
    /// <remarks>
    /// The ISO name for a Region or Territory
    /// </remarks>
    private static readonly byte[] CountryName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x01, 0x01, 0x10, 0x01, 0x00, 0x00];
    /// <summary>
    /// Country Set
    /// </summary>
    /// <remarks>
    /// A strong reference to identifiy a country
    /// </remarks>
    private static readonly byte[] countryObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x27, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Country Name Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to provide the country names and code optionally in different languages
    /// </remarks>
    private static readonly byte[] countryObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x26, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Country Region Set
    /// </summary>
    /// <remarks>
    /// A strong reference to identifiy one or more region in a country
    /// </remarks>
    private static readonly byte[] countryRegionObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x27, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Country Type
    /// </summary>
    /// <remarks>
    /// A set of attributes to define a country by its name or code
    /// </remarks>
    private static readonly byte[] countryType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2A, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Country Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group to provide a country name or code
    /// </remarks>
    private static readonly byte[] countryTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2A, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// County State Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to provide the names of a county / state / region optionally in differnet languages
    /// </remarks>
    private static readonly byte[] countyStateObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x26, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Coverage
    /// </summary>
    /// <remarks>
    /// Temporal and spatial information about the resource (factual or depicted)
    /// </remarks>
    private static readonly byte[] coverage = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x13, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Coverage Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to one or more coverages (temporal, spatial)
    /// </remarks>
    private static readonly byte[] coverageObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x02, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Coverage Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group to specify the type of coverage information being provided
    /// </remarks>
    private static readonly byte[] coverageTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x13, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Coverage Value Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a general textual annotation to describe coverage information
    /// </remarks>
    private static readonly byte[] coverageValueObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x13, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// CPL ID
    /// </summary>
    /// <remarks>
    /// CPL UUID
    /// </remarks>
    private static readonly byte[] CPLID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x11, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// CPLProcessed Report Delinquency Time
    /// </summary>
    /// <remarks>
    /// Timestamp when the CPLProcessed event collection by the SMS becomes delinquent
    /// </remarks>
    private static readonly byte[] CPLProcessedReportDelinquencyTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x19, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// CplValidation Batch
    /// </summary>
    /// <remarks>
    /// An unordered batch of CPL validation results
    /// </remarks>
    private static readonly byte[] CplValidationBatch = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x18, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// CPL XML Data
    /// </summary>
    /// <remarks>
    /// CPL data
    /// </remarks>
    private static readonly byte[] CPLXMLData = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x0E, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// CPL XML Data Length
    /// </summary>
    /// <remarks>
    /// CPL data length
    /// </remarks>
    private static readonly byte[] CPLXMLDataLength = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x0D, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Creation Date-Time
    /// </summary>
    /// <remarks>
    /// Identifies date and time at the point of creation.
    /// </remarks>
    private static readonly byte[] CreationDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x10, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Creation Date-Time
    /// </summary>
    /// <remarks>
    /// Identifies date and time at the point of creation.
    /// </remarks>
    private static readonly byte[] CreationTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x07, 0x02, 0x01, 0x10, 0x01, 0x03, 0x00, 0x00];
    /// <summary>
    /// Creation Timestamp
    /// </summary>
    /// <remarks>
    /// IEEE 1588-2019 PTP Timestamp documenting the time at which the data in the data set were created
    /// </remarks>
    private static readonly byte[] CreationTimestamp = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x07, 0x02, 0x01, 0x10, 0x01, 0x05, 0x00, 0x00];
    /// <summary>
    /// Creator
    /// </summary>
    /// <remarks>
    /// A creator of the resource e.g. personla behind the camera
    /// </remarks>
    private static readonly byte[] creator = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Creator Entity Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to one or more creators
    /// </remarks>
    private static readonly byte[] creatorEntityObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Cryptographic Context ID
    /// </summary>
    /// <remarks>
    /// Identifies the Cryptographic Context used for data encryption
    /// </remarks>
    private static readonly byte[] CryptographicContextID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x01, 0x01, 0x15, 0x11, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Cryptographic Context Link
    /// </summary>
    /// <remarks>
    /// Links to the cryptographic context used for data encryption
    /// </remarks>
    private static readonly byte[] CryptographicContextLink = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x06, 0x01, 0x01, 0x06, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Cryptographic Context Object
    /// </summary>
    /// <remarks>
    /// A strong reference to the cryptographic context
    /// </remarks>
    private static readonly byte[] CryptographicContextObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x06, 0x01, 0x01, 0x04, 0x02, 0x0D, 0x00, 0x00];
    /// <summary>
    /// Cryptographic Key ID
    /// </summary>
    /// <remarks>
    /// The identifier of the Key used for Digital Cinema encryption
    /// </remarks>
    private static readonly byte[] CryptographicKeyID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x02, 0x09, 0x03, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Csiz
    /// </summary>
    /// <remarks>
    /// The number of components in the picture as defined in ISO/IEC 15444-1 Annex A.5.1. If this Sub Descriptor is referenced by the CDCI Descriptor, the order and kind of components shall be as defined by the Essence Container UL in the MXF File Descriptor. If this Sub Descriptor is referenced by the RGBA Descriptor, the order and kind of components shall be as defined by the Pixel Layout property of the RGBA Descriptor.
    /// </remarks>
    private static readonly byte[] Csiz = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x06, 0x03, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Cue-In Words
    /// </summary>
    /// <remarks>
    /// The actual words on the sound track or a textual reference to music etc. at the in-cue point
    /// </remarks>
    private static readonly byte[] CueInWords_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x01, 0x02, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Cue-Out Words
    /// </summary>
    /// <remarks>
    /// The words on the sound track or a textual reference to music etc. at the out-cue point
    /// </remarks>
    private static readonly byte[] CueOutWords_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x01, 0x02, 0x0E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Qlty Cue Sheet
    /// </summary>
    /// <remarks>
    /// String of cue points, timestamps and descriptions from the BWF &lt;qlty&gt; chunk
    /// </remarks>
    private static readonly byte[] CueSheet = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x05, 0x02, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Cue Words Sets
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] CueWordsSets = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x02, 0x40, 0x23, 0x00];
    /// <summary>
    /// Cultural Value
    /// </summary>
    /// <remarks>
    /// Assessment of the cultural quality
    /// </remarks>
    private static readonly byte[] CulturalValue_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x02, 0x02, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Currencies
    /// </summary>
    /// <remarks>
    /// Information about currencies involved in transactions
    /// </remarks>
    private static readonly byte[] Currencies = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Currency Code
    /// </summary>
    /// <remarks>
    /// International Standards Organisation Codes for the representation of currencies and funds
    /// </remarks>
    private static readonly byte[] CurrencyCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Currency Name
    /// </summary>
    /// <remarks>
    /// The currency of the transaction as a name
    /// </remarks>
    private static readonly byte[] CurrencyName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x06, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Current Number in Sequence
    /// </summary>
    /// <remarks>
    /// The current number in a sequence
    /// </remarks>
    private static readonly byte[] CurrentNumberInSequence = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x10, 0x10, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Current Repeat Number
    /// </summary>
    /// <remarks>
    /// The number of the current repeat
    /// </remarks>
    private static readonly byte[] CurrentRepeatNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x20, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Custom Relation
    /// </summary>
    /// <remarks>
    /// A set of attributes to express a custom relation between resources
    /// </remarks>
    private static readonly byte[] customRelation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Relation By Name
    /// </summary>
    /// <remarks>
    /// Related resource identified by name
    /// </remarks>
    private static readonly byte[] customRelationByName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Custom Relation Identifier Set
    /// </summary>
    /// <remarks>
    /// A strong reference to related resource identified by an identifier
    /// </remarks>
    private static readonly byte[] customRelationIdentifierObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x01, 0x08, 0x00, 0x00];
    /// <summary>
    /// Relation Link
    /// </summary>
    /// <remarks>
    /// Related resource identified by a URI
    /// </remarks>
    private static readonly byte[] customRelationLink = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x01, 0x02, 0x00, 0x00];
    /// <summary>
    /// Custom relation Note
    /// </summary>
    /// <remarks>
    /// To provide additional contextual,information
    /// </remarks>
    private static readonly byte[] customRelationNote = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x01, 0x06, 0x00, 0x00];
    /// <summary>
    /// Custom Relation Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to one or more custom relations to other resources
    /// </remarks>
    private static readonly byte[] customRelationObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x02, 0x12, 0x00, 0x00, 0x00];
    /// <summary>
    /// Custom Relation Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group to define the type of relation being described
    /// </remarks>
    private static readonly byte[] customRelationTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x01, 0x07, 0x00, 0x00];
    /// <summary>
    /// Cut Point
    /// </summary>
    /// <remarks>
    /// Specifies the point, in edit units, in a track at which a cut occurs.
    /// </remarks>
    private static readonly byte[] CutPoint = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x07, 0x02, 0x01, 0x03, 0x01, 0x06, 0x00, 0x00];
    /// <summary>
    /// D-BOX Technologies
    /// </summary>
    /// <remarks>
    /// Metadata registered by D-BOX Technologies for private use
    /// </remarks>
    private static readonly byte[] D_BOXTechnologies = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Capture Process
    /// </summary>
    /// <remarks>
    /// Information about how data content was captured
    /// </remarks>
    private static readonly byte[] DataCaptureProcess = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x01, 0x02, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Codec Object
    /// </summary>
    /// <remarks>
    /// A strong reference to a codec object
    /// </remarks>
    private static readonly byte[] dataCodecObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Compression History
    /// </summary>
    /// <remarks>
    /// Audit history of compression for payload.
    /// </remarks>
    private static readonly byte[] DataCompressionHistory = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Definition
    /// </summary>
    /// <remarks>
    /// The value defines the kind of data or metadata to which it refers
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] DataDefinition_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x07, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Definition
    /// </summary>
    /// <remarks>
    /// Identifies the value of PHDR Data Definition
    /// Namespace: http://www.smpte-ra.org/reg/335/2012/14/9
    /// </remarks>
    private static readonly byte[] DataDefinition_9 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x0E, 0x09, 0x06, 0x07, 0x01, 0x01, 0x01, 0x04];
    /// <summary>
    /// Data Definitions
    /// </summary>
    /// <remarks>
    /// Specifies a unordered set of references to Data Definitions
    /// </remarks>
    private static readonly byte[] DataDefinitions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x05, 0x05, 0x00, 0x00];
    /// <summary>
    /// Data Device Kind
    /// </summary>
    /// <remarks>
    /// Specific description for a device
    /// </remarks>
    private static readonly byte[] DataDeviceKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x20, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Device Parameter Name
    /// </summary>
    /// <remarks>
    /// Specific parameter for the specified device
    /// </remarks>
    private static readonly byte[] DataDeviceParameterName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x20, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Device Parameter Setting
    /// </summary>
    /// <remarks>
    /// The setting of the specific parameter for the specified device
    /// </remarks>
    private static readonly byte[] DataDeviceParameterSetting_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x20, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Encryption
    /// </summary>
    /// <remarks>
    /// Content encryption/decryption information for data
    /// </remarks>
    private static readonly byte[] DataEncryption = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x02, 0x09, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Encryption Algorithms
    /// </summary>
    /// <remarks>
    /// Information about data encryption algorithms
    /// </remarks>
    private static readonly byte[] DataEncryptionAlgorithms = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x02, 0x09, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Enhancement or Modification Description
    /// </summary>
    /// <remarks>
    /// Description of how data content was modified.
    /// </remarks>
    private static readonly byte[] DataEnhancementOrModificationDescription_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x20, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Essence Characteristics
    /// </summary>
    /// <remarks>
    /// Operating characteristics of the device creating the data essence.
    /// </remarks>
    private static readonly byte[] DataEssenceCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Essence Coding ID
    /// </summary>
    /// <remarks>
    /// Specifies the data essence coding type
    /// </remarks>
    private static readonly byte[] DataEssenceCoding = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x03, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Essence Compression
    /// </summary>
    /// <remarks>
    /// Information about data essence compression.
    /// </remarks>
    private static readonly byte[] DataEssenceCompression = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Essence Processing
    /// </summary>
    /// <remarks>
    /// Enhamcement or modification to the data essence
    /// </remarks>
    private static readonly byte[] DataEssenceProcessing = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x20, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Essence Test Parameters
    /// </summary>
    /// <remarks>
    /// Data test parameters from the original recording
    /// </remarks>
    private static readonly byte[] DataEssenceTestParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x03, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Format
    /// </summary>
    /// <remarks>
    /// A set of attributes to describe data carried in the material
    /// </remarks>
    private static readonly byte[] dataFormat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Format Definition
    /// </summary>
    /// <remarks>
    /// A definition of the data format
    /// </remarks>
    private static readonly byte[] dataFormatDefinition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Format ID
    /// </summary>
    /// <remarks>
    /// An identifier attributed to the data format
    /// </remarks>
    private static readonly byte[] dataFormatID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Format Name
    /// </summary>
    /// <remarks>
    /// A name attributed to the data format
    /// </remarks>
    private static readonly byte[] dataFormatName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Format Profile
    /// </summary>
    /// <remarks>
    /// To define a profile of a data format
    /// </remarks>
    private static readonly byte[] dataFormatProfile = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Format Profile Level
    /// </summary>
    /// <remarks>
    /// To define a level of a data format
    /// </remarks>
    private static readonly byte[] dataFormatProfileLevel = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x0E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Format Version ID
    /// </summary>
    /// <remarks>
    /// A version identifier attributed to the data format
    /// </remarks>
    private static readonly byte[] dataFormatVersionID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Hashing Algorithms
    /// </summary>
    /// <remarks>
    /// Information about data hashing algorithms
    /// </remarks>
    private static readonly byte[] DataHashingAlgorithms = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x02, 0x09, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Interpretations and Definitions
    /// </summary>
    /// <remarks>
    /// Defining information about data interpretation
    /// </remarks>
    private static readonly byte[] DataInterpretationsAndDefinitions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Note
    /// </summary>
    /// <remarks>
    /// A contextual information note
    /// </remarks>
    private static readonly byte[] dataNote = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x0F, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Offsets
    /// </summary>
    /// <remarks>
    /// Generic Data Offsets
    /// </remarks>
    private static readonly byte[] DataOffsets = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x09, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Presence Flag
    /// </summary>
    /// <remarks>
    /// A flag to indicate the presence of data
    /// </remarks>
    private static readonly byte[] dataPresenceFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Processor Settings
    /// </summary>
    /// <remarks>
    /// The settings of a specific device in the system
    /// </remarks>
    private static readonly byte[] DataProcessorSettings = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x20, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Relationships
    /// </summary>
    /// <remarks>
    /// Generic Relationships between data
    /// </remarks>
    private static readonly byte[] DataRelationships = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Stream ID
    /// </summary>
    /// <remarks>
    /// Unique identifier for this Data Stream
    /// </remarks>
    private static readonly byte[] DataStreamID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x01, 0x03, 0x04, 0x0B, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// SMPTE 337M Data Stream Number
    /// </summary>
    /// <remarks>
    /// The data_stream_number of the SMPTE 337M data stream being described.
    /// </remarks>
    private static readonly byte[] DataStreamNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x04, 0x02, 0x05, 0x01, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Stream Sample Rate
    /// </summary>
    /// <remarks>
    /// Rate at which creator samples data conveyed on the Data Stream, per second
    /// </remarks>
    private static readonly byte[] DataStreamSampleRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Stream Scheme URI
    /// </summary>
    /// <remarks>
    /// URI identifying application of Data Stream
    /// </remarks>
    private static readonly byte[] DataStreamSchemeURI = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x06, 0x10, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Technical Attribute AnyURI Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type AnyURI
    /// </remarks>
    private static readonly byte[] dataTechnicalAttributeAnyURIObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x1B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Technical Attribute Boolean Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Boolean
    /// </remarks>
    private static readonly byte[] dataTechnicalAttributeBooleanObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x1C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Technical Attribute Float Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Float
    /// </remarks>
    private static readonly byte[] dataTechnicalAttributeFloatObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x19, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Technical Attribute Int16 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int16
    /// </remarks>
    private static readonly byte[] dataTechnicalAttributeInt16Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x12, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Technical Attribute Int32 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int32
    /// </remarks>
    private static readonly byte[] dataTechnicalAttributeInt32Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x13, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Technical Attribute Int64 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int64
    /// </remarks>
    private static readonly byte[] dataTechnicalAttributeInt64Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x14, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Technical Attribute Int8 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int8
    /// </remarks>
    private static readonly byte[] dataTechnicalAttributeInt8Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x11, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Technical Attribute Rational Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Rational
    /// </remarks>
    private static readonly byte[] dataTechnicalAttributeRationalObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x1A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Technical Attribute String Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type string
    /// </remarks>
    private static readonly byte[] dataTechnicalAttributeStringObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Technical Attribute UInt16 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt16
    /// </remarks>
    private static readonly byte[] dataTechnicalAttributeUInt16Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x16, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Technical Attribute UInt32 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt32
    /// </remarks>
    private static readonly byte[] dataTechnicalAttributeUInt32Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x17, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Technical Attribute UInt64 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt64
    /// </remarks>
    private static readonly byte[] dataTechnicalAttributeUInt64Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x18, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Technical Attribute UInt8 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt8
    /// </remarks>
    private static readonly byte[] dataTechnicalAttributeUInt8Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x15, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Track ID
    /// </summary>
    /// <remarks>
    /// An identifier associated to the data track
    /// </remarks>
    private static readonly byte[] dataTrackId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Track Language Code
    /// </summary>
    /// <remarks>
    /// A language associated to the data track based on RFC 5646/BCP 47
    /// </remarks>
    private static readonly byte[] dataTrackLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Data Track Name
    /// </summary>
    /// <remarks>
    /// A name associated to the data track
    /// </remarks>
    private static readonly byte[] dataTrackName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Date
    /// </summary>
    /// <remarks>
    /// Definitions of key dates associated with a resource
    /// </remarks>
    private static readonly byte[] date = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0C, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Date Copyrighted
    /// </summary>
    /// <remarks>
    /// The date YYYY:MM:DD when the resource was copyrighted
    /// </remarks>
    private static readonly byte[] dateCopyrighted = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0C, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Date Created
    /// </summary>
    /// <remarks>
    /// The date YYYY:MM:DD when the resource was created
    /// </remarks>
    private static readonly byte[] dateCreated = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0C, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Date Digitized
    /// </summary>
    /// <remarks>
    /// The date YYYY:MM:DD when the resource was digitized
    /// </remarks>
    private static readonly byte[] dateDigitized = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0C, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Date Format Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute format group to specify the custom format of date being used
    /// </remarks>
    private static readonly byte[] dateFormatGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0D, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Date Issued
    /// </summary>
    /// <remarks>
    /// The date YYYY:MM:DD when the resource was issued
    /// </remarks>
    private static readonly byte[] dateIssued = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0C, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Date Modified
    /// </summary>
    /// <remarks>
    /// The date YYYY:MM:DD when the resource was modified
    /// </remarks>
    private static readonly byte[] dateModified = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0C, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Date Note
    /// </summary>
    /// <remarks>
    /// A note to provide additional contextual information
    /// </remarks>
    private static readonly byte[] dateNote = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0C, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Date Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to one or more dates
    /// </remarks>
    private static readonly byte[] dateObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x02, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Date Released
    /// </summary>
    /// <remarks>
    /// The date YYYY:MM:DD when the resource was released
    /// </remarks>
    private static readonly byte[] dateReleased = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0C, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Dates and Times
    /// </summary>
    /// <remarks>
    /// All information about dates and times
    /// </remarks>
    private static readonly byte[] DatesAndTimes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Date-Time Drop Frame Flag
    /// </summary>
    /// <remarks>
    /// TRUE if drop-frame is active
    /// </remarks>
    private static readonly byte[] DateTimeDropFrame = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x04, 0x01, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Date-Time Embedded Flag
    /// </summary>
    /// <remarks>
    /// TRUE if embedded in other data
    /// </remarks>
    private static readonly byte[] DateTimeEmbedded = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x04, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Date-Time Kind
    /// </summary>
    /// <remarks>
    /// Date/Time format kind (examples may include, but are not restricted to, SMPTE timecodes).
    /// </remarks>
    private static readonly byte[] DateTimeKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x04, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Date-Time Rate
    /// </summary>
    /// <remarks>
    /// Defines the Date/Time rate where this differs from the essence rate
    /// </remarks>
    private static readonly byte[] DateTimeRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x04, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Date Type
    /// </summary>
    /// <remarks>
    /// Definition of a generic date type for the definition of custom dates
    /// </remarks>
    private static readonly byte[] dateType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0D, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Date Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group to specify the custom type of date being used
    /// </remarks>
    private static readonly byte[] dateTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0D, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Date Value
    /// </summary>
    /// <remarks>
    /// A date YYYY:MM:DD
    /// </remarks>
    private static readonly byte[] dateValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0D, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Death Date
    /// </summary>
    /// <remarks>
    /// The death date of a contact/person
    /// </remarks>
    private static readonly byte[] deathDate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x22, 0x12, 0x00, 0x00, 0x00];
    /// <summary>
    /// Death Place
    /// </summary>
    /// <remarks>
    /// To specify the place of death.
    /// </remarks>
    private static readonly byte[] deathPlace = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x22, 0x18, 0x00, 0x00, 0x00];
    /// <summary>
    /// Declassification Date
    /// </summary>
    /// <remarks>
    /// Date for automatic declassification or the code indicating exemption from automatic declassification
    /// </remarks>
    private static readonly byte[] Declassification = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x08, 0x02, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Decoding Delay
    /// </summary>
    /// <remarks>
    /// Information about delay durations in decoding processes
    /// </remarks>
    private static readonly byte[] DecodingDelay = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x03, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Default Data Value
    /// </summary>
    /// <remarks>
    /// Specifies the default value of a property or metadata element as defined by the Type definitions
    /// </remarks>
    private static readonly byte[] DefaultDataValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x02, 0x02, 0x03, 0x02, 0x00, 0x00];
    /// <summary>
    /// Default Fade Edit Rate
    /// </summary>
    /// <remarks>
    /// Specifies the default time base for fade edit event units in hertz.
    /// </remarks>
    private static readonly byte[] DefaultFadeEditUnit = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x30, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Default Fade Duration
    /// </summary>
    /// <remarks>
    /// Specifies the default length of an audio fade-in or fade-out to be applied, in units of edit rate
    /// </remarks>
    private static readonly byte[] DefaultFadeLength = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x07, 0x02, 0x02, 0x01, 0x01, 0x05, 0x01, 0x00];
    /// <summary>
    /// Default Fade Type
    /// </summary>
    /// <remarks>
    /// Specifies the default fade type for audio soft cuts
    /// </remarks>
    private static readonly byte[] DefaultFadeType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x30, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Default Namespace URI
    /// </summary>
    /// <remarks>
    /// The Uniform Resource Identifier (URI) of the default namespace for an XML document
    /// </remarks>
    private static readonly byte[] DefaultNamespaceURI = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x01, 0x02, 0x01, 0x04, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Default Namespace URI
    /// </summary>
    /// <remarks>
    /// The Uniform Resource Identifier (URI) of the default namespace for an XML document
    /// </remarks>
    private static readonly byte[] DefaultNamespaceURI_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x01, 0x02, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Defined Event Start True Date-Time
    /// </summary>
    /// <remarks>
    /// The absolute beginning date and time of a defined event
    /// </remarks>
    private static readonly byte[] DefinedEventStartTrueDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x07, 0x02, 0x01, 0x02, 0x07, 0x10, 0x00, 0x00];
    /// <summary>
    /// Defined Name
    /// </summary>
    /// <remarks>
    /// Name of item being defined
    /// </remarks>
    private static readonly byte[] DefinedName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x07, 0x01, 0x04, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Defined Name
    /// </summary>
    /// <remarks>
    /// Name of item being defined
    /// </remarks>
    private static readonly byte[] DefinedName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x07, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Object Description
    /// </summary>
    /// <remarks>
    /// Provides human informative description about the object
    /// </remarks>
    private static readonly byte[] DefinitionObjectDescription = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x03, 0x01, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Definition Object ID
    /// </summary>
    /// <remarks>
    /// The unique identifier for the item being defined
    /// </remarks>
    private static readonly byte[] DefinitionObjectIdentification = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x15, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Definition Object Name
    /// </summary>
    /// <remarks>
    /// Name of item being defined
    /// </remarks>
    private static readonly byte[] DefinitionObjectName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x07, 0x01, 0x02, 0x03, 0x01, 0x00, 0x00];
    /// <summary>
    /// Definition Object Name
    /// </summary>
    /// <remarks>
    /// Name of item being defined
    /// </remarks>
    private static readonly byte[] DefinitionObjectName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x07, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Degraded Effects
    /// </summary>
    /// <remarks>
    /// Specifies a vector of references to the effect definitions that may be substituted if the specified effect is not available
    /// </remarks>
    private static readonly byte[] DegradeTo = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x04, 0x01, 0x00, 0x00];
    /// <summary>
    /// Delay
    /// </summary>
    /// <remarks>
    /// Information about Delay durations
    /// </remarks>
    private static readonly byte[] Delay = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Delivery Code
    /// </summary>
    /// <remarks>
    /// A delivery / postal code
    /// </remarks>
    private static readonly byte[] deliveryCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x26, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Delta Entry Array
    /// </summary>
    /// <remarks>
    /// Array of values used to identify elements of Essence within an edit unit
    /// </remarks>
    private static readonly byte[] DeltaEntryArray = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x04, 0x04, 0x01, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Department
    /// </summary>
    /// <remarks>
    /// A set of attributes to describe a department within an organization
    /// </remarks>
    private static readonly byte[] department = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x24, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Department ID
    /// </summary>
    /// <remarks>
    /// An identifier attributed to a department
    /// </remarks>
    private static readonly byte[] departmentID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x24, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Department Name
    /// </summary>
    /// <remarks>
    /// The name of department within an organization
    /// </remarks>
    private static readonly byte[] departmentName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x24, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Derived From
    /// </summary>
    /// <remarks>
    /// Narrative text indicating the source document or authority for derivative declassification
    /// </remarks>
    private static readonly byte[] DerivedFrom_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x08, 0x02, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Derived Summary Information
    /// </summary>
    /// <remarks>
    /// Summary Information derived from other Metadata
    /// </remarks>
    private static readonly byte[] DerivedSummaryInformation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Described Track IDs
    /// </summary>
    /// <remarks>
    /// Specifies an unordered list of track ID values that identify the tracks which are described
    /// </remarks>
    private static readonly byte[] DescribedTrackIDs = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x01, 0x07, 0x01, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Description
    /// </summary>
    /// <remarks>
    /// A freeform textual descrition
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] Description_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x01, 0x06, 0x03, 0x01, 0x00, 0x00];
    /// <summary>
    /// Description
    /// </summary>
    /// <remarks>
    /// A description of the resource
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] Description_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x09, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Description
    /// </summary>
    /// <remarks>
    /// A freeform textual descrition
    /// </remarks>
    private static readonly byte[] Description_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x01, 0x06, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// DescriptionAttributionDate
    /// </summary>
    /// <remarks>
    /// The date when the description was attributed to the resource
    /// </remarks>
    private static readonly byte[] descriptionAttributionDate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x09, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// DescriptionAttributorEntity Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an entity object to specify the authority attributing the description
    /// </remarks>
    private static readonly byte[] descriptionAttributorEntityObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x09, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// DescriptionCastFlag
    /// </summary>
    /// <remarks>
    /// A flag to indicate if the description contains information about the cast or crew
    /// </remarks>
    private static readonly byte[] descriptionCastFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x09, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// DescriptionGeographicalExclusionScope
    /// </summary>
    /// <remarks>
    /// The geographical scope within which the description does not apply
    /// </remarks>
    private static readonly byte[] descriptionGeographicalExclusionScope = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x09, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// DescriptionGeographicalScope
    /// </summary>
    /// <remarks>
    /// The geographical scope within which the description applies
    /// </remarks>
    private static readonly byte[] descriptionGeographicalScope = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x09, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Description Kind
    /// </summary>
    /// <remarks>
    /// The name of a descriptive comment or note.  Eg. Peters comment, Noise
    /// </remarks>
    private static readonly byte[] DescriptionKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x03, 0x02, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Description Kind
    /// </summary>
    /// <remarks>
    /// The name of a descriptive comment or note.  Eg. Peters comment, Noise
    /// </remarks>
    private static readonly byte[] DescriptionKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x03, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// DescriptionLength
    /// </summary>
    /// <remarks>
    /// The length of the description
    /// </remarks>
    private static readonly byte[] descriptionLength = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x09, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Description Note
    /// </summary>
    /// <remarks>
    /// A note to provide additional contextual information
    /// </remarks>
    private static readonly byte[] descriptionNote = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x09, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Description Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to one or more descriptions
    /// </remarks>
    private static readonly byte[] descriptionObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x02, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Description Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group defining the type of description (e.g. "summary"
    /// </remarks>
    private static readonly byte[] descriptionTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x09, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Description Value Sets
    /// </summary>
    /// <remarks>
    /// The description text optionally in different languages
    /// </remarks>
    private static readonly byte[] descriptionValueObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x09, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Descriptive Clip Described Track IDs
    /// </summary>
    /// <remarks>
    /// Specifies an unordered list of track ID values that identify the tracks which are described
    /// </remarks>
    private static readonly byte[] DescriptiveClipDescribedTrackIDs = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x07, 0x01, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Descriptive Comment
    /// </summary>
    /// <remarks>
    /// The comment or note as text.  E.g.  Head banding,
    /// </remarks>
    private static readonly byte[] DescriptiveComment = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x03, 0x02, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Descriptive Comment
    /// </summary>
    /// <remarks>
    /// The comment or note as text.  E.g.  Head banding,
    /// </remarks>
    private static readonly byte[] DescriptiveComment_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x03, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Descriptive Metadata Framework
    /// </summary>
    /// <remarks>
    /// Strong Reference to the Descriptive Metadata Framework
    /// </remarks>
    private static readonly byte[] DescriptiveFrameworkObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x02, 0x0C, 0x00, 0x00];
    /// <summary>
    /// Descriptive Metadata Application Environment ID
    /// </summary>
    /// <remarks>
    /// Identifies the application to which the information in this DM plug-in applies
    /// </remarks>
    private static readonly byte[] DescriptiveMetadataApplicationEnvironmentID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x05, 0x20, 0x07, 0x01, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// Descriptive Metadata Plug-In ID
    /// </summary>
    /// <remarks>
    /// UUID of this DM Plug-in instance
    /// </remarks>
    private static readonly byte[] DescriptiveMetadataPlugInID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x05, 0x20, 0x07, 0x01, 0x0E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Descriptive Metadata Scheme
    /// </summary>
    /// <remarks>
    /// The Universal Label of the Descriptive Metadata scheme that is referenced by the DM Framework property
    /// </remarks>
    private static readonly byte[] DescriptiveMetadataScheme = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x04, 0x06, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Descriptive Metadata Set References
    /// </summary>
    /// <remarks>
    /// Specifies ordered weak references to descriptive metadata sets
    /// </remarks>
    private static readonly byte[] DescriptiveMetadataSetReferences = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x01, 0x01, 0x04, 0x04, 0x02, 0x00, 0x00];
    /// <summary>
    /// Descriptive Metadata Sets
    /// </summary>
    /// <remarks>
    /// Specifies unordered references to descriptive metadata sets
    /// </remarks>
    private static readonly byte[] DescriptiveMetadataSets = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x01, 0x01, 0x04, 0x03, 0x03, 0x00, 0x00];
    /// <summary>
    /// Descriptive Names
    /// </summary>
    /// <remarks>
    /// Assigned descriptive names
    /// </remarks>
    private static readonly byte[] DescriptiveNames = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Descriptive Metadata Schemes
    /// </summary>
    /// <remarks>
    /// An unordered batch of 'n' Universal Labels of all the Descriptive Metadata schemes used in this file
    /// </remarks>
    private static readonly byte[] DescriptiveSchemes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x02, 0x02, 0x10, 0x02, 0x02, 0x00, 0x00];
    /// <summary>
    /// Details
    /// </summary>
    /// <remarks>
    /// A set of attributes to provide the details of a Contact / Person
    /// </remarks>
    private static readonly byte[] details = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x25, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Details Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group  to specify the type of details e.g. home or office
    /// </remarks>
    private static readonly byte[] detailsTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x25, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Device Absolute Heading
    /// </summary>
    /// <remarks>
    /// Defined by the absolute heading of the sensor.  Expressed in degrees and tenths of degrees.
    /// </remarks>
    private static readonly byte[] DeviceAbsoluteHeading = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x03, 0x01, 0x01, 0x02, 0x00, 0x00];
    /// <summary>
    /// Device Absolute Position
    /// </summary>
    /// <remarks>
    /// The absolute position of the essence-capturing device
    /// </remarks>
    private static readonly byte[] DeviceAbsolutePosition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Device Absolute Positional Accuracy
    /// </summary>
    /// <remarks>
    /// Accuracy of frame center coordinates as a Circular Error Probable (CEP) (50%), (default metres)
    /// </remarks>
    private static readonly byte[] DeviceAbsolutePositionalAccuracy = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x01, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Device Absolute Speed
    /// </summary>
    /// <remarks>
    /// Defined by the relative speed of the sensor along the heading. Expressed in metres/second .  Speed values shall indicate translations in which the capturing device has physically moved.
    /// </remarks>
    private static readonly byte[] DeviceAbsoluteSpeed = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x03, 0x01, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Device Altitude
    /// </summary>
    /// <remarks>
    /// Altitude of sensor as measured from Mean Sea Level (MSL),  (default metres)
    /// </remarks>
    private static readonly byte[] DeviceAltitude = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x01, 0x02, 0x02, 0x00, 0x00];
    /// <summary>
    /// Device Altitude (Concise)
    /// </summary>
    /// <remarks>
    /// Altitude of sensor as measured from Mean Sea Level (MSL),  (default metres)
    /// </remarks>
    private static readonly byte[] DeviceAltitudeConcise = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x01, 0x02, 0x02, 0x01, 0x00];
    /// <summary>
    /// Device Angles
    /// </summary>
    /// <remarks>
    /// Device information regarding angles related to positioning information
    /// </remarks>
    private static readonly byte[] DeviceAngles = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Device Asset Number
    /// </summary>
    /// <remarks>
    /// Defines the asset number of the device used in capturing or generating the content
    /// </remarks>
    private static readonly byte[] DeviceAssetNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x01, 0x20, 0x0C, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Device Characteristics
    /// </summary>
    /// <remarks>
    /// Information about the devices used
    /// </remarks>
    private static readonly byte[] DeviceCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Device Comments and Descriptions
    /// </summary>
    /// <remarks>
    /// Technical comments or descriptions relating to devices
    /// </remarks>
    private static readonly byte[] DeviceCommentsAndDescriptions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x03, 0x03, 0x10, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Device Creator Name
    /// </summary>
    /// <remarks>
    /// Name of creator of device creating a Data Stream
    /// </remarks>
    private static readonly byte[] DeviceCreatorName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x01, 0x02, 0x06, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Descriptive Comment for a Device
    /// </summary>
    /// <remarks>
    /// Technical comments and descriptions of a general nature for a device
    /// </remarks>
    private static readonly byte[] DeviceDescriptiveComments = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x03, 0x02, 0x03, 0x02, 0x02, 0x10, 0x00, 0x00];
    /// <summary>
    /// Device Designation
    /// </summary>
    /// <remarks>
    /// Identifies the "house name" of the device used in capturing or generating the essence
    /// </remarks>
    private static readonly byte[] DeviceDesignation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Device Dimensions
    /// </summary>
    /// <remarks>
    /// Physical measurements relating to the size of the device used for the captured essence
    /// </remarks>
    private static readonly byte[] DeviceDimensions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x09, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Device Identifiers
    /// </summary>
    /// <remarks>
    /// Unique identifiers for any device used in program production, such as cameras, microphones, editing, color grading, etc
    /// </remarks>
    private static readonly byte[] DeviceIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Device ID Kind
    /// </summary>
    /// <remarks>
    /// The type of identifier used to identify the device
    /// </remarks>
    private static readonly byte[] DeviceIDKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x20, 0x07, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Device Instance Identifier
    /// </summary>
    /// <remarks>
    /// Unambiguous identifier for device creating a Data Stream, in the context of the application
    /// </remarks>
    private static readonly byte[] DeviceInstanceIdentifier = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x01, 0x02, 0x06, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Device Kind
    /// </summary>
    /// <remarks>
    /// Defines the kind of device used to capture or create the content (as either a commonly known name or as a locally defined name, e.g. Radio-camera)
    /// </remarks>
    private static readonly byte[] DeviceKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x01, 0x20, 0x08, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Device Kind
    /// </summary>
    /// <remarks>
    /// Device Type expressed as a common name - e.g. camera, audio tape recorder, RAM, Hard disk etc
    /// </remarks>
    private static readonly byte[] DeviceKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Device Kind Code
    /// </summary>
    /// <remarks>
    /// Device Type expressed as a code
    /// </remarks>
    private static readonly byte[] DeviceKindCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x20, 0x08, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Device Latitude
    /// </summary>
    /// <remarks>
    /// Specifies a sensor's geographic location in decimal degrees of latitude.
    /// </remarks>
    private static readonly byte[] DeviceLatitude = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x02, 0x01, 0x02, 0x04, 0x02, 0x00];
    /// <summary>
    /// Device Latitude
    /// </summary>
    /// <remarks>
    /// Specifies a sensor's geographic location in decimal degrees of latitude.  Positive values indicate northern hemisphere; negative values indicate southern hemisphere.
    /// </remarks>
    private static readonly byte[] DeviceLatitude_Float = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x01, 0x02, 0x04, 0x00, 0x00];
    /// <summary>
    /// Device Latitude (Degrees, Concise)
    /// </summary>
    /// <remarks>
    /// Specifies a sensor's geographic location in decimal degrees of latitude.  Positive values indicate northern hemisphere; negative values indicate southern hemisphere.
    /// </remarks>
    private static readonly byte[] DeviceLatitudeDegreesConcise = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x01, 0x02, 0x04, 0x01, 0x00];
    /// <summary>
    /// Device Longitude
    /// </summary>
    /// <remarks>
    /// Specifies a sensor's geographic location in decimal degrees of longitude.
    /// </remarks>
    private static readonly byte[] DeviceLongitude = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x02, 0x01, 0x02, 0x06, 0x02, 0x00];
    /// <summary>
    /// Device Longitude
    /// </summary>
    /// <remarks>
    /// Specifies a sensor's geographic location in decimal degrees of longitude.  Positive values indicate eastern hemisphere, negative values indicate western hemisphere.
    /// </remarks>
    private static readonly byte[] DeviceLongitude_Float = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x01, 0x02, 0x06, 0x00, 0x00];
    /// <summary>
    /// Device Longitude (Degrees, Concise)
    /// </summary>
    /// <remarks>
    /// Specifies a sensor's geographic location in decimal degrees of longitude.  Positive values indicate eastern hemisphere, negative values indicate western hemisphere.
    /// </remarks>
    private static readonly byte[] DeviceLongitudeDegreesConcise = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x01, 0x02, 0x06, 0x01, 0x00];
    /// <summary>
    /// Device Manufacturer Name
    /// </summary>
    /// <remarks>
    /// The manufacturer or maker of the device
    /// </remarks>
    private static readonly byte[] DeviceManufacturerName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x0A, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Device Manufacturer Name
    /// </summary>
    /// <remarks>
    /// The manufacturer or maker of the device
    /// </remarks>
    private static readonly byte[] DeviceManufacturerName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x0A, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Device Model
    /// </summary>
    /// <remarks>
    /// Identifies the device model used in capturing or generating the essence.
    /// </remarks>
    private static readonly byte[] DeviceModel = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x20, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Device Parameter Name-Value Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Name-Value sets
    /// </remarks>
    private static readonly byte[] DeviceParametersNameValueObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x1F, 0x03];
    /// <summary>
    /// Device Parameters Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Device Parameters sets
    /// </remarks>
    private static readonly byte[] DeviceParametersObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x1E, 0x00];
    /// <summary>
    /// Device Product Name
    /// </summary>
    /// <remarks>
    /// Name identifying product creating a Data Stream
    /// </remarks>
    private static readonly byte[] DeviceProductName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x01, 0x02, 0x06, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Device Rate and Direction of Positional Change
    /// </summary>
    /// <remarks>
    /// Information about the absolute rate and direction of positional change of the capturing device
    /// </remarks>
    private static readonly byte[] DeviceRateAndDirectionOfPositionalChange = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Device Relative Heading
    /// </summary>
    /// <remarks>
    /// Defined by the relative heading of the sensor.  Expressed in degrees and tenths of degrees.
    /// </remarks>
    private static readonly byte[] DeviceRelativeHeading = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x03, 0x02, 0x01, 0x02, 0x00, 0x00];
    /// <summary>
    /// Device Relative Position
    /// </summary>
    /// <remarks>
    /// The relative position of the essence-capturing device
    /// </remarks>
    private static readonly byte[] DeviceRelativePosition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Device Relative Positional Accuracy
    /// </summary>
    /// <remarks>
    /// Accuracy of frame center coordinates
    /// </remarks>
    private static readonly byte[] DeviceRelativePositionalAccuracy = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x02, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Device Relative Position X
    /// </summary>
    /// <remarks>
    /// Defined by the X translational position of the camera from a local Datum Absolute Position.  Positive values indicate translations in which the camera has physically moved from left to right,  (default metres)
    /// </remarks>
    private static readonly byte[] DeviceRelativePositionX = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00];
    /// <summary>
    /// Device Relative Position Y
    /// </summary>
    /// <remarks>
    /// Defined by the Y translational position of the camera from a local Datum Absolute Position.  Positive values indicate translations in which the camera has physically moved to a higher elevation,  (default metres)
    /// </remarks>
    private static readonly byte[] DeviceRelativePositionY = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x02, 0x02, 0x03, 0x00, 0x00];
    /// <summary>
    /// Device Relative Position Z
    /// </summary>
    /// <remarks>
    /// Defined by the Z translational position of the camera from a local Datum Absolute Position.  Positive values shall indicate translations in which the camera has physically moved towards the target,  (default metres)
    /// </remarks>
    private static readonly byte[] DeviceRelativePositionZ = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x02, 0x02, 0x04, 0x00, 0x00];
    /// <summary>
    /// Device Relative Rate and Direction of Positional Change
    /// </summary>
    /// <remarks>
    /// Information about relative rate and direction of positional change of the capturing device
    /// </remarks>
    private static readonly byte[] DeviceRelativeRateAndDirectionOfPositionalChange = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x03, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Device Relative Speed
    /// </summary>
    /// <remarks>
    /// Defined by the relative speed of the sensor along the heading.  Speed values shall indicate translations in which the camera has physically moved, (default metres/second)
    /// </remarks>
    private static readonly byte[] DeviceRelativeSpeed = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x03, 0x02, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Device Serial Number
    /// </summary>
    /// <remarks>
    /// Alphanumeric serial number identifying the individual device
    /// </remarks>
    private static readonly byte[] DeviceSerialNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x20, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Device to Subject Distance
    /// </summary>
    /// <remarks>
    /// Length measurements relating to distance between capturing device and the subject depicted in the captured essence
    /// </remarks>
    private static readonly byte[] DeviceToSubjectDistance = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Device Usage Description
    /// </summary>
    /// <remarks>
    /// Freeform textual description of the function or use of the device in the production of a specific content item
    /// </remarks>
    private static readonly byte[] DeviceUsageDescription = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x03, 0x03, 0x10, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Device Usage Description
    /// </summary>
    /// <remarks>
    /// Freeform textual description of the function or use of the device in the production of a specific content item
    /// </remarks>
    private static readonly byte[] DeviceUsageDescription_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x03, 0x03, 0x10, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Device Version
    /// </summary>
    /// <remarks>
    /// Version identifier for device creating a Data Stream
    /// </remarks>
    private static readonly byte[] DeviceVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x01, 0x02, 0x06, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Device X Dimension
    /// </summary>
    /// <remarks>
    /// Specifies the sensor location along the x-axis in Earth Centered, Earth Fixed (ECEF) Cartesian coordinates,  (default metres)
    /// </remarks>
    private static readonly byte[] DeviceXDimension = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x01, 0x02, 0x10, 0x00, 0x00];
    /// <summary>
    /// Device Y Dimension
    /// </summary>
    /// <remarks>
    /// Specifies the sensor location along the y-axis in Earth Centered, Earth Fixed (ECEF) Cartesian coordinates,  (default metres)
    /// </remarks>
    private static readonly byte[] DeviceYDimension = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x01, 0x02, 0x11, 0x00, 0x00];
    /// <summary>
    /// Dial Norm
    /// </summary>
    /// <remarks>
    /// Gain to be applied to normalise perceived loudness of the clip
    /// </remarks>
    private static readonly byte[] DialNorm = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Dialogue Content Kind
    /// </summary>
    /// <remarks>
    /// Numerical ID for the kind of dialogue content: 0 - undefined, 1 - (storyline) dialogue, 2 - voiceover, 3 - spoken subtitle, 4 - audio description/visually impaired, 5 - commentary, 6 - emergency
    /// </remarks>
    private static readonly byte[] dialogueContentKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x63, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Dialogue Loudness
    /// </summary>
    /// <remarks>
    /// Dialogue loudness.
    /// </remarks>
    private static readonly byte[] dialogueLoudness = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4C, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Dictionary
    /// </summary>
    /// <remarks>
    /// Specifies a reference to the Dictionary of Definitions Used in Container
    /// </remarks>
    private static readonly byte[] Dictionary = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x02, 0x02, 0x00, 0x00];
    /// <summary>
    /// Dictionary Description
    /// </summary>
    /// <remarks>
    /// Specifies a readable description of a dictionary definition
    /// </remarks>
    private static readonly byte[] DictionaryDescription_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x07, 0x14, 0x00, 0x00, 0x00];
    /// <summary>
    /// DID
    /// </summary>
    /// <remarks>
    /// Data Identifier
    /// </remarks>
    private static readonly byte[] DID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x38, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Digital Audio Coding Parameters
    /// </summary>
    /// <remarks>
    /// Information about the essence digital coding
    /// </remarks>
    private static readonly byte[] DigitalAudioCodingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Digital Audio Compression Parameters
    /// </summary>
    /// <remarks>
    /// Information about the digital audio compression scheme used (MPEG, Dolby etc)
    /// </remarks>
    private static readonly byte[] DigitalAudioCompressionParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Digital Audio Processing Parameters
    /// </summary>
    /// <remarks>
    /// Parameters required for processing
    /// </remarks>
    private static readonly byte[] DigitalAudioProcessingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Digital Audio Quantization and Level Parameters
    /// </summary>
    /// <remarks>
    /// Information about the digital quantisation and levels
    /// </remarks>
    private static readonly byte[] DigitalAudioQuantizationAndLevelParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Digital Audio Storage Parameters
    /// </summary>
    /// <remarks>
    /// Information about audio storage parameters.
    /// </remarks>
    private static readonly byte[] DigitalAudioStorageParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Digital Cinema Encryption
    /// </summary>
    /// <remarks>
    /// Content encryption/decryption information for Digital Cinema
    /// </remarks>
    private static readonly byte[] DigitalCinemaEncryption = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x02, 0x09, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Digital Cinema Encryption Algorithms
    /// </summary>
    /// <remarks>
    /// Information about encryption algorithms for Digital Cinema
    /// </remarks>
    private static readonly byte[] DigitalCinemaEncryptionAlgorithms = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x02, 0x09, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Digital Cinema Hashing Algorithms
    /// </summary>
    /// <remarks>
    /// Information about content hashing algorithms for Digital Cinema
    /// </remarks>
    private static readonly byte[] DigitalCinemaHashingAlgorithms = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x02, 0x09, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Digital Data Essence Coding Parameters
    /// </summary>
    /// <remarks>
    /// Information about the data essence digital coding
    /// </remarks>
    private static readonly byte[] DigitalDataEssenceCodingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Digital Encoding Bit Rate
    /// </summary>
    /// <remarks>
    /// The encoded bit rate of the subject digital video bitstream or file in Megabits per second
    /// </remarks>
    private static readonly byte[] DigitalEncodingBitRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Digital Metadata Carrier
    /// </summary>
    /// <remarks>
    /// The metadata coding type - eg.  Digital VBI,  AES-3
    /// </remarks>
    private static readonly byte[] DigitalMetadataCarrier_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Digital Metadata Coding Characteristics
    /// </summary>
    /// <remarks>
    /// Information about the metadata digital coding
    /// </remarks>
    private static readonly byte[] DigitalMetadataCodingCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Digital Monitoring and Control Coding Parameters
    /// </summary>
    /// <remarks>
    /// Information about the original digital coding of the data
    /// </remarks>
    private static readonly byte[] DigitalMonitoringAndControlCodingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Digital Monitoring and Control Sampling Parameters
    /// </summary>
    /// <remarks>
    /// Information about the Monitoring and Control metadata digital sampling
    /// </remarks>
    private static readonly byte[] DigitalMonitoringAndControlSamplingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x05, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Digital or Analog Origination
    /// </summary>
    /// <remarks>
    /// The nature of the first capture of the material
    /// </remarks>
    private static readonly byte[] DigitalOrAnalogOrigination_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Digital Quantization and Level Parameters
    /// </summary>
    /// <remarks>
    /// Inflormation about the digital quantisation and levels
    /// </remarks>
    private static readonly byte[] DigitalQuantizationAndLevelParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Digital Sampling Parameters
    /// </summary>
    /// <remarks>
    /// Information about the digital sampling
    /// </remarks>
    private static readonly byte[] DigitalSamplingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Digital Video and Image Coding Parameters
    /// </summary>
    /// <remarks>
    /// Information about the essence digital coding
    /// </remarks>
    private static readonly byte[] DigitalVideoAndImageCodingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Digital Video and Image Compression Parameters
    /// </summary>
    /// <remarks>
    /// Information about the digital video compression scheme used (MPEG, DV etc)
    /// </remarks>
    private static readonly byte[] DigitalVideoAndImageCompressionParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Digital Video and Image Sampling Parameters
    /// </summary>
    /// <remarks>
    /// Inflormation about the digital sampling
    /// </remarks>
    private static readonly byte[] DigitalVideoAndImageSamplingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Digital Video and Image Signal Type Identifiers
    /// </summary>
    /// <remarks>
    /// Identifiers of the specific standard to which a  video signal conforms
    /// </remarks>
    private static readonly byte[] DigitalVideoAndImageSignalTypeIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x01, 0x05, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Digital Video and Image Storage Parameters
    /// </summary>
    /// <remarks>
    /// Information about image storage parameters.
    /// </remarks>
    private static readonly byte[] DigitalVideoAndImageStorageParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Digital Video File Format
    /// </summary>
    /// <remarks>
    /// The  format of the subject digital video bitstream or file
    /// </remarks>
    private static readonly byte[] DigitalVideoFileFormat_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x01, 0x0B, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Dimension
    /// </summary>
    /// <remarks>
    /// A set of attributes to define a dimension
    /// </remarks>
    private static readonly byte[] dimension = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3B, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Dimensions
    /// </summary>
    /// <remarks>
    /// Length measurements relating to size
    /// </remarks>
    private static readonly byte[] Dimensions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Dimension Unit
    /// </summary>
    /// <remarks>
    /// The unit in which the dimension is expressed
    /// </remarks>
    private static readonly byte[] dimensionUnit = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3B, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Dimension Value
    /// </summary>
    /// <remarks>
    /// The value of the dimension as contextually defined
    /// </remarks>
    private static readonly byte[] dimensionValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3B, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Director Name
    /// </summary>
    /// <remarks>
    /// Contains the name of the director of the program
    /// </remarks>
    private static readonly byte[] DirectorName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x0A, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Disclaimer Sets
    /// </summary>
    /// <remarks>
    /// A batch of references to a textual annotation to express disclaimers
    /// </remarks>
    private static readonly byte[] disclaimerObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x19, 0x0F, 0x00, 0x00, 0x00];
    /// <summary>
    /// Disc Medium Fundamental Parameters
    /// </summary>
    /// <remarks>
    /// Fundamental characteristics of Disc medium
    /// </remarks>
    private static readonly byte[] DiscMediumFundamentalParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x10, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Disc Medium Parameters
    /// </summary>
    /// <remarks>
    /// Characteristics of Disc medium
    /// </remarks>
    private static readonly byte[] DiscMediumParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x10, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Disc Partition Capacity
    /// </summary>
    /// <remarks>
    /// The capacity of the disc partition in terms of the maximum number of Megabytes which can be stored.
    /// </remarks>
    private static readonly byte[] DiscPartitionCapacity = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x10, 0x01, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Disk Identifiers
    /// </summary>
    /// <remarks>
    /// Disk identifier information
    /// </remarks>
    private static readonly byte[] DiskIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x03, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Display Characteristics
    /// </summary>
    /// <remarks>
    /// Information about display devices
    /// </remarks>
    private static readonly byte[] DisplayCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Display F2 Offset
    /// </summary>
    /// <remarks>
    /// Topness Adjustment for displayed picture
    /// </remarks>
    private static readonly byte[] DisplayF2Offset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x01, 0x03, 0x02, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Display Height
    /// </summary>
    /// <remarks>
    /// Specifies the height of the presented image relative to the sampled image in pixels
    /// </remarks>
    private static readonly byte[] DisplayHeight = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x01, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Display Type
    /// </summary>
    /// <remarks>
    /// A text string giving an application specific means to indicate the intended use of the content of the XML document.
    /// </remarks>
    private static readonly byte[] DisplayType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x06, 0x01, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Display Units
    /// </summary>
    /// <remarks>
    /// Specifies the displayable name of the units of a parameter
    /// </remarks>
    private static readonly byte[] DisplayUnits_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x30, 0x05, 0x0B, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Display Width
    /// </summary>
    /// <remarks>
    /// Specifies the width of the presented image in pixels
    /// </remarks>
    private static readonly byte[] DisplayWidth = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x01, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Display X-Offset
    /// </summary>
    /// <remarks>
    /// Specifies the X offset of the presented image relative to the sampled image in pixels
    /// </remarks>
    private static readonly byte[] DisplayXOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x01, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Display Y-Offset
    /// </summary>
    /// <remarks>
    /// Specifies the Y offset of the presented image relative to the sampled image in pixels
    /// </remarks>
    private static readonly byte[] DisplayYOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x01, 0x0E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Distance Measurements
    /// </summary>
    /// <remarks>
    /// Length measurements relating to distance
    /// </remarks>
    private static readonly byte[] DistanceMeasurements = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Distribution MaxRGB Percentages
    /// </summary>
    /// <remarks>
    /// First vector of DistributionMaxRGB with Integer percentage values
    /// </remarks>
    private static readonly byte[] DistributionMaxRGBPercentages = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x3C, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Distribution MaxRGB Percentiles
    /// </summary>
    /// <remarks>
    /// Second vector of DistributionMaxRGB with Linearized maxRGB value at given percentile
    /// </remarks>
    private static readonly byte[] DistributionMaxRGBPercentiles = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x3D, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Dither
    /// </summary>
    /// <remarks>
    /// rectangular, triangular PD
    /// </remarks>
    private static readonly byte[] Dither_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// AS-11 Core
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] DM_AS_11_Core = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0B, 0x01, 0x00, 0x00];
    /// <summary>
    /// AS-11 Core Framework
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] DM_AS_11_Core_Framework = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0B, 0x01, 0x01, 0x00];
    /// <summary>
    /// AS-11 Segmentation
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] DM_AS_11_Segmentation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0B, 0x02, 0x00, 0x00];
    /// <summary>
    /// AS-11 Segmentation Framework
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] DM_AS_11_Segmentation_Framework = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0B, 0x02, 0x01, 0x00];
    /// <summary>
    /// AS-11 UKDPP
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] DM_AS_11_UKDPP = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// AS-11 UKDPP Framework
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] DM_AS_11_UKDPP_Framework = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// DMCVT Application Identifier
    /// </summary>
    /// <remarks>
    /// Identifying an application and its defining document in the SMPTE ST 2094 suite
    /// </remarks>
    private static readonly byte[] DMCVTApplicationIdentifier = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// DMCVT Application Version Number
    /// </summary>
    /// <remarks>
    /// The Application Version of the identified SMPTE ST 2094 application
    /// </remarks>
    private static readonly byte[] DMCVTApplicationVersionNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// DMCVT Backwards Version
    /// </summary>
    /// <remarks>
    /// The lowest Application Version for which this metadata set is valid
    /// </remarks>
    private static readonly byte[] DMCVTBackwardsVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// DMCVT Essence Items
    /// </summary>
    /// <remarks>
    /// DMCVT Essence Items
    /// </remarks>
    private static readonly byte[] DMCVTEssenceItems = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// DMCVT Rows In Targeted System Display Actual Peak Luminance
    /// </summary>
    /// <remarks>
    /// Number of rows (M) in the DMCVT Targeted System Display Actual Peak Luminance array
    /// </remarks>
    private static readonly byte[] DMCVTRowsInTargetedSystemDisplayActualPeakLuminance = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x02, 0x37, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// DMCVT SubDescriptor Items
    /// </summary>
    /// <remarks>
    /// DMCVT SubDescriptor Items
    /// </remarks>
    private static readonly byte[] DMCVTSubDescriptorItems = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// DMCVT Targeted System Display Actual Peak Luminance
    /// </summary>
    /// <remarks>
    /// Two-input sampled function representing the normalized actual peak luminance of the targeted system display, in units of 1/15. The four most significant bits in each UInt8 are zero.
    /// </remarks>
    private static readonly byte[] DMCVTTargetedSystemDisplayActualPeakLuminance = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x02, 0x36, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// DMCVT Targeted System Display Maximum Luminance
    /// </summary>
    /// <remarks>
    /// Maximum luminance of the targeted system's display
    /// </remarks>
    private static readonly byte[] DMCVTTargetedSystemDisplayMaximumLuminance = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x02, 0x0B, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// DMCVT Targeted System Display Minimum Luminance
    /// </summary>
    /// <remarks>
    /// Minimum luminance of the targeted system's display
    /// </remarks>
    private static readonly byte[] DMCVTTargetedSystemDisplayMinimumLuminance = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x02, 0x0C, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// DMCVT Targeted System Display Primaries
    /// </summary>
    /// <remarks>
    /// xy chromaticity coordinates of the three primaries of the targeted system display
    /// </remarks>
    private static readonly byte[] DMCVTTargetedSystemDisplayPrimaries = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x02, 0x09, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// DMCVT Targeted System Display Signal Format
    /// </summary>
    /// <remarks>
    /// Enumerator of the signal format of the targeted system display
    /// </remarks>
    private static readonly byte[] DMCVTTargetedSystemDisplaySignalFormat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x02, 0x27, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// DMCVT Targeted System Display White Point Chromaticity
    /// </summary>
    /// <remarks>
    /// xy chromaticity coordinate of the targeted system display's white point
    /// </remarks>
    private static readonly byte[] DMCVTTargetedSystemDisplayWhitePointChromaticity = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x02, 0x0A, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// DMS AS-03
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] DMS_AS_03 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x04, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// DMS AS-03 Framework
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] DMS_AS_03_Framework = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x04, 0x01, 0x03, 0x01, 0x00, 0x00];
    /// <summary>
    /// DMS AS-10 Core
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] DMS_AS_10_Core = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0A, 0x01, 0x00, 0x00];
    /// <summary>
    /// DMS AS-10 Core Framework
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] DMS_AS_10_Core_Framework = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0A, 0x01, 0x01, 0x00];
    /// <summary>
    /// DMS_AS_12
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] DMS_AS_12 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0C, 0x01, 0x00, 0x00];
    /// <summary>
    /// DMS_AS_12_AdID_Slate
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] DMS_AS_12_AdID_Slate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x0D, 0x0D, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// DMS_AS_12_Framework
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] DMS_AS_12_Framework = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x07, 0x01, 0x0C, 0x01, 0x01, 0x00];
    /// <summary>
    /// Document ID
    /// </summary>
    /// <remarks>
    /// An identifier associated with the metadata instance / document
    /// </remarks>
    private static readonly byte[] documentId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Document Locator
    /// </summary>
    /// <remarks>
    /// the location where an instance of the metadata document can be found
    /// </remarks>
    private static readonly byte[] documentLocator = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// DOI
    /// </summary>
    /// <remarks>
    /// International DOI Foundation Digital Object Identifier
    /// </remarks>
    private static readonly byte[] DOI = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x15, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Dolby Laboratories Inc.
    /// </summary>
    /// <remarks>
    /// Metadata registered by Dolby Laboratories Inc. for private use
    /// </remarks>
    private static readonly byte[] DolbyLaboratories_Inc = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x0E, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Doremi Labs, Inc.
    /// </summary>
    /// <remarks>
    /// Metadata registered by Doremi Labs, Inc. for private use
    /// </remarks>
    private static readonly byte[] DoremiLabsInc = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x0E, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// DPP
    /// </summary>
    /// <remarks>
    /// Metadata registered by the UK Digital Production Partnership for public use
    /// </remarks>
    private static readonly byte[] DPP = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x0D, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// DPP Groups
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] DPP_Groups = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// DPP Schemes
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] DPP_Schemes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Drop Frame
    /// </summary>
    /// <remarks>
    /// Specifies whether timecode is drop frame (Non-drop Frame = 0)
    /// </remarks>
    private static readonly byte[] DropFrame = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x01, 0x01, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// DTS, Inc.
    /// </summary>
    /// <remarks>
    /// Metadata registered by DTS, Inc. for private use
    /// </remarks>
    private static readonly byte[] DTS = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x0E, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Durations
    /// </summary>
    /// <remarks>
    /// Information about time durations
    /// </remarks>
    private static readonly byte[] Durations = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Dutch Guild
    /// </summary>
    /// <remarks>
    /// Metadata registered by the Dutch Guild for public use
    /// </remarks>
    private static readonly byte[] DutchGuild = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x0D, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// DVB Parental Rating
    /// </summary>
    /// <remarks>
    /// Classification as used in DVB
    /// </remarks>
    private static readonly byte[] DVBParentalRating = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x07, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Dynamic Source Package ID
    /// </summary>
    /// <remarks>
    /// Specifies the package containing an essence event
    /// </remarks>
    private static readonly byte[] DynamicSourcePackageID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x06, 0x01, 0x01, 0x03, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Dynamic Source Track IDs
    /// </summary>
    /// <remarks>
    /// Specifies one or more tracks within the referenced precursor containing an essence event
    /// </remarks>
    private static readonly byte[] DynamicSourceTrackIDs = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x06, 0x01, 0x01, 0x03, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// EBU/UER
    /// </summary>
    /// <remarks>
    /// Metadata registered by the EBU for public use
    /// </remarks>
    private static readonly byte[] EBU_UER = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x0D, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// ebucore
    /// </summary>
    /// <remarks>
    /// The EBUCore schema
    /// </remarks>
    private static readonly byte[] ebucore = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// EBU Core Main Framework
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] EBUCoreMainFramework = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Ebucore Set
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] ebucoreObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x45, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Edge Code
    /// </summary>
    /// <remarks>
    /// The edge code on the film  eg feet;frames
    /// </remarks>
    private static readonly byte[] EdgeCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Edge Code Film Gauge
    /// </summary>
    /// <remarks>
    /// Specifies the gauge of film stock associated with the edge code.
    /// </remarks>
    private static readonly byte[] EdgeCodeFilmFormat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x10, 0x01, 0x03, 0x01, 0x09, 0x00, 0x00];
    /// <summary>
    /// Edge Code Format
    /// </summary>
    /// <remarks>
    /// Specifies the edge code format
    /// </remarks>
    private static readonly byte[] EdgeCodeFormat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x10, 0x01, 0x03, 0x01, 0x02, 0x00, 0x00];
    /// <summary>
    /// Edge Code Header
    /// </summary>
    /// <remarks>
    /// An organizationally given header for a film reel or roll
    /// </remarks>
    private static readonly byte[] EdgeCodeHeader = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x03, 0x02, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Edge Code Start
    /// </summary>
    /// <remarks>
    /// Specifies the edge code at the beginning of the clip, segment etc
    /// </remarks>
    private static readonly byte[] EdgeCodeStart = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x04, 0x09, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Edit Hint
    /// </summary>
    /// <remarks>
    /// Hint provided to an interpolator for the algorithm to be used
    /// </remarks>
    private static readonly byte[] EditHint = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x30, 0x05, 0x08, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Editing Decision Information
    /// </summary>
    /// <remarks>
    /// Information about editing decisions.
    /// </remarks>
    private static readonly byte[] EditingDecisionInformation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x30, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Editing Effect Information
    /// </summary>
    /// <remarks>
    /// Information about editing effects
    /// </remarks>
    private static readonly byte[] EditingEffectInformation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x30, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Editing Event Information
    /// </summary>
    /// <remarks>
    /// Information about editing events
    /// </remarks>
    private static readonly byte[] EditingEventInformation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x30, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Editing Information
    /// </summary>
    /// <remarks>
    /// Information about alterations to the original image stream to produce new editorial material.
    /// </remarks>
    private static readonly byte[] EditingInformation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Editing Matte Information
    /// </summary>
    /// <remarks>
    /// Information about editing mattes
    /// </remarks>
    private static readonly byte[] EditingMatteInformation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x30, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Editing User Notes
    /// </summary>
    /// <remarks>
    /// Information about editing user notes
    /// </remarks>
    private static readonly byte[] EditingUserNotes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x30, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Editing Version Information
    /// </summary>
    /// <remarks>
    /// Information about the version of the edit
    /// </remarks>
    private static readonly byte[] EditingVersionInformation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x30, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Editing Web Information
    /// </summary>
    /// <remarks>
    /// Information about editing for web output
    /// </remarks>
    private static readonly byte[] EditingWebInformation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x30, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Edit Offsets
    /// </summary>
    /// <remarks>
    /// Information about editing offsets
    /// </remarks>
    private static readonly byte[] EditOffsets = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x07, 0x02, 0x01, 0x03, 0x10, 0x02, 0x00, 0x00];
    /// <summary>
    /// Editorial Comments and Descriptions
    /// </summary>
    /// <remarks>
    /// Comments or descriptions of an editorial nature
    /// </remarks>
    private static readonly byte[] EditorialCommentsAndDescriptions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timeline Edit Rate
    /// </summary>
    /// <remarks>
    /// Specifies the timeline rate in hertz
    /// </remarks>
    private static readonly byte[] EditRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x30, 0x04, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Edit Timeline Durations
    /// </summary>
    /// <remarks>
    /// Time duration information
    /// </remarks>
    private static readonly byte[] EditTimelineDurations = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Edit Unit
    /// </summary>
    /// <remarks>
    /// Time expressed in edit units
    /// </remarks>
    private static readonly byte[] editUnit = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x58, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Edit Unit Byte Count
    /// </summary>
    /// <remarks>
    /// Defines the byte count of each and every Edit Unit of stored Essence indexed by this Index Table Segment
    /// </remarks>
    private static readonly byte[] EditUnitByteCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x04, 0x06, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// EIDR DMS Essence ID
    /// </summary>
    /// <remarks>
    /// EIDR Identifier for the essence associated with the Descriptive Framework Set
    /// </remarks>
    private static readonly byte[] EIDRDMSEssenceID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x01, 0x01, 0x15, 0x14, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Electrical Extender Magnification
    /// </summary>
    /// <remarks>
    /// Expresses the magnification setup of the picture size in percent where 100% (64h) represents the original picture size
    /// </remarks>
    private static readonly byte[] ElectricalExtenderMagnification = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x01, 0x03, 0x01, 0x0B, 0x00, 0x00];
    /// <summary>
    /// Electronic Address Information
    /// </summary>
    /// <remarks>
    /// Information about electronic addresses
    /// </remarks>
    private static readonly byte[] ElectronicAddressInformation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x10, 0x03, 0x00, 0x00];
    /// <summary>
    /// Electronic Address Varieties
    /// </summary>
    /// <remarks>
    /// Information about electronic addresses
    /// </remarks>
    private static readonly byte[] ElectronicAddressVarieties = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x07, 0x01, 0x20, 0x01, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// Electrospatial Formulation
    /// </summary>
    /// <remarks>
    /// Mono, Dual mono, Stereo A+B,  Stereo M&amp;S, Dolby surround,  MPEG BC/NBC etc
    /// </remarks>
    private static readonly byte[] ElectrospatialFormulation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Element Count
    /// </summary>
    /// <remarks>
    /// Specifies the number of elements in the array
    /// </remarks>
    private static readonly byte[] ElementCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x02, 0x03, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Element Delta
    /// </summary>
    /// <remarks>
    /// The number of bytes from the start of the section to this element.
    /// </remarks>
    private static readonly byte[] ElementDelta = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x04, 0x04, 0x04, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Element Length
    /// </summary>
    /// <remarks>
    /// The length of each element in a list in bytes
    /// </remarks>
    private static readonly byte[] ElementLength = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x03, 0x01, 0x02, 0x03, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Element Name List
    /// </summary>
    /// <remarks>
    /// Specifies, as a single string value, a list of names zero delineated between each name in an enumeration
    /// </remarks>
    private static readonly byte[] ElementNames = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Element Of
    /// </summary>
    /// <remarks>
    /// References the ExtendibleEnumerations in which this element is known to be used
    /// </remarks>
    private static readonly byte[] ElementOf = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x06, 0x01, 0x01, 0x07, 0x21, 0x00, 0x00, 0x00];
    /// <summary>
    /// ELEMENTS
    /// </summary>
    /// <remarks>
    /// Register of individual Metadata Elements
    /// </remarks>
    private static readonly byte[] _Elements = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Enumeration Underlying Integer Type
    /// </summary>
    /// <remarks>
    /// Specifies the underlying type of an integer enumeration type
    /// </remarks>
    private static readonly byte[] ElementType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x07, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Type Definition Element Value List
    /// </summary>
    /// <remarks>
    /// Specifies, as a single string value, a list of values to match the names in the Type Definition Element Name List
    /// </remarks>
    private static readonly byte[] ElementValues = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x02, 0x03, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// E-Mail Address
    /// </summary>
    /// <remarks>
    /// e-mail address
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] EmailAddress_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x10, 0x03, 0x03, 0x01];
    /// <summary>
    /// Email Address
    /// </summary>
    /// <remarks>
    /// An email address
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] EmailAddress_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x25, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// E-Mail Address
    /// </summary>
    /// <remarks>
    /// e-mail address
    /// </remarks>
    private static readonly byte[] EmailAddress_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x10, 0x03, 0x03, 0x00];
    /// <summary>
    /// Emphasis
    /// </summary>
    /// <remarks>
    /// The AES-3 emphasis in use
    /// </remarks>
    private static readonly byte[] Emphasis = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x05, 0x01, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Encoding and Decoding
    /// </summary>
    /// <remarks>
    /// Information about delay durations in encoding and decoding processes
    /// </remarks>
    private static readonly byte[] EncodingAndDecoding = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Encoding Delay
    /// </summary>
    /// <remarks>
    /// Information about delay durations in encoding processes
    /// </remarks>
    private static readonly byte[] EncodingDelay = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x03, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Encrypted Source Value
    /// </summary>
    /// <remarks>
    /// The encrypted essence value
    /// </remarks>
    private static readonly byte[] EncryptedSourceValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x02, 0x09, 0x03, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Encrypted Track File ID
    /// </summary>
    /// <remarks>
    /// The identifier of the AS-DCP track file containing this triplet
    /// </remarks>
    private static readonly byte[] EncryptedTrackFileID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x06, 0x01, 0x01, 0x06, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Encryption
    /// </summary>
    /// <remarks>
    /// Content encryption/decryption information
    /// </remarks>
    private static readonly byte[] Encryption = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// End Anchor
    /// </summary>
    /// <remarks>
    /// Specifies the HTML Anchor at which this clip ends
    /// </remarks>
    private static readonly byte[] EndAnchor = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x30, 0x06, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// End Anchor
    /// </summary>
    /// <remarks>
    /// Specifies the HTML Anchor at which this clip ends
    /// </remarks>
    private static readonly byte[] EndAnchor_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x30, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Qlty End Of Modulation
    /// </summary>
    /// <remarks>
    /// End of modulation time of the original recording, in hours, minutes, seconds and tenths of a second
    /// </remarks>
    private static readonly byte[] EndModulation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x05, 0x02, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// End Time
    /// </summary>
    /// <remarks>
    /// Timestamp representing the end of the time window containing the requested security log events
    /// </remarks>
    private static readonly byte[] EndTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x22, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Energy
    /// </summary>
    /// <remarks>
    /// Descriptive information about Energy (Default is Joule)
    /// </remarks>
    private static readonly byte[] Energy = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x03, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Plug-In Engine ID
    /// </summary>
    /// <remarks>
    /// Identifies the software engine of the plugin
    /// </remarks>
    private static readonly byte[] Engine = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Enhancement or Modification
    /// </summary>
    /// <remarks>
    /// Enhamcement or modification to the essence
    /// </remarks>
    private static readonly byte[] EnhancementOrModification = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Enhancement or Modification Description
    /// </summary>
    /// <remarks>
    /// Description of how video content was modified.
    /// </remarks>
    private static readonly byte[] EnhancementOrModificationDescription_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x20, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Entity
    /// </summary>
    /// <remarks>
    /// A set of attributes to identifiy a participant and its role
    /// </remarks>
    private static readonly byte[] entity = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x21, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Entity Award Sets
    /// </summary>
    /// <remarks>
    /// To list awards received by a person or organization.
    /// </remarks>
    private static readonly byte[] entityAwardObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x21, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Entity Contact Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to contact objects
    /// </remarks>
    private static readonly byte[] entityContactObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x21, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Entity Event Sets
    /// </summary>
    /// <remarks>
    /// To list events related to an Entity.
    /// </remarks>
    private static readonly byte[] entityEventObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x21, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Entity ID
    /// </summary>
    /// <remarks>
    /// An identifier attributed to the participant
    /// </remarks>
    private static readonly byte[] entityID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x21, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Entity Organization Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to organization objects
    /// </remarks>
    private static readonly byte[] entityOrganizationObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x21, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Entity Role Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to  role objects
    /// </remarks>
    private static readonly byte[] entityRoleObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x21, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Enumerated Attributes
    /// </summary>
    /// <remarks>
    /// Enumerated Attributes
    /// </remarks>
    private static readonly byte[] EnumeratedAttributes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// EPG Program Synopsis
    /// </summary>
    /// <remarks>
    /// Short synopsis of the program for use in the EPG
    /// </remarks>
    private static readonly byte[] EPGProgramSynopsis = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x06, 0x08, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Episode Number
    /// </summary>
    /// <remarks>
    /// The alphanumeric episode number
    /// </remarks>
    private static readonly byte[] EpisodeNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x05, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Episode Number
    /// </summary>
    /// <remarks>
    /// The alphanumeric episode number
    /// </remarks>
    private static readonly byte[] EpisodeNumber_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Episode End Number
    /// </summary>
    /// <remarks>
    /// The episodic number at the end of a series
    /// </remarks>
    private static readonly byte[] EpisodicEndNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x02, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Episodic Item Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Episodic Item sets
    /// </remarks>
    private static readonly byte[] EpisodicItemSets = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x07, 0x00];
    /// <summary>
    /// Episode Start Number
    /// </summary>
    /// <remarks>
    /// The episodic number at the start of a series
    /// </remarks>
    private static readonly byte[] EpisodicStartNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Essence and Metadata Relationships
    /// </summary>
    /// <remarks>
    /// Type of relation (e.g., is part of, is an item of [program, series], remix, remake, ...)
    /// </remarks>
    private static readonly byte[] EssenceAndMetadataRelationships = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x06, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Essence Container Array
    /// </summary>
    /// <remarks>
    /// An array of 'n' universal labels of all essence containers in the file
    /// </remarks>
    private static readonly byte[] EssenceContainerArray = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x01, 0x02, 0x02, 0x10, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Essence Container Format
    /// </summary>
    /// <remarks>
    /// Specifies a reference to the format of Container of Essence Data
    /// </remarks>
    private static readonly byte[] EssenceContainerFormat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x01, 0x02, 0x01, 0x00];
    /// <summary>
    /// Essence Containers
    /// </summary>
    /// <remarks>
    /// A batch of 'n' universal labels of all essence containers in the file
    /// </remarks>
    private static readonly byte[] EssenceContainers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x02, 0x02, 0x10, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Essence Data
    /// </summary>
    /// <remarks>
    /// Specifies a unordered set of references to Essence Data
    /// </remarks>
    private static readonly byte[] EssenceDataObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x05, 0x02, 0x00, 0x00];
    /// <summary>
    /// Essence Description
    /// </summary>
    /// <remarks>
    /// Specifies a reference to a format descriptor for the essence
    /// </remarks>
    private static readonly byte[] EssenceDescription = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x02, 0x03, 0x00, 0x00];
    /// <summary>
    /// Essence Is Identified
    /// </summary>
    /// <remarks>
    /// Specifies whether the wrapper or container format identifies essence with an SMPTE label or other AUID (False=0)
    /// </remarks>
    private static readonly byte[] EssenceIsIdentified = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x02, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Essence Length
    /// </summary>
    /// <remarks>
    /// Specifies the number of addressable elements of essence data
    /// </remarks>
    private static readonly byte[] EssenceLength = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x06, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Essence Stream
    /// </summary>
    /// <remarks>
    /// Specifies the stream of data as essence
    /// </remarks>
    private static readonly byte[] EssenceStream = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x07, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Essence Stream ID
    /// </summary>
    /// <remarks>
    /// Essence (or its container) stream ID
    /// </remarks>
    private static readonly byte[] EssenceStreamID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x01, 0x03, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Essence to Essence Relationships
    /// </summary>
    /// <remarks>
    /// The relationship value in terms of Parent of;  Child of;  Item of;  Excerpt of;  Version of;  Compilation of;  etc
    /// </remarks>
    private static readonly byte[] EssenceToEssenceRelationships = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x06, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Essence to Object Relationships
    /// </summary>
    /// <remarks>
    /// The relationship between metadata and an object
    /// </remarks>
    private static readonly byte[] EssenceToObjectRelationships = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Track Number
    /// </summary>
    /// <remarks>
    /// Specifies the intended track number in a sequences of tracks
    /// </remarks>
    private static readonly byte[] EssenceTrackNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x04, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Event
    /// </summary>
    /// <remarks>
    /// To describe an event related to the media resource.
    /// </remarks>
    private static readonly byte[] _event = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6C, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Event Absolute Duration
    /// </summary>
    /// <remarks>
    /// The absolute duration of the project, mission, scene, editing event, license, publication etc
    /// </remarks>
    private static readonly byte[] EventAbsoluteDuration = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x02, 0x01, 0x03, 0x03, 0x00, 0x00];
    /// <summary>
    /// Event Absolute Duration
    /// </summary>
    /// <remarks>
    /// The absolute duration of the project, mission, scene, editing event, license, publication etc
    /// </remarks>
    private static readonly byte[] EventAbsoluteDuration_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x02, 0x01, 0x03, 0x02, 0x00, 0x00];
    /// <summary>
    /// Event Absolute Duration Frame Count
    /// </summary>
    /// <remarks>
    /// The absolute duration of the project, mission, scene, editing event, license, publication etc
    /// </remarks>
    private static readonly byte[] EventAbsoluteDurationFrameCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x02, 0x01, 0x03, 0x01, 0x00, 0x00];
    /// <summary>
    /// Event Absolute Durations
    /// </summary>
    /// <remarks>
    /// The absolute duration of the project, mission, scene, editing event, license, publication etc
    /// </remarks>
    private static readonly byte[] EventAbsoluteDurations = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x02, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Event Annotation Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Annotation sets
    /// </remarks>
    private static readonly byte[] EventAnnotationObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x0D, 0x01];
    /// <summary>
    /// Event Comment
    /// </summary>
    /// <remarks>
    /// User-provided Comment Text for an event
    /// </remarks>
    private static readonly byte[] EventComment = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x30, 0x04, 0x04, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Event Comment
    /// </summary>
    /// <remarks>
    /// User-provided Comment Text for an event
    /// </remarks>
    private static readonly byte[] EventComment_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x30, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Event Description Sets
    /// </summary>
    /// <remarks>
    /// To provide description of the event, possibly in different languages.
    /// </remarks>
    private static readonly byte[] eventDescriptionObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6C, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Event Elapsed Time to End
    /// </summary>
    /// <remarks>
    /// The elapsed time into the segment, shot, clip, item etc. when an event finishes (Days, Hours, minutes, seconds, fractions of seconds)
    /// </remarks>
    private static readonly byte[] EventElapsedTimeToEnd_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x02, 0x01, 0x03, 0x10, 0x03, 0x02, 0x00];
    /// <summary>
    /// Event Elapsed Time to Start
    /// </summary>
    /// <remarks>
    /// The elapsed time into the segment, shot, clip, item etc. when an event begins (Days, Hours, minutes, seconds, fractions of seconds)
    /// </remarks>
    private static readonly byte[] EventElapsedTimeToStart_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x02, 0x01, 0x03, 0x10, 0x03, 0x01, 0x00];
    /// <summary>
    /// Event End
    /// </summary>
    /// <remarks>
    /// To give an end date for an Event.
    /// </remarks>
    private static readonly byte[] eventEnd = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6C, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Local Event End Date-Time
    /// </summary>
    /// <remarks>
    /// The absolute ending date and time of the project, mission, scene, editing event, license, publication etc
    /// </remarks>
    private static readonly byte[] EventEndDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x02, 0x09, 0x02, 0x00, 0x00];
    /// <summary>
    /// Event End Relative Times
    /// </summary>
    /// <remarks>
    /// The relative end time of the project, mission, scene, editing event, license, publication etc
    /// </remarks>
    private static readonly byte[] EventEndRelativeTimes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x03, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Event End Time Address
    /// </summary>
    /// <remarks>
    /// The absolute ending date and time of the project, mission, scene, editing event, license, publication etc
    /// </remarks>
    private static readonly byte[] EventEndTimeAddress = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x02, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Event End Timecode Offset
    /// </summary>
    /// <remarks>
    /// The relative end time of the project, mission, scene, editing event, license, publication etc
    /// </remarks>
    private static readonly byte[] EventEndTimecodeOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x03, 0x04, 0x02, 0x00, 0x00];
    /// <summary>
    /// Event End Time Offset
    /// </summary>
    /// <remarks>
    /// The relative end time of the project, mission, scene, editing event, license, publication etc
    /// </remarks>
    private static readonly byte[] EventEndTimeOffset_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x03, 0x04, 0x01, 0x00, 0x00];
    /// <summary>
    /// Event End True Date-Time
    /// </summary>
    /// <remarks>
    /// The absolute ending date and time of the project, mission, scene, editing event, license, publication etc
    /// </remarks>
    private static readonly byte[] EventEndTrueDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x02, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Event ID
    /// </summary>
    /// <remarks>
    /// An identifer associated with an event.
    /// </remarks>
    private static readonly byte[] eventId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6C, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Event Indication
    /// </summary>
    /// <remarks>
    /// A term that describes what the Event is as a part of the Process.  Terms must be consistent with industry or organizational practices to be useful.  Includes project, mission, scene, in-points, trigger points, license, option, publication, cataloguing etc.
    /// </remarks>
    private static readonly byte[] EventIndication = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x05, 0x01, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Event Indication
    /// </summary>
    /// <remarks>
    /// A term that describes what the Event is as a part of the Process.  Terms must be consistent with industry or organizational practices to be useful.  Includes project, mission, scene, in-points, trigger points, license, option, publication, cataloguing etc.
    /// </remarks>
    private static readonly byte[] EventIndication_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x01, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Event Location Sets
    /// </summary>
    /// <remarks>
    /// To provide information on the locations related to the event.
    /// </remarks>
    private static readonly byte[] eventLocationObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6C, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Event Name Sets
    /// </summary>
    /// <remarks>
    /// To provide the names by which the event is known, possibly in different languages.
    /// </remarks>
    private static readonly byte[] eventNameObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6C, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Event Note
    /// </summary>
    /// <remarks>
    /// To provide additional contextual information about the event.
    /// </remarks>
    private static readonly byte[] eventNote = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6C, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Event Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Event sets
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] EventObjects_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x09, 0x00];
    /// <summary>
    /// Event Sets
    /// </summary>
    /// <remarks>
    /// Events related to the media resource.
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] EventObjects_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x02, 0x17, 0x00, 0x00, 0x00];
    /// <summary>
    /// Event Offsets
    /// </summary>
    /// <remarks>
    /// Information about events offset from the beginning of material - ie, an event occuring after a given time interval from the start of a segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] EventOffsets = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x02, 0x01, 0x03, 0x10, 0x03, 0x00, 0x00];
    /// <summary>
    /// Event Start
    /// </summary>
    /// <remarks>
    /// Specifies the Starting Time of an Event in edit units, relative to the origin
    /// </remarks>
    private static readonly byte[] EventPosition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x07, 0x02, 0x01, 0x03, 0x03, 0x03, 0x00, 0x00];
    /// <summary>
    /// Event Start
    /// </summary>
    /// <remarks>
    /// To give a start date for an Event.
    /// </remarks>
    private static readonly byte[] eventStart = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6C, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Local Event Start Date-Time
    /// </summary>
    /// <remarks>
    /// The absolute beginning date and time of the project, mission, scene, editing event, license, publication etc
    /// </remarks>
    private static readonly byte[] EventStartDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x02, 0x07, 0x02, 0x00, 0x00];
    /// <summary>
    /// Event Start Relative Times
    /// </summary>
    /// <remarks>
    /// The relative start time of the project, mission, scene, editing event, license, publication etc
    /// </remarks>
    private static readonly byte[] EventStartRelativeTimes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Event Start Time Address
    /// </summary>
    /// <remarks>
    /// The absolute beginning date and time of the project, mission, scene, editing event, license, publication etc
    /// </remarks>
    private static readonly byte[] EventStartTimeAddress = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x02, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Event Start Timecode Offset
    /// </summary>
    /// <remarks>
    /// The relative start time of the project, mission, scene, editing event, license, publication etc
    /// </remarks>
    private static readonly byte[] EventStartTimecodeOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x03, 0x03, 0x02, 0x00, 0x00];
    /// <summary>
    /// Event Start Time Offset
    /// </summary>
    /// <remarks>
    /// The relative start time of the project, mission, scene, editing event, license, publication etc
    /// </remarks>
    private static readonly byte[] EventStartTimeOffset_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x03, 0x03, 0x01, 0x00, 0x00];
    /// <summary>
    /// Event Start True Date-Time
    /// </summary>
    /// <remarks>
    /// The absolute beginning date and time of the project, mission, scene, editing event, license, publication etc
    /// </remarks>
    private static readonly byte[] EventStartTrueDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x02, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Event Text Kind
    /// </summary>
    /// <remarks>
    /// Identifies the type (purpose) of the event text type, e.g. subtitles or closed captions.
    /// </remarks>
    private static readonly byte[] EventTextKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x03, 0x02, 0x01, 0x08, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Event Text Language Code
    /// </summary>
    /// <remarks>
    /// Specifies the language of the event text using RFC 5646 tags
    /// </remarks>
    private static readonly byte[] EventTextLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x03, 0x01, 0x01, 0x02, 0x02, 0x15, 0x00, 0x00];
    /// <summary>
    /// Event Track Edit Rate
    /// </summary>
    /// <remarks>
    /// Specifies the time base for edit/event units in hertz.
    /// </remarks>
    private static readonly byte[] EventTrackEditRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x30, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Event Origin
    /// </summary>
    /// <remarks>
    /// Specifies the point, in edit units, in an event track from which relative times are measured.
    /// </remarks>
    private static readonly byte[] EventTrackOrigin = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x07, 0x02, 0x01, 0x03, 0x01, 0x0B, 0x00, 0x00];
    /// <summary>
    /// Event Type Group Set
    /// </summary>
    /// <remarks>
    /// To specify a kind of event.
    /// </remarks>
    private static readonly byte[] eventTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x6C, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// EVS Broadcast Equipment
    /// </summary>
    /// <remarks>
    /// Metadata registered by EVS Broadcast Equipment for private use
    /// </remarks>
    private static readonly byte[] EVSBroadcastEquipment = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x0E, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// ExCCI Data
    /// </summary>
    /// <remarks>
    /// Extended Content Control Information Data Packet
    /// </remarks>
    private static readonly byte[] ExCCIData = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x07, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Experimental
    /// </summary>
    /// <remarks>
    /// For use in multimedia research or other limited access, experimental environments
    /// </remarks>
    private static readonly byte[] Experimental = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Exploitation Issues Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to a textual annotation to express exploitation issues
    /// </remarks>
    private static readonly byte[] exploitationIssuesObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x19, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Export Status
    /// </summary>
    /// <remarks>
    /// Export Status
    /// </remarks>
    private static readonly byte[] ExportStatus = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x24, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Exposure Index of Photo Meter
    /// </summary>
    /// <remarks>
    /// Setting of the photo meter in ISO number.
    /// </remarks>
    private static readonly byte[] ExposureIndexOfPhotoMeter = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x01, 0x03, 0x01, 0x0C, 0x00, 0x00];
    /// <summary>
    /// Exposure Index of Photo Meter in Long Integer
    /// </summary>
    /// <remarks>
    /// Setting of the photo meter in ISO number  for high sensitivity camera
    /// </remarks>
    private static readonly byte[] ExposureIndexOfPhotoMeterLongInteger = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x01, 0x03, 0x01, 0x0C, 0x01, 0x00];
    /// <summary>
    /// Extended Captions Language Code
    /// </summary>
    /// <remarks>
    /// The RFC-3066-compliant code that specifies the base ISO code for the language as well as regional and script variant information used for textual captions displayed on-screen
    /// </remarks>
    private static readonly byte[] ExtendedCaptionsLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x01, 0x02, 0x02, 0x12, 0x00, 0x00];
    /// <summary>
    /// Extended Clip ID
    /// </summary>
    /// <remarks>
    /// Clip ID as an Extended UMID. Note that the value includes the whole UMID including the first 12 UL bytes
    /// </remarks>
    private static readonly byte[] ExtendedClipID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x01, 0x01, 0x15, 0x09, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Extended Clip ID Array
    /// </summary>
    /// <remarks>
    /// An ordered  array of Extended UMIDs
    /// </remarks>
    private static readonly byte[] ExtendedClipIDArray = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x01, 0x01, 0x15, 0x0B, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Extended Text Language Code
    /// </summary>
    /// <remarks>
    /// The RFC-3066-compliant code that specifies the base ISO code for the language as well as regional and script variant information used for text
    /// </remarks>
    private static readonly byte[] ExtendedTextLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x01, 0x02, 0x02, 0x11, 0x00, 0x00];
    /// <summary>
    /// Extendible Element Name List
    /// </summary>
    /// <remarks>
    /// Specifies, as a single string value, a list of names zero delineated between each name in an extendible enumeration
    /// </remarks>
    private static readonly byte[] ExtendibleEnumerationElementNames = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x02, 0x03, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Type Definition Extendible Element Values
    /// </summary>
    /// <remarks>
    /// Specifies as a single string value a list of values to match the SMPTE labels or AUIDs in the Type Definition Extendible Element Names
    /// </remarks>
    private static readonly byte[] ExtendibleEnumerationElementValues = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x02, 0x03, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Extension Description
    /// </summary>
    /// <remarks>
    /// Description of the Extension Scheme
    /// </remarks>
    private static readonly byte[] ExtensionDescription = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x06, 0x01, 0x01, 0x07, 0x1E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Extension Scheme ID
    /// </summary>
    /// <remarks>
    /// Globally unique identification of the ExtensionScheme
    /// </remarks>
    private static readonly byte[] ExtensionSchemeID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x06, 0x01, 0x01, 0x07, 0x1B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Ext Start Offset
    /// </summary>
    /// <remarks>
    /// The byte offset to the first essence data in an external Essence file
    /// </remarks>
    private static readonly byte[] ExtStartOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x06, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Factor Denominator
    /// </summary>
    /// <remarks>
    /// The denominator
    /// </remarks>
    private static readonly byte[] factorDenominator = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3F, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Factor Numerator
    /// </summary>
    /// <remarks>
    /// The numerator
    /// </remarks>
    private static readonly byte[] factorNumerator = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3F, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Fade-In Duration
    /// </summary>
    /// <remarks>
    /// Specifies the length of an audio fade-in to be applied, in units of edit rate
    /// </remarks>
    private static readonly byte[] FadeInLength = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x07, 0x02, 0x02, 0x01, 0x01, 0x05, 0x02, 0x00];
    /// <summary>
    /// Fade-In Type
    /// </summary>
    /// <remarks>
    /// Specifies type of audio fade in
    /// </remarks>
    private static readonly byte[] FadeInType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x30, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Fade-Out Duration
    /// </summary>
    /// <remarks>
    /// Specifies the length of an audio fade-out to be applied, in units of edit rate
    /// </remarks>
    private static readonly byte[] FadeOutLength = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x07, 0x02, 0x02, 0x01, 0x01, 0x05, 0x03, 0x00];
    /// <summary>
    /// Fade-Out Type
    /// </summary>
    /// <remarks>
    /// Specifies type of audio fade out
    /// </remarks>
    private static readonly byte[] FadeOutType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x30, 0x05, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Family Name
    /// </summary>
    /// <remarks>
    /// The family name
    /// </remarks>
    private static readonly byte[] familiyName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x22, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Family Name
    /// </summary>
    /// <remarks>
    /// The family name of an individual
    /// </remarks>
    private static readonly byte[] FamilyName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x30, 0x06, 0x03, 0x01, 0x01, 0x01, 0x00];
    /// <summary>
    /// Family Name
    /// </summary>
    /// <remarks>
    /// The family name of an individual
    /// </remarks>
    private static readonly byte[] FamilyName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x06, 0x03, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Fax Number
    /// </summary>
    /// <remarks>
    /// Fax number
    /// </remarks>
    private static readonly byte[] FaxNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x10, 0x03, 0x02, 0x00];
    /// <summary>
    /// Fax Number
    /// </summary>
    /// <remarks>
    /// Fax number
    /// </remarks>
    private static readonly byte[] FaxNumber_UTF16String = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x10, 0x03, 0x02, 0x01];
    /// <summary>
    /// Female Lead Actress Name
    /// </summary>
    /// <remarks>
    /// Contains the name of the female lead actress of the program
    /// </remarks>
    private static readonly byte[] FemaleLeadActressName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x0A, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Local Festival Date-Time
    /// </summary>
    /// <remarks>
    /// The beginning date and time of the festival (local time)
    /// </remarks>
    private static readonly byte[] FestivalDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x07, 0x02, 0x01, 0x02, 0x07, 0x10, 0x01, 0x00];
    /// <summary>
    /// Festival Name
    /// </summary>
    /// <remarks>
    /// The festival or award ceremony at which an award was made.
    /// </remarks>
    private static readonly byte[] FestivalName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x03, 0x02, 0x02, 0x01, 0x03, 0x01, 0x00, 0x00];
    /// <summary>
    /// Festival Name
    /// </summary>
    /// <remarks>
    /// The festival or award ceremony at which an award was made.
    /// </remarks>
    private static readonly byte[] FestivalName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x02, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// FFV1CodingParameters
    /// </summary>
    /// <remarks>
    /// FFV1 Coding Parameters
    /// </remarks>
    private static readonly byte[] FFV1CodingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x0C, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// FFV1IdenticalGOP
    /// </summary>
    /// <remarks>
    /// TRUE if every GOP in the sequence is constructed the same, Boolean
    /// </remarks>
    private static readonly byte[] FFV1IdenticalGOP = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x0C, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// FFV1InitializationMetadata
    /// </summary>
    /// <remarks>
    /// FFV1 Initialization Metadata, required for Version 3 streams, UInt8Array
    /// </remarks>
    private static readonly byte[] FFV1InitializationMetadata = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x0C, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// FFV1MaxGOP
    /// </summary>
    /// <remarks>
    /// Specifies the maximum occurring spacing between key frames. A value of 0 or the absence of this property implies no limit to the maximum GOP, UInt16
    /// </remarks>
    private static readonly byte[] FFV1MaxGOP = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x0C, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// FFV1MaximumBitRate
    /// </summary>
    /// <remarks>
    /// Maximum bit rate of FFV1 video elementary stream in bits per second, UInt32
    /// </remarks>
    private static readonly byte[] FFV1MaximumBitRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x0C, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// FFV1MicroVersion
    /// </summary>
    /// <remarks>
    /// Specifies the FFV1 video microversion. Coded as per IETF RFC (to be defined), UInt16
    /// </remarks>
    private static readonly byte[] FFV1MicroVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x0C, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// FFV1Version
    /// </summary>
    /// <remarks>
    /// Specifies the FFV1 video version. Coded as per IETF RFC (to be defined), UInt16
    /// </remarks>
    private static readonly byte[] FFV1Version = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x0C, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Field Dominance
    /// </summary>
    /// <remarks>
    /// Specifies whether the first frame of picture is field 1 or field 2
    /// </remarks>
    private static readonly byte[] FieldDominance = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x01, 0x03, 0x01, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Field Frame Type Code
    /// </summary>
    /// <remarks>
    /// Identifies the field or frame type of the source video image for video derived from compressed sources.  Eg,  I  B  or P
    /// </remarks>
    private static readonly byte[] FieldFrameTypeCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x06, 0x02, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Field of View (FOV-Horizontal)
    /// </summary>
    /// <remarks>
    /// Sensor horizontal field of view.
    /// </remarks>
    private static readonly byte[] FieldOfViewFOVHorizontal = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x20, 0x02, 0x01, 0x01, 0x08, 0x00, 0x00];
    /// <summary>
    /// Field of View (FOV-Horizontal)
    /// </summary>
    /// <remarks>
    /// Sensor horizontal field of view in degrees
    /// </remarks>
    private static readonly byte[] FieldOfViewFOVHorizontalFP4 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x20, 0x02, 0x01, 0x01, 0x08, 0x01, 0x00];
    /// <summary>
    /// Field of View (FOV-Vertical)
    /// </summary>
    /// <remarks>
    /// Sensor vertical field of view in degrees
    /// </remarks>
    private static readonly byte[] FieldOfViewFOVVertical = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x20, 0x02, 0x01, 0x01, 0x0A, 0x00, 0x00];
    /// <summary>
    /// Field of View (FOV-Vertical FP-4)
    /// </summary>
    /// <remarks>
    /// Sensor vertical field of view in degrees
    /// </remarks>
    private static readonly byte[] FieldOfViewFOVVerticalFP4 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x04, 0x20, 0x02, 0x01, 0x01, 0x0A, 0x01, 0x00];
    /// <summary>
    /// Field Rate
    /// </summary>
    /// <remarks>
    /// Specifies the field rate of the video scanning  system.
    /// </remarks>
    private static readonly byte[] FieldRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x03, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Codec Essence Descriptor
    /// </summary>
    /// <remarks>
    /// Specifies a reference to the file essence descriptor used by the codec
    /// </remarks>
    private static readonly byte[] FileDescriptorClass = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x01, 0x07, 0x00, 0x00];
    /// <summary>
    /// File Descriptors
    /// </summary>
    /// <remarks>
    /// Specifies a vector of an ordered set of references to File Descriptor sets
    /// </remarks>
    private static readonly byte[] FileDescriptors = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x01, 0x01, 0x04, 0x06, 0x0B, 0x00, 0x00];
    /// <summary>
    /// Container Last Modification Date-Time
    /// </summary>
    /// <remarks>
    /// Identifies date and time at the point of most recent modification of any item in the container
    /// </remarks>
    private static readonly byte[] FileLastModified = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x07, 0x02, 0x01, 0x10, 0x02, 0x04, 0x00, 0x00];
    /// <summary>
    /// Modification Date-Time
    /// </summary>
    /// <remarks>
    /// Identifies date and time at the point of modification
    /// </remarks>
    private static readonly byte[] FileModificationDate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x07, 0x02, 0x01, 0x10, 0x02, 0x03, 0x00, 0x00];
    /// <summary>
    /// Filler Data
    /// </summary>
    /// <remarks>
    /// Specifies an empty data element.  Intended to act as a space filler.  Value may be application dependant.
    /// </remarks>
    private static readonly byte[] FillerData = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x02, 0x10, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Exposed Aspect Ratio
    /// </summary>
    /// <remarks>
    /// Aspect ratio of the exposed physical frame
    /// </remarks>
    private static readonly byte[] FilmAspectRatio = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x10, 0x01, 0x03, 0x02, 0x03, 0x00, 0x00];
    /// <summary>
    /// Film Batch Number
    /// </summary>
    /// <remarks>
    /// Specifies the batch of film stock
    /// </remarks>
    private static readonly byte[] FilmBatchNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x10, 0x01, 0x03, 0x01, 0x07, 0x01, 0x00];
    /// <summary>
    /// Film Batch Number
    /// </summary>
    /// <remarks>
    /// Specifies the batch of film stock
    /// </remarks>
    private static readonly byte[] FilmBatchNumber_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x10, 0x01, 0x03, 0x01, 0x07, 0x00, 0x00];
    /// <summary>
    /// Film Capture Aperture
    /// </summary>
    /// <remarks>
    /// Examples: Super 16, Academy etc.
    /// </remarks>
    private static readonly byte[] FilmCaptureAperture_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x10, 0x01, 0x03, 0x02, 0x02, 0x00, 0x00];
    /// <summary>
    /// Film Capture Process
    /// </summary>
    /// <remarks>
    /// Information about how film content was captured
    /// </remarks>
    private static readonly byte[] FilmCaptureProcess = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Film Color Process
    /// </summary>
    /// <remarks>
    /// The film coloring process used.  Eg  Pathe Color,  Hand Coloring,  Berthon Keller Dorian Lenticular Process
    /// </remarks>
    private static readonly byte[] FilmColorProcess_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x10, 0x01, 0x03, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Film Encryption
    /// </summary>
    /// <remarks>
    /// Content encryption/decryption information for Film
    /// </remarks>
    private static readonly byte[] FilmEncryption = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x09, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Film Gauge
    /// </summary>
    /// <remarks>
    /// Specifies gauge of film stock in mm. Examples: 70mm, 48mm, 16mm, etc.
    /// </remarks>
    private static readonly byte[] FilmFormat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x10, 0x01, 0x03, 0x01, 0x08, 0x00, 0x00];
    /// <summary>
    /// Film Format Name
    /// </summary>
    /// <remarks>
    /// The gauge and format of the film. For example:  Neg;  Blair Viventoscope
    /// </remarks>
    private static readonly byte[] FilmFormatName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x10, 0x01, 0x03, 0x01, 0x04, 0x01, 0x00];
    /// <summary>
    /// Film Format Name
    /// </summary>
    /// <remarks>
    /// The gauge and format of the film. For example:  Neg;  Blair Viventoscope
    /// </remarks>
    private static readonly byte[] FilmFormatName_FilmType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x10, 0x01, 0x03, 0x01, 0x04, 0x02, 0x00];
    /// <summary>
    /// Film Format Name
    /// </summary>
    /// <remarks>
    /// The gauge and format of the film. For example:  Neg;  Blair Viventoscope
    /// </remarks>
    private static readonly byte[] FilmFormatName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x10, 0x01, 0x03, 0x01, 0x04, 0x00, 0x00];
    /// <summary>
    /// Film Frame Rates
    /// </summary>
    /// <remarks>
    /// Frame per second film frame rate
    /// </remarks>
    private static readonly byte[] FilmFrameRates = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x08, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Film Locators
    /// </summary>
    /// <remarks>
    /// Location information for film
    /// </remarks>
    private static readonly byte[] FilmLocators = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Film Medium Parameters
    /// </summary>
    /// <remarks>
    /// Information about the physical film medium
    /// </remarks>
    private static readonly byte[] FilmMediumParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x10, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Film Pulldown Characteristics
    /// </summary>
    /// <remarks>
    /// Film transfer pulldown characteristics
    /// </remarks>
    private static readonly byte[] FilmPulldownCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Film Sound Source
    /// </summary>
    /// <remarks>
    /// Indicates the film sound source
    /// </remarks>
    private static readonly byte[] FilmSoundSource = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Film Stock Kind
    /// </summary>
    /// <remarks>
    /// Example: 5247
    /// </remarks>
    private static readonly byte[] FilmStockKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x10, 0x01, 0x03, 0x01, 0x05, 0x01, 0x00];
    /// <summary>
    /// Film Stock Kind
    /// </summary>
    /// <remarks>
    /// Example: 5247
    /// </remarks>
    private static readonly byte[] FilmStockKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x10, 0x01, 0x03, 0x01, 0x05, 0x00, 0x00];
    /// <summary>
    /// Film Stock Manufacturer Name
    /// </summary>
    /// <remarks>
    /// Example: Kodak, Ilford
    /// </remarks>
    private static readonly byte[] FilmStockManufacturer = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x10, 0x01, 0x03, 0x01, 0x06, 0x01, 0x00];
    /// <summary>
    /// Film Stock Manufacturer Name
    /// </summary>
    /// <remarks>
    /// Example: Kodak, Ilford
    /// </remarks>
    private static readonly byte[] FilmStockManufacturerName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x10, 0x01, 0x03, 0x01, 0x06, 0x00, 0x00];
    /// <summary>
    /// Film Test Parameter
    /// </summary>
    /// <remarks>
    /// eg.  Film Frequency Response;  Telecine Gamma Correction;  Macbeth Color Checker,  Telecine Gray Scale Mirror;  Lab Aim Density;  Lab Aim Density Red/Green/Blue;  Lab Aim Density Red/Green/Blue Dmin;   etc
    /// </remarks>
    private static readonly byte[] FilmTestParameter_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x10, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Film Test Parameters
    /// </summary>
    /// <remarks>
    /// Film test information from the original recording
    /// </remarks>
    private static readonly byte[] FilmTestParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x10, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Film Test Result
    /// </summary>
    /// <remarks>
    /// The result from the specified test
    /// </remarks>
    private static readonly byte[] FilmTestResult = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x10, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Film Test Result
    /// </summary>
    /// <remarks>
    /// The result from the specified test
    /// </remarks>
    private static readonly byte[] FilmTestResult_Int32 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x10, 0x02, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Film-to-Video Characteristics
    /// </summary>
    /// <remarks>
    /// Information about transferring Film to Video
    /// </remarks>
    private static readonly byte[] FilmToVideoCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Filter
    /// </summary>
    /// <remarks>
    /// To define the characteristics of a filter.
    /// </remarks>
    private static readonly byte[] filter = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5E, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Filtering Applied
    /// </summary>
    /// <remarks>
    /// eg, Academy, flat etc
    /// </remarks>
    private static readonly byte[] FilteringApplied_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x01, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Filtering Code
    /// </summary>
    /// <remarks>
    /// Specifies the spectral filtering that has been applied to the digital samples of the video signal.
    /// </remarks>
    private static readonly byte[] FilteringCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x01, 0x0F, 0x00, 0x00, 0x00];
    /// <summary>
    /// Filter Order
    /// </summary>
    /// <remarks>
    /// To define the order of a filter.
    /// </remarks>
    private static readonly byte[] filterOrder = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5E, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Filter Profile Type Group Set
    /// </summary>
    /// <remarks>
    /// To define the profile of a filter.
    /// </remarks>
    private static readonly byte[] filterProfileTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5E, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Filter Setting
    /// </summary>
    /// <remarks>
    /// To define filter settings.
    /// </remarks>
    private static readonly byte[] filterSetting = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5F, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Filter Setting Attribute Order
    /// </summary>
    /// <remarks>
    /// To specify the order of an attribute filter.
    /// </remarks>
    private static readonly byte[] filterSettingAttributeOrder = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5F, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Filter Setting Sets
    /// </summary>
    /// <remarks>
    /// A set of filter settings
    /// </remarks>
    private static readonly byte[] filterSettingObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5E, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Filter Setting Technical anyURI Sets
    /// </summary>
    /// <remarks>
    /// A technical attribute of type anyURI.
    /// </remarks>
    private static readonly byte[] filterSettingTechnicalAttributeAnyURIObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5F, 0x0E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Filter Setting Technical Boolean Sets
    /// </summary>
    /// <remarks>
    /// A technical attribute of type boolean.
    /// </remarks>
    private static readonly byte[] filterSettingTechnicalAttributeBooleanObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5F, 0x0F, 0x00, 0x00, 0x00];
    /// <summary>
    /// Filter Setting Technical Float Sets
    /// </summary>
    /// <remarks>
    /// A technical attribute of type float.
    /// </remarks>
    private static readonly byte[] filterSettingTechnicalAttributeFloatObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5F, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Filter Setting Technical Short Sets
    /// </summary>
    /// <remarks>
    /// A technical attribute of type short.
    /// </remarks>
    private static readonly byte[] filterSettingTechnicalAttributeInt16Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5F, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Filter Setting Technical Integer Sets
    /// </summary>
    /// <remarks>
    /// A technical attribute of type integer.
    /// </remarks>
    private static readonly byte[] filterSettingTechnicalAttributeInt32Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5F, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Filter Setting Technical Long Sets
    /// </summary>
    /// <remarks>
    /// A technical attribute of type long.
    /// </remarks>
    private static readonly byte[] filterSettingTechnicalAttributeInt64Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5F, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Filter Setting Technical Byte Sets
    /// </summary>
    /// <remarks>
    /// A technical attribute of type byte.
    /// </remarks>
    private static readonly byte[] filterSettingTechnicalAttributeInt8Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5F, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Filter Setting Technical Rational Sets
    /// </summary>
    /// <remarks>
    /// A technical attribute of type rational.
    /// </remarks>
    private static readonly byte[] filterSettingTechnicalAttributeRationalObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5F, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Filter Setting Technical String Sets
    /// </summary>
    /// <remarks>
    /// A technical attribute of type string.
    /// </remarks>
    private static readonly byte[] filterSettingTechnicalAttributeStringObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5F, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Filter Setting Technical Unsigned Short Sets
    /// </summary>
    /// <remarks>
    /// A technical attribute of type unsigned short.
    /// </remarks>
    private static readonly byte[] filterSettingTechnicalAttributeUInt16Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5F, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Filter Setting Technical Unsigned Integer Sets
    /// </summary>
    /// <remarks>
    /// A technical attribute of type unsigned integer.
    /// </remarks>
    private static readonly byte[] filterSettingTechnicalAttributeUInt32Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5F, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Filter Setting Technical Unsigned Long Sets
    /// </summary>
    /// <remarks>
    /// A technical attribute of type unsigned long.
    /// </remarks>
    private static readonly byte[] filterSettingTechnicalAttributeUInt64Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5F, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Filter Setting Technical Unsigned Byte Sets
    /// </summary>
    /// <remarks>
    /// A technical attribute of type unsigned byte.
    /// </remarks>
    private static readonly byte[] filterSettingTechnicalAttributeUInt8Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5F, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Filter Setting Type group Set
    /// </summary>
    /// <remarks>
    /// To define a type of filter setting.
    /// </remarks>
    private static readonly byte[] filterSettingTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5F, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Filter Track IDRef Sets
    /// </summary>
    /// <remarks>
    /// A set of reference to track to shich the filter applies.
    /// </remarks>
    private static readonly byte[] filterTrackIDRefObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5E, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Filter Type Group Set
    /// </summary>
    /// <remarks>
    /// To define a tyoe of filter.
    /// </remarks>
    private static readonly byte[] filterTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5E, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Financial Information
    /// </summary>
    /// <remarks>
    /// Details of payments, costs, income money and other considerations
    /// </remarks>
    private static readonly byte[] FinancialInformation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// First Broadcast Flag
    /// </summary>
    /// <remarks>
    /// First broadcast of the product
    /// </remarks>
    private static readonly byte[] FirstBroadcastFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x20, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// First Frame
    /// </summary>
    /// <remarks>
    /// Specifies an edit unit for alignment with the FFOA of the picture track
    /// </remarks>
    private static readonly byte[] FirstFrame = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x0E, 0x09, 0x05, 0x0A, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// First Given Name
    /// </summary>
    /// <remarks>
    /// The first given name for an individual
    /// </remarks>
    private static readonly byte[] FirstGivenName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x30, 0x06, 0x03, 0x01, 0x02, 0x01, 0x00];
    /// <summary>
    /// First Given Name
    /// </summary>
    /// <remarks>
    /// The first given name for an individual
    /// </remarks>
    private static readonly byte[] FirstGivenName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x06, 0x03, 0x01, 0x02, 0x00, 0x00];
    /// <summary>
    /// First Number in Sequence
    /// </summary>
    /// <remarks>
    /// The first number in a sequence
    /// </remarks>
    private static readonly byte[] FirstNumberInSequence = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x10, 0x10, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// First Number in Sequence
    /// </summary>
    /// <remarks>
    /// The first number in a sequence
    /// </remarks>
    private static readonly byte[] FirstNumberInSequence_UInt32 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x10, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// First Showing Flag
    /// </summary>
    /// <remarks>
    /// A flag to identify a first publication ('True' if set to '1')
    /// </remarks>
    private static readonly byte[] firstShowingFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1C, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// First Transmission Date-Time, Channel, and Broadcaster
    /// </summary>
    /// <remarks>
    /// Indicates the first broadcast date-time, the broadcast channel and broadcaster of the program as a text string
    /// </remarks>
    private static readonly byte[] FirstTransmissionDateTimeChannelAndBroadcaster = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x06, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Fixed Array Element Type
    /// </summary>
    /// <remarks>
    /// Specifies a reference to the underlying type used in the fixed array type
    /// </remarks>
    private static readonly byte[] FixedArrayElementType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x07, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Fixed Channel Status Data
    /// </summary>
    /// <remarks>
    /// AES3 Fixed data pattern for channel status data
    /// </remarks>
    private static readonly byte[] FixedChannelStatusData = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x05, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Fixed User Data
    /// </summary>
    /// <remarks>
    /// AES3 Fixed data pattern for user data
    /// </remarks>
    private static readonly byte[] FixedUserData = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x05, 0x01, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Edit Unit Flags
    /// </summary>
    /// <remarks>
    /// Flags to indicate coding of elements in this edit unit
    /// </remarks>
    private static readonly byte[] Flags = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x04, 0x04, 0x04, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// FLIR Systems, Inc.
    /// </summary>
    /// <remarks>
    /// Metadata registered by FLIR Systems, Inc. for private use
    /// </remarks>
    private static readonly byte[] FLIR = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x0E, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Focal Length
    /// </summary>
    /// <remarks>
    /// Focal length of the lens in millimeters at time of collection.
    /// </remarks>
    private static readonly byte[] FocalLength = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x20, 0x02, 0x01, 0x01, 0x04, 0x01, 0x00];
    /// <summary>
    /// Focal Length
    /// </summary>
    /// <remarks>
    /// Focal length of the lens at time of capture
    /// </remarks>
    private static readonly byte[] FocalLength_Float = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x20, 0x02, 0x01, 0x01, 0x04, 0x00, 0x00];
    /// <summary>
    /// Focus Position From Front Lens Vertex
    /// </summary>
    /// <remarks>
    /// Distance in meters between the front of the lens and the object in focus
    /// </remarks>
    private static readonly byte[] FocusPositionFromFrontLensVertex = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x02, 0x02, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Focus Position From Image Plane
    /// </summary>
    /// <remarks>
    /// Distance in meters between the image plane and the object in focus
    /// </remarks>
    private static readonly byte[] FocusPositionFromImagePlane = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Focus Ring Position
    /// </summary>
    /// <remarks>
    /// Focus ring rotation angle in unsigned integer. 0 is for near-end, FFFFh for infinity
    /// </remarks>
    private static readonly byte[] FocusRingPosition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x02, 0x02, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Following Index Table
    /// </summary>
    /// <remarks>
    /// Specifies whether a Complete Index Table is in a partition following all Essence that it indexes.
    /// </remarks>
    private static readonly byte[] FollowingIndexTable = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x04, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Follows In Sequence
    /// </summary>
    /// <remarks>
    /// A resource that the current resource follows in a sequence
    /// </remarks>
    private static readonly byte[] followsInSequence = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x02, 0x14, 0x00, 0x00];
    /// <summary>
    /// Footer Partition
    /// </summary>
    /// <remarks>
    /// The number of the Footer Partition (as a byte offset relative to the start of the Header Partition)
    /// </remarks>
    private static readonly byte[] FooterPartition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x10, 0x10, 0x05, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format
    /// </summary>
    /// <remarks>
    /// A set of attributes to provide structural metadata defining the format of material associated with a resource
    /// </remarks>
    private static readonly byte[] format = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Audio Format Extended Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to extended audio format objects
    /// </remarks>
    private static readonly byte[] formatAudioFormatExtendedObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x21, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Audio  Format  Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong reference to an audioFormat object
    /// </remarks>
    private static readonly byte[] formatAudioFormatObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Characteristics
    /// </summary>
    /// <remarks>
    /// Specifies formatting used in laying down the essence onto physical media
    /// </remarks>
    private static readonly byte[] FormatCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Container Format  Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a container format object
    /// </remarks>
    private static readonly byte[] formatContainerFormatObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Data  Format  Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong reference to a dataFormat object
    /// </remarks>
    private static readonly byte[] formatDataFormatObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x0F, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Date Created
    /// </summary>
    /// <remarks>
    /// The date when this format was defined for the first time
    /// </remarks>
    private static readonly byte[] formatDateCreated = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Modified Date
    /// </summary>
    /// <remarks>
    /// A strong reference to a date when the format definition was modified
    /// </remarks>
    private static readonly byte[] formatDateModifiedObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x1E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Definition
    /// </summary>
    /// <remarks>
    /// A definition associated with the format
    /// </remarks>
    private static readonly byte[] formatDefinition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Descriptor
    /// </summary>
    /// <remarks>
    /// eg. Letterbox, Pillarbox etc
    /// </remarks>
    private static readonly byte[] FormatDescriptor = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x01, 0x06, 0x05, 0x01, 0x00, 0x00];
    /// <summary>
    /// Format Descriptor
    /// </summary>
    /// <remarks>
    /// eg. Letterbox, Pillarbox etc
    /// </remarks>
    private static readonly byte[] FormatDescriptor_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x01, 0x06, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Duration Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to time objects
    /// </remarks>
    private static readonly byte[] formatDurationTimeObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x24, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Edit Rate Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a rational object to express an edit rate
    /// </remarks>
    private static readonly byte[] formatEditRateObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format End Time Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to time objects
    /// </remarks>
    private static readonly byte[] formatEndTimeObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x23, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Group
    /// </summary>
    /// <remarks>
    /// A set of attributes used to define a format
    /// </remarks>
    private static readonly byte[] formatGroup = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format  Group Definition
    /// </summary>
    /// <remarks>
    /// A definition associated with the term
    /// </remarks>
    private static readonly byte[] formatGroupDefinition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x02, 0x05, 0x00, 0x00];
    /// <summary>
    /// Format  Group Label
    /// </summary>
    /// <remarks>
    /// A universal label or free text to express the format
    /// </remarks>
    private static readonly byte[] formatGroupLabel = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x02, 0x02, 0x00, 0x00];
    /// <summary>
    /// Format  Group Language Code
    /// </summary>
    /// <remarks>
    /// The BCP-47 code of the language used to express the term
    /// </remarks>
    private static readonly byte[] formatGroupLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x02, 0x06, 0x00, 0x00];
    /// <summary>
    /// Format Group Link
    /// </summary>
    /// <remarks>
    /// A link to a term in a classification scheme
    /// </remarks>
    private static readonly byte[] formatGroupLink = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x02, 0x03, 0x00, 0x00];
    /// <summary>
    /// Format Group Namespace
    /// </summary>
    /// <remarks>
    /// The namespace of the classification scheme
    /// </remarks>
    private static readonly byte[] formatGroupNamespace = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x02, 0x07, 0x00, 0x00];
    /// <summary>
    /// Format Group Source
    /// </summary>
    /// <remarks>
    /// The authority who has provided the classification scheme of free text term
    /// </remarks>
    private static readonly byte[] formatGroupSource = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x02, 0x08, 0x00, 0x00];
    /// <summary>
    /// Format  Group Thesaurus
    /// </summary>
    /// <remarks>
    /// The thesaurus from which the format originates
    /// </remarks>
    private static readonly byte[] formatGroupThesaurus = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Format  Group UL
    /// </summary>
    /// <remarks>
    /// A UL to a label in the label register
    /// </remarks>
    private static readonly byte[] formatGroupUL = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x02, 0x04, 0x00, 0x00];
    /// <summary>
    /// Format ID
    /// </summary>
    /// <remarks>
    /// An identifier attributed to the format
    /// </remarks>
    private static readonly byte[] formatID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Image  Format  Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong reference to a imageFormat object
    /// </remarks>
    private static readonly byte[] formatImageFormatObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x0E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Medium Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a medium object
    /// </remarks>
    private static readonly byte[] formatMediumObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Medium Sets
    /// </summary>
    /// <remarks>
    /// To list the different medium in which the media resource is available.
    /// </remarks>
    private static readonly byte[] formatMediumObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x27, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Metadata Format Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to metadata format objects
    /// </remarks>
    private static readonly byte[] formatMetadataFormatObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x25, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Name
    /// </summary>
    /// <remarks>
    /// A name attributed to the format
    /// </remarks>
    private static readonly byte[] formatName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format  Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to one or more formats in which the resource exists
    /// </remarks>
    private static readonly byte[] formatObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x02, 0x14, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Overall Duration Set
    /// </summary>
    /// <remarks>
    /// The overall duration of the material
    /// </remarks>
    private static readonly byte[] formatOverallDurationTimeObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Package Info Set
    /// </summary>
    /// <remarks>
    /// A string reference to a package info object
    /// </remarks>
    private static readonly byte[] formatPackageInfoObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Signing  Format  Sets
    /// </summary>
    /// <remarks>
    /// A batch of  strong reference to a signingFormat object
    /// </remarks>
    private static readonly byte[] formatSigningFormatObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Start Time Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to time objects
    /// </remarks>
    private static readonly byte[] formatStartTimeObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x22, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Technical Attribute AnyURI Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type AnyURI
    /// </remarks>
    private static readonly byte[] formatTechnicalAttributeAnyURIObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x1C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Technical Attribute Boolean Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Boolean
    /// </remarks>
    private static readonly byte[] formatTechnicalAttributeBooleanObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x1D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Technical Attribute Float Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Float
    /// </remarks>
    private static readonly byte[] formatTechnicalAttributeFloatObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x1A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Technical Attribute Int16 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int16
    /// </remarks>
    private static readonly byte[] formatTechnicalAttributeInt16Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x13, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Technical Attribute Int32 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int32
    /// </remarks>
    private static readonly byte[] formatTechnicalAttributeInt32Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x14, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Technical Attribute Int64 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int64
    /// </remarks>
    private static readonly byte[] formatTechnicalAttributeInt64Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x15, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Technical Attribute Int8 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int8
    /// </remarks>
    private static readonly byte[] formatTechnicalAttributeInt8Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x12, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Technical Attribute Rational Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Rational
    /// </remarks>
    private static readonly byte[] formatTechnicalAttributeRationalObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x1B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Technical Attribute String Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type string
    /// </remarks>
    private static readonly byte[] formatTechnicalAttributeStringObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x11, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Technical Attribute UInt16 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt16
    /// </remarks>
    private static readonly byte[] formatTechnicalAttributeUInt16Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x17, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Technical Attribute UInt32 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt32
    /// </remarks>
    private static readonly byte[] formatTechnicalAttributeUInt32Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x18, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Technical Attribute UInt64 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt64
    /// </remarks>
    private static readonly byte[] formatTechnicalAttributeUInt64Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x19, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Technical Attribute UInt8 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt8
    /// </remarks>
    private static readonly byte[] formatTechnicalAttributeUInt8Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x16, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Duration Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to timecode format objects
    /// </remarks>
    private static readonly byte[] formatTimecodeFormatObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x26, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a type group to define the type of format being described
    /// </remarks>
    private static readonly byte[] formatTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x20, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Value Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a Value defining the format as free text
    /// </remarks>
    private static readonly byte[] formatValueObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x1F, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Version
    /// </summary>
    /// <remarks>
    /// Specifies the version of the specification of the format
    /// </remarks>
    private static readonly byte[] FormatVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x02, 0x01, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Version ID
    /// </summary>
    /// <remarks>
    /// An identifier attributed to a version of the format
    /// </remarks>
    private static readonly byte[] formatVersionID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Video  Format  Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong reference to a videoFormat object
    /// </remarks>
    private static readonly byte[] formatVideoFormatObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Format Year Created
    /// </summary>
    /// <remarks>
    /// The year when this format was defined for the first time
    /// </remarks>
    private static readonly byte[] formatYearCreated = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x30, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Former Family Name
    /// </summary>
    /// <remarks>
    /// Former name of an individual (e.g. maiden name)
    /// </remarks>
    private static readonly byte[] FormerFamilyName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x02, 0x30, 0x06, 0x03, 0x01, 0x0C, 0x01, 0x00];
    /// <summary>
    /// Former Family Name
    /// </summary>
    /// <remarks>
    /// Former name of an individual (e.g. maiden name)
    /// </remarks>
    private static readonly byte[] FormerFamilyName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x02, 0x30, 0x06, 0x03, 0x01, 0x0C, 0x00, 0x00];
    /// <summary>
    /// Forward Index Direction
    /// </summary>
    /// <remarks>
    /// Specifies whether the Index Table Segments are pointing forward or backward.
    /// </remarks>
    private static readonly byte[] ForwardIndexDirection = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x04, 0x05, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Fraction Bright Pixels
    /// </summary>
    /// <remarks>
    /// Fraction of pixels that contains the brightest pixel
    /// </remarks>
    private static readonly byte[] FractionBrightPixels = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x3E, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Frame Center Elevation
    /// </summary>
    /// <remarks>
    /// The elevation of field of view frame center, measured in meters above WGS-84 spheroid
    /// </remarks>
    private static readonly byte[] FrameCenterElevation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x07, 0x01, 0x02, 0x01, 0x03, 0x16, 0x00, 0x00];
    /// <summary>
    /// Frame Center Latitude
    /// </summary>
    /// <remarks>
    /// Specifies the video frame center point geographic location in decimal degrees of latitude.  Positive values indicate northern hemisphere; negative values indicate southern hemisphere.
    /// </remarks>
    private static readonly byte[] FrameCenterLatitude = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x01, 0x03, 0x02, 0x00, 0x00];
    /// <summary>
    /// Frame Center Latitude
    /// </summary>
    /// <remarks>
    /// Specifies the video frame center point geographic location in decimal degrees of latitude.
    /// </remarks>
    private static readonly byte[] FrameCenterLatitude02 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x02, 0x01, 0x03, 0x02, 0x02, 0x00];
    /// <summary>
    /// Frame Center Latitude (Degrees, Concise)
    /// </summary>
    /// <remarks>
    /// Specifies the video frame center point geographic location in decimal degrees of latitude.  Positive values indicate northern hemisphere; negative values indicate southern hemisphere.
    /// </remarks>
    private static readonly byte[] FrameCenterLatitudeDegreesConcise = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x01, 0x03, 0x03, 0x00, 0x00];
    /// <summary>
    /// Frame Center Latitude-Longitude
    /// </summary>
    /// <remarks>
    /// Specifies a video frame center point geographic location Latitude and Longitude.
    /// </remarks>
    private static readonly byte[] FrameCenterLatLong = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x01, 0x03, 0x06, 0x00, 0x00];
    /// <summary>
    /// Frame Center Longitude
    /// </summary>
    /// <remarks>
    /// Specifies the video frame center point geographic location in decimal degrees of longitude.  Positive values indicate eastern hemisphere; negative values indicate western hemisphere.
    /// </remarks>
    private static readonly byte[] FrameCenterLongitude = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x01, 0x03, 0x04, 0x00, 0x00];
    /// <summary>
    /// Frame Center Longitude
    /// </summary>
    /// <remarks>
    /// Specifies the video frame center point geographic location in decimal degrees of longitude.
    /// </remarks>
    private static readonly byte[] FrameCenterLongitude02 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x02, 0x01, 0x03, 0x04, 0x02, 0x00];
    /// <summary>
    /// Frame Center Longitude (Degrees, Concise)
    /// </summary>
    /// <remarks>
    /// Specifies the video frame center point geographic location in decimal degrees of longitude.  Positive values indicate eastern hemisphere; negative values indicate western hemisphere.
    /// </remarks>
    private static readonly byte[] FrameCenterLongitudeDegreesConcise = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x01, 0x03, 0x05, 0x00, 0x00];
    /// <summary>
    /// Frame Code
    /// </summary>
    /// <remarks>
    /// Unique frame number for film
    /// </remarks>
    private static readonly byte[] FrameCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x07, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Frame Count
    /// </summary>
    /// <remarks>
    /// Length of the segment, shot, clip, item etc in frames.
    /// </remarks>
    private static readonly byte[] FrameCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Frame Count Offset
    /// </summary>
    /// <remarks>
    /// Offset of the content from a given timecode in timecode frames.
    /// </remarks>
    private static readonly byte[] FrameCountOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x03, 0x10, 0x01, 0x01, 0x00];
    /// <summary>
    /// Frame Layout
    /// </summary>
    /// <remarks>
    /// Specifies frame layout (interlaced, single frame, full frame, etc.)
    /// </remarks>
    private static readonly byte[] FrameLayout = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x03, 0x01, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Frame Positional Accuracy
    /// </summary>
    /// <remarks>
    /// Accuracy of frame center coordinates as a Circular Error Probable (CEP) (50%),  (default metres)
    /// </remarks>
    private static readonly byte[] FramePositionalAccuracy = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x01, 0x03, 0x01, 0x00, 0x00];
    /// <summary>
    /// Rounded Capture Film Frame Rate
    /// </summary>
    /// <remarks>
    /// Specifies the film frame rate, rounded to the nearest whole number
    /// </remarks>
    private static readonly byte[] FrameRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x01, 0x08, 0x02, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Frame Rate
    /// </summary>
    /// <remarks>
    /// The rate that video images are captured, expressed in frames per second.
    /// </remarks>
    private static readonly byte[] FrameRate_UInt16 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x03, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rounded Timecode Timebase
    /// </summary>
    /// <remarks>
    /// eg. 24, 25, 30, 48, 60
    /// </remarks>
    private static readonly byte[] FramesPerSecond = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x04, 0x01, 0x01, 0x02, 0x06, 0x00, 0x00];
    /// <summary>
    /// Framework Extended Text Language Code
    /// </summary>
    /// <remarks>
    /// The RFC-3066-compliant code that specifies the base ISO code for the language as well as regional and script variant information of the text in this set and the default language code of all sets contained in this framework
    /// </remarks>
    private static readonly byte[] FrameworkExtendedTextLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x01, 0x02, 0x02, 0x13, 0x00, 0x00];
    /// <summary>
    /// Framework Text Language Code
    /// </summary>
    /// <remarks>
    /// The ISO language code of the text in this set and the default language code of all sets contained in this framework
    /// </remarks>
    private static readonly byte[] FrameworkTextLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x01, 0x01, 0x02, 0x02, 0x03, 0x00, 0x00];
    /// <summary>
    /// Framework Thesaurus Name
    /// </summary>
    /// <remarks>
    /// The name of the default specialized vocabulary of selected words or concepts for a particular field used in a framework, e.g. a particular cataloguing, indexing or thesaurus system
    /// </remarks>
    private static readonly byte[] FrameworkThesaurusName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x02, 0x01, 0x02, 0x15, 0x01, 0x00, 0x00];
    /// <summary>
    /// Framework Thesaurus Name
    /// </summary>
    /// <remarks>
    /// The name of the default specialized vocabulary of selected words or concepts for a particular field used in a framework, e.g. a particular cataloguing, indexing or thesaurus system
    /// </remarks>
    private static readonly byte[] FrameworkThesaurusName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x02, 0x01, 0x02, 0x15, 0x00, 0x00, 0x00];
    /// <summary>
    /// Framework Title
    /// </summary>
    /// <remarks>
    /// A human readable title for this instance of the Production Framework (e.g. "Wilco Productions version 3")
    /// </remarks>
    private static readonly byte[] FrameworkTitle = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x05, 0x0F, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Framework Title
    /// </summary>
    /// <remarks>
    /// A human readable title for this instance of the Production Framework (e.g. "Wilco Productions version 3")
    /// </remarks>
    private static readonly byte[] FrameworkTitle_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x05, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Fraunhofer
    /// </summary>
    /// <remarks>
    /// Metadata registered by Fraunhofer for private use
    /// </remarks>
    private static readonly byte[] Fraunhofer = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x0E, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Free Publication Flag
    /// </summary>
    /// <remarks>
    /// A flag to identify a freely accessible publication ('True' if set to '1')
    /// </remarks>
    private static readonly byte[] freePublicationFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1C, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Fundamental
    /// </summary>
    /// <remarks>
    /// Fundamental defining information
    /// </remarks>
    private static readonly byte[] Fundamental = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Fundamental  Audio Characteristics
    /// </summary>
    /// <remarks>
    /// Fundamental audio characteristics
    /// </remarks>
    private static readonly byte[] FundamentalAudioCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Fundamental Data Essence Parameters
    /// </summary>
    /// <remarks>
    /// Fundamental data essence characteristics
    /// </remarks>
    private static readonly byte[] FundamentalDataEssenceParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Fundamental Dimensions
    /// </summary>
    /// <remarks>
    /// Information about the four basic indefinables of natural philosophy
    /// </remarks>
    private static readonly byte[] FundamentalDimensions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Fundamental Image Characteristics
    /// </summary>
    /// <remarks>
    /// Fundamental characteristics of the image
    /// </remarks>
    private static readonly byte[] FundamentalImageCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Fundamental Metadata Characteristics
    /// </summary>
    /// <remarks>
    /// Fundamental Metadata characteristics
    /// </remarks>
    private static readonly byte[] FundamentalMetadataCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Fundamental Monitoring and Control Characteristics
    /// </summary>
    /// <remarks>
    /// Fundamental Monitoring and Control characteristics
    /// </remarks>
    private static readonly byte[] FundamentalMonitoringAndControlCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Gain Interact
    /// </summary>
    /// <remarks>
    /// Set to true to allow gain interaction.
    /// </remarks>
    private static readonly byte[] gainInteract = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x64, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Gain Interaction Range
    /// </summary>
    /// <remarks>
    /// To specify the supported range of gain interaction.
    /// </remarks>
    private static readonly byte[] gainInteractionRange = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x65, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Gain Interaction Range Bound
    /// </summary>
    /// <remarks>
    /// Set attribute to "min" to provide minimum gain factor of possible user gain interaction (gainMin = gain (or 1.0 if not defined) * gainInteractionRangeMin) Set attribute to "max" to provide maximum gain factor of possible user gain interaction gainMax = gain (or 1.0 if not defined) * gainInteractionRangeMin)
    /// </remarks>
    private static readonly byte[] gainInteractionRangeBound = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x65, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Gain Interact Range Sets
    /// </summary>
    /// <remarks>
    /// Set the range of gain values allowed for interaction.
    /// </remarks>
    private static readonly byte[] gainInteractionRangeObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x64, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Gain Interaction Range Value
    /// </summary>
    /// <remarks>
    /// Value defining the range of gain.
    /// </remarks>
    private static readonly byte[] gainInteractionRangeValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x65, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Gamma for CDL
    /// </summary>
    /// <remarks>
    /// Enumerated code that represents the gamma characteristic applied at the input to the ASC CDL.
    /// </remarks>
    private static readonly byte[] GammaForCDL = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x01, 0x03, 0x02, 0x07, 0x00, 0x00];
    /// <summary>
    /// Gender Set
    /// </summary>
    /// <remarks>
    /// An attribute to facilitate search on a particular gender, i.e. male or female.optionally in different languages
    /// </remarks>
    private static readonly byte[] genderObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x22, 0x0E, 0x00, 0x00, 0x00];
    /// <summary>
    /// General Coding Characteristics
    /// </summary>
    /// <remarks>
    /// Characteristics that apply to more than one type of essence or metadata
    /// </remarks>
    private static readonly byte[] GeneralCodingCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// General Comments
    /// </summary>
    /// <remarks>
    /// Note form technical comments and descriptions of a general nature
    /// </remarks>
    private static readonly byte[] GeneralComments = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// General Data Coding Characteristics
    /// </summary>
    /// <remarks>
    /// Characteristics that apply to any type of data
    /// </remarks>
    private static readonly byte[] GeneralDataCodingCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x04, 0x06, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// General Dates and Times
    /// </summary>
    /// <remarks>
    /// General information about dates and times
    /// </remarks>
    private static readonly byte[] GeneralDatesAndTimes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// General Date-Time Coding Characteristics
    /// </summary>
    /// <remarks>
    /// Coding Characteristics of time and date metadata
    /// </remarks>
    private static readonly byte[] GeneralDateTimeCodingCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x04, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// General Essence and Data Parameters
    /// </summary>
    /// <remarks>
    /// Specifies information relating to the essence and data
    /// </remarks>
    private static readonly byte[] GeneralEssenceAndDataParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// General Essence Coding Characteristics
    /// </summary>
    /// <remarks>
    /// Characteristics that apply to more than one type of essence
    /// </remarks>
    private static readonly byte[] GeneralEssenceCodingCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// General Essence Container Characteristics
    /// </summary>
    /// <remarks>
    /// Characteristics that apply to Essence Containers
    /// </remarks>
    private static readonly byte[] GeneralEssenceContainerCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x04, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// General Metadata Coding Characteristics
    /// </summary>
    /// <remarks>
    /// Characteristics that apply to more than one type of metadata
    /// </remarks>
    private static readonly byte[] GeneralMetadataCodingCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x04, 0x06, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// General Metadata Container Characteristics
    /// </summary>
    /// <remarks>
    /// Characteristics that apply to metadata Containers
    /// </remarks>
    private static readonly byte[] GeneralMetadataContainerCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x04, 0x06, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// General Organization Identifiers
    /// </summary>
    /// <remarks>
    /// Unique Identifiers for Organizations
    /// </remarks>
    private static readonly byte[] GeneralOrganizationIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x01, 0x0A, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// General Process Indicators
    /// </summary>
    /// <remarks>
    /// Flags etc indicating the process status of the essence
    /// </remarks>
    private static readonly byte[] GeneralProcessIndicators = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// General Processing Parameters
    /// </summary>
    /// <remarks>
    /// Parameters of a general nature required for processing
    /// </remarks>
    private static readonly byte[] GeneralProcessingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// General Publication
    /// </summary>
    /// <remarks>
    /// General publishing details
    /// </remarks>
    private static readonly byte[] GeneralPublication = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x10, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Generation Clone Number
    /// </summary>
    /// <remarks>
    /// A number that should be incremented by one for each numerically lossless generation from the source where the original source has a value of zero
    /// </remarks>
    private static readonly byte[] GenerationCloneNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x05, 0x01, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Generation Copy Number
    /// </summary>
    /// <remarks>
    /// A number that should be incremented by one for each numerically lossy  generation from the source where the original source has a value of zero
    /// </remarks>
    private static readonly byte[] GenerationCopyNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x05, 0x01, 0x03, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Generation ID
    /// </summary>
    /// <remarks>
    /// Specifies the reference to a particular modification.
    /// </remarks>
    private static readonly byte[] GenerationID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x07, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Generation Status
    /// </summary>
    /// <remarks>
    /// Generation Status
    /// </remarks>
    private static readonly byte[] GenerationStatus = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x23, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Generic Film Medium Parameters
    /// </summary>
    /// <remarks>
    /// Generic Information about the film medium
    /// </remarks>
    private static readonly byte[] GenericFilmMediumParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x10, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Generic Identifiers
    /// </summary>
    /// <remarks>
    /// Unique Identifiers for non-Broadcasting Organizations
    /// </remarks>
    private static readonly byte[] GenericIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Generic Object Names
    /// </summary>
    /// <remarks>
    /// Descriptive names assigned to Generic Objects
    /// </remarks>
    private static readonly byte[] GenericObjectNames = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x04, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Generic Payloads
    /// </summary>
    /// <remarks>
    /// A Batch of Universal Labels of all the Generic Payloads used in this file.
    /// </remarks>
    private static readonly byte[] GenericPayloads = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x06, 0x01, 0x01, 0x04, 0x03, 0x06, 0x00, 0x00];
    /// <summary>
    /// Generic Relationships
    /// </summary>
    /// <remarks>
    /// Specifies relationships which are generic between items
    /// </remarks>
    private static readonly byte[] GenericRelationships = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Generic Stream ID
    /// </summary>
    /// <remarks>
    /// Stream ID of the linked Generic Stream payload
    /// </remarks>
    private static readonly byte[] GenericStreamID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x03, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Genre
    /// </summary>
    /// <remarks>
    /// Programme genre (e.g., entertainment, current affairs magasine, Italo Western, ...)
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] Genre_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x01, 0x01, 0x03, 0x01, 0x00, 0x00];
    /// <summary>
    /// Genre
    /// </summary>
    /// <remarks>
    /// The genre of the resource, e.g. news, drama, sport
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] Genre_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x10, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Genre
    /// </summary>
    /// <remarks>
    /// Programme genre (e.g., entertainment, current affairs magasine, Italo Western, ...)
    /// </remarks>
    private static readonly byte[] Genre_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Genre Level
    /// </summary>
    /// <remarks>
    /// An optional level of ranking associated with genre in case several values are provided for a resource
    /// </remarks>
    private static readonly byte[] genreLevel = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x10, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Genre Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to one or more genres associated with the resource
    /// </remarks>
    private static readonly byte[] genreObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0E, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Genre Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group e.g. for reference to a classification scheme
    /// </remarks>
    private static readonly byte[] genreTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x10, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Geographic Location
    /// </summary>
    /// <remarks>
    /// Geographic rectangle specified by at least 3 corner points, coordinate system and datum
    /// </remarks>
    private static readonly byte[] Geographic_Location = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x07, 0x01, 0x02, 0x01, 0x03, 0x10, 0x00, 0x00];
    /// <summary>
    /// Geographical Coordinates
    /// </summary>
    /// <remarks>
    /// Geographic coordinates of an address as a 12-byte spatial coordinate component as defined in SMPTE 330M-2003
    /// </remarks>
    private static readonly byte[] GeographicalCoordinates = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x15, 0x00];
    /// <summary>
    /// Geographic Area Northwest
    /// </summary>
    /// <remarks>
    /// The geographic coordinate of the NorthWest corner of a rectangle (measured in milliarcseconds relative to the datum)
    /// </remarks>
    private static readonly byte[] GeographicArea_NorthWest = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x07, 0x01, 0x02, 0x01, 0x03, 0x12, 0x00, 0x00];
    /// <summary>
    /// Geographic Area Source Datum
    /// </summary>
    /// <remarks>
    /// The code for the datum point for a Geographic Area
    /// </remarks>
    private static readonly byte[] GeographicArea_SourceDatum = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x07, 0x01, 0x02, 0x01, 0x03, 0x14, 0x00, 0x00];
    /// <summary>
    /// Geographic Area Southeast
    /// </summary>
    /// <remarks>
    /// The geographic coordinate of the SouthEast corner of a rectangle (measured in milliarcseconds relative to the datum)
    /// </remarks>
    private static readonly byte[] GeographicArea_SouthEast = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x07, 0x01, 0x02, 0x01, 0x03, 0x13, 0x00, 0x00];
    /// <summary>
    /// Geographic Polygon Coordinates
    /// </summary>
    /// <remarks>
    /// A vector of geographic coordinates (measured in milliarcseconds relative to the datum)
    /// </remarks>
    private static readonly byte[] GeographicPolygon_Coords = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x07, 0x01, 0x02, 0x01, 0x03, 0x11, 0x00, 0x00];
    /// <summary>
    /// Geographic Polygon Source Datum
    /// </summary>
    /// <remarks>
    /// The code for the datum point for a Geographic Polygon
    /// </remarks>
    private static readonly byte[] GeographicPolygon_SourceDatum = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x07, 0x01, 0x02, 0x01, 0x03, 0x15, 0x00, 0x00];
    /// <summary>
    /// getCertificate Status
    /// </summary>
    /// <remarks>
    /// Error Code
    /// </remarks>
    private static readonly byte[] getCertificateStatus = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// getCPLValidationResult Status
    /// </summary>
    /// <remarks>
    /// Error Code
    /// </remarks>
    private static readonly byte[] getCPLValidationResultStatus = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x12, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// getKDMValidationResult Status
    /// </summary>
    /// <remarks>
    /// Error Code
    /// </remarks>
    private static readonly byte[] getKDMValidationResultStatus = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x17, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// getSecureTime Status
    /// </summary>
    /// <remarks>
    /// Error Code
    /// </remarks>
    private static readonly byte[] getSecureTimeStatus = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x0C, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Given Name
    /// </summary>
    /// <remarks>
    /// The first given name
    /// </remarks>
    private static readonly byte[] givenName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x22, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Globally Unique Human Identifiers
    /// </summary>
    /// <remarks>
    /// Globally Unique Human Identifiers
    /// </remarks>
    private static readonly byte[] GloballyUniqueHumanIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x01, 0x01, 0x15, 0x40, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Globally Unique Identifiers
    /// </summary>
    /// <remarks>
    /// Unique identifiers and locators
    /// </remarks>
    private static readonly byte[] GloballyUniqueIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Globally Unique Locators
    /// </summary>
    /// <remarks>
    /// Globally Unique path definitions
    /// </remarks>
    private static readonly byte[] GloballyUniqueLocators = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Globally Unique Object Identifiers
    /// </summary>
    /// <remarks>
    /// Globally Unique Object Identifiers
    /// </remarks>
    private static readonly byte[] GloballyUniqueObjectIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x01, 0x01, 0x15, 0x40, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Global Number
    /// </summary>
    /// <remarks>
    /// Organizationally-given global number used to identify subjects in the image
    /// </remarks>
    private static readonly byte[] GlobalNumber_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x15, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Graphic Kind
    /// </summary>
    /// <remarks>
    /// The type of a graphic as a name - eg modified still, graphic image
    /// </remarks>
    private static readonly byte[] GraphicKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Graphic Usage Kind
    /// </summary>
    /// <remarks>
    /// The type of usage for which a graphic is intended - e.g title sequence, overlay.
    /// </remarks>
    private static readonly byte[] GraphicUsage = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x05, 0x01, 0x01, 0x07, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Graphic Usage Kind
    /// </summary>
    /// <remarks>
    /// The type of usage for which a graphic is intended - e.g title sequence, overlay.
    /// </remarks>
    private static readonly byte[] GraphicUsageKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Grass Valley, Inc.
    /// </summary>
    /// <remarks>
    /// Metadata registered by Grass Valley, Inc. for private use
    /// </remarks>
    private static readonly byte[] GrassValleyInc = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x0E, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Group Names
    /// </summary>
    /// <remarks>
    /// Name information for groups
    /// </remarks>
    private static readonly byte[] GroupNames = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x06, 0x03, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Group of Soundfield Groups Link ID
    /// </summary>
    /// <remarks>
    /// MCA Link IDs of the Group of Soundfield Groups to which this Soundfield Group belongs
    /// </remarks>
    private static readonly byte[] GroupOfSoundfieldGroupsLinkID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x01, 0x03, 0x07, 0x01, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Group Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Group sets
    /// </remarks>
    private static readonly byte[] GroupRelationshipObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x05, 0x00];
    /// <summary>
    /// Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a Group set
    /// </remarks>
    private static readonly byte[] GroupSet = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x02, 0x40, 0x05, 0x00];
    /// <summary>
    /// Group Synopsis
    /// </summary>
    /// <remarks>
    /// Synopsis of the group, series, serial etc.
    /// </remarks>
    private static readonly byte[] GroupSynopsis = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x02, 0x01, 0x06, 0x08, 0x01, 0x00, 0x00];
    /// <summary>
    /// Group Synopsis
    /// </summary>
    /// <remarks>
    /// Synopsis of the group, series, serial etc.
    /// </remarks>
    private static readonly byte[] GroupSynopsis_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x02, 0x01, 0x06, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Guest Flag
    /// </summary>
    /// <remarks>
    /// A flag to indicate if the contact/person is a guest
    /// </remarks>
    private static readonly byte[] guestFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x22, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Harris Corporation
    /// </summary>
    /// <remarks>
    /// Metadata registered by Harris Corporation for private use
    /// </remarks>
    private static readonly byte[] HarrisCorporation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x0E, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Has Audio Watermark
    /// </summary>
    /// <remarks>
    /// Indicates that the program has an audio watermark
    /// </remarks>
    private static readonly byte[] HasAudioWatermark = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x01, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Has Episode
    /// </summary>
    /// <remarks>
    /// A series that the current resource is an episode of
    /// </remarks>
    private static readonly byte[] hasEpisode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x02, 0x10, 0x00, 0x00];
    /// <summary>
    /// Has Format
    /// </summary>
    /// <remarks>
    /// A resource defining the format with the current resource
    /// </remarks>
    private static readonly byte[] hasFormat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x02, 0x0C, 0x00, 0x00];
    /// <summary>
    /// Hash
    /// </summary>
    /// <remarks>
    /// A set of attributes to define a hash vector
    /// </remarks>
    private static readonly byte[] hash = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x46, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Hash Function Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a type group to define the type of hash function used
    /// </remarks>
    private static readonly byte[] hashFunctionTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x46, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Hash Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a hash object
    /// </remarks>
    private static readonly byte[] hashObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3C, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Hash Value Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a value of the hash vector
    /// </remarks>
    private static readonly byte[] hashValueObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x46, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Has Member
    /// </summary>
    /// <remarks>
    /// A resource that is a member of a group
    /// </remarks>
    private static readonly byte[] hasMember = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x02, 0x0F, 0x00, 0x00];
    /// <summary>
    /// Has Part
    /// </summary>
    /// <remarks>
    /// A resource that forms part of the current resource
    /// </remarks>
    private static readonly byte[] hasPart = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x02, 0x08, 0x00, 0x00];
    /// <summary>
    /// Has Season
    /// </summary>
    /// <remarks>
    /// A season that the current resource is a series of
    /// </remarks>
    private static readonly byte[] hasSeason = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x02, 0x12, 0x00, 0x00];
    /// <summary>
    /// Has Series
    /// </summary>
    /// <remarks>
    /// To identify series e.g. in a season.
    /// </remarks>
    private static readonly byte[] hasSeries = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x02, 0x17, 0x00, 0x00];
    /// <summary>
    /// Has Version
    /// </summary>
    /// <remarks>
    /// A version derived from the current resource
    /// </remarks>
    private static readonly byte[] hasVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x02, 0x02, 0x00, 0x00];
    /// <summary>
    /// Has Video Watermark
    /// </summary>
    /// <remarks>
    /// Indicates the program has a video watermark
    /// </remarks>
    private static readonly byte[] HasVideoWatermark = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// HBO
    /// </summary>
    /// <remarks>
    /// Metadata registered by Home Box Office, Inc. for private use
    /// </remarks>
    private static readonly byte[] HBO = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x0E, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Header Byte Count
    /// </summary>
    /// <remarks>
    /// Count of bytes used for the metadata in a file Header
    /// </remarks>
    private static readonly byte[] HeaderByteCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x04, 0x06, 0x09, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Height
    /// </summary>
    /// <remarks>
    /// A set of attributes to define a Height
    /// </remarks>
    private static readonly byte[] height = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x41, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Height Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group to specify the type of height
    /// </remarks>
    private static readonly byte[] heightTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x41, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Height Value Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a dimension to define the value and unit of the height
    /// </remarks>
    private static readonly byte[] heightValueObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x41, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// HEVC Average Bit Rate
    /// </summary>
    /// <remarks>
    /// Average bit rate of the HEVC stream in bit/s
    /// </remarks>
    private static readonly byte[] HEVCAverageBitRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x02, 0x14, 0x00, 0x00];
    /// <summary>
    /// HEVC Closed GOP Indicator
    /// </summary>
    /// <remarks>
    /// TRUE if all GOPs are started with IDR Picture.
    /// </remarks>
    private static readonly byte[] HEVCClosedGOPIndicator = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x02, 0x06, 0x00, 0x00];
    /// <summary>
    /// HEVC Coded Content Kind
    /// </summary>
    /// <remarks>
    /// Enumerated value specifying Picture type and Coding type
    /// </remarks>
    private static readonly byte[] HEVCCodedContentKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x02, 0x04, 0x00, 0x00];
    /// <summary>
    /// HEVC Constant B Picture Flag
    /// </summary>
    /// <remarks>
    /// TRUE if the number of B Pictures is always constant
    /// </remarks>
    private static readonly byte[] HEVCConstantBPictureFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x02, 0x03, 0x00, 0x00];
    /// <summary>
    /// HEVC CTU Size
    /// </summary>
    /// <remarks>
    /// Specifies the size of CTU
    /// </remarks>
    private static readonly byte[] HEVCCTUSize = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x02, 0x15, 0x00, 0x00];
    /// <summary>
    /// HEVC Decoding Delay
    /// </summary>
    /// <remarks>
    /// Specifies the delay required for decoded pictures in number of access units
    /// </remarks>
    private static readonly byte[] HEVCDecodingDelay = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x02, 0x0E, 0x00, 0x00];
    /// <summary>
    /// HEVC Identical GOP Indicator
    /// </summary>
    /// <remarks>
    /// TRUE if every GOP in the sequence has the same number of pictures and the same types of pictures in  the same order.
    /// </remarks>
    private static readonly byte[] HEVCIdenticalGOPIndicator = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x02, 0x07, 0x00, 0x00];
    /// <summary>
    /// HEVC Level
    /// </summary>
    /// <remarks>
    /// Specifies the HEVC level
    /// </remarks>
    private static readonly byte[] HEVCLevel = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x02, 0x0D, 0x00, 0x00];
    /// <summary>
    /// HEVC Maximum Bit Rate
    /// </summary>
    /// <remarks>
    /// Maximum bit rate of the HEVC stream in bit/s
    /// </remarks>
    private static readonly byte[] HEVCMaximumBitRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x02, 0x0B, 0x00, 0x00];
    /// <summary>
    /// HEVC Maximum B-Picture Count
    /// </summary>
    /// <remarks>
    /// Specifies the maximum number of B Pictures between P or I Pictures
    /// </remarks>
    private static readonly byte[] HEVCMaximumBPictureCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x02, 0x09, 0x00, 0x00];
    /// <summary>
    /// HEVC Maximum GOP Size
    /// </summary>
    /// <remarks>
    /// Specifies the maximum occurring spacing between I Pictures
    /// </remarks>
    private static readonly byte[] HEVCMaximumGOPSize = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x02, 0x08, 0x00, 0x00];
    /// <summary>
    /// HEVC Maximum Ref Frames
    /// </summary>
    /// <remarks>
    /// Specifies the maximum number of reference frames
    /// </remarks>
    private static readonly byte[] HEVCMaximumRefFrames = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x02, 0x0F, 0x00, 0x00];
    /// <summary>
    /// HEVC Number of PPSs
    /// </summary>
    /// <remarks>
    /// Spefifies the maximum number of picture parameter sets that have different pps_pic_parameter_set_id in each GOP
    /// </remarks>
    private static readonly byte[] HEVCNumberOfPPSs = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x02, 0x1B, 0x00, 0x00];
    /// <summary>
    /// HEVC Parameters
    /// </summary>
    /// <remarks>
    /// Parameters about HEVC Picture Coding
    /// </remarks>
    private static readonly byte[] HEVCParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// HEVC Picture Parameter Set Flag
    /// </summary>
    /// <remarks>
    /// Specifies the location and the constancy of picture parameter sets
    /// </remarks>
    private static readonly byte[] HEVCPictureParameterSetFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x02, 0x11, 0x00, 0x00];
    /// <summary>
    /// HEVC Profile
    /// </summary>
    /// <remarks>
    /// Specifies the HEVC video profile
    /// </remarks>
    private static readonly byte[] HEVCProfile = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x02, 0x0A, 0x00, 0x00];
    /// <summary>
    /// HEVC Profile Constraint
    /// </summary>
    /// <remarks>
    /// Specifies the HEVC video profile constraint flags
    /// </remarks>
    private static readonly byte[] HEVCProfileConstraint = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x02, 0x0C, 0x00, 0x00];
    /// <summary>
    /// HEVC Sequence Parameter Set Flag
    /// </summary>
    /// <remarks>
    /// Specifies the location and the constancy of sequence parameter sets
    /// </remarks>
    private static readonly byte[] HEVCSequenceParameterSetFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x02, 0x10, 0x00, 0x00];
    /// <summary>
    /// HEVC Tier
    /// </summary>
    /// <remarks>
    /// Specifies the HEVC tier
    /// </remarks>
    private static readonly byte[] HEVCTier = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x02, 0x12, 0x00, 0x00];
    /// <summary>
    /// HEVC Tile Columns Minus 1
    /// </summary>
    /// <remarks>
    /// Specifies the number of tile columns minus 1
    /// </remarks>
    private static readonly byte[] HEVCTileColumnsMinus1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x02, 0x17, 0x00, 0x00];
    /// <summary>
    /// HEVC Tile Height Minus 1
    /// </summary>
    /// <remarks>
    /// Specifies the height minus 1 of tiles in units of CTBs
    /// </remarks>
    private static readonly byte[] HEVCTileHeightMinus1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x02, 0x1A, 0x00, 0x00];
    /// <summary>
    /// HEVC Tile Rows Minus 1
    /// </summary>
    /// <remarks>
    /// Specifies the number of tile rows minus 1
    /// </remarks>
    private static readonly byte[] HEVCTileRowsMinus1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x02, 0x18, 0x00, 0x00];
    /// <summary>
    /// HEVC Tile Uniform Spacing Flag
    /// </summary>
    /// <remarks>
    /// TRUE if tile column boundaries and tile row boundaries are distributed uniformly
    /// </remarks>
    private static readonly byte[] HEVCTileUniformSpacingFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x02, 0x16, 0x00, 0x00];
    /// <summary>
    /// HEVC Tile Width Minus 1
    /// </summary>
    /// <remarks>
    /// Specifies the width minus 1 of tiles in units of CTBs
    /// </remarks>
    private static readonly byte[] HEVCTileWidthMinus1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x02, 0x19, 0x00, 0x00];
    /// <summary>
    /// HEVC Video Parameter Set Flag
    /// </summary>
    /// <remarks>
    /// Specifies the location and the constancy of video parameter sets
    /// </remarks>
    private static readonly byte[] HEVCVideoParameterSetFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x06, 0x02, 0x13, 0x00, 0x00];
    /// <summary>
    /// Highlight Gain Control
    /// </summary>
    /// <remarks>
    /// Control for the steepness of the curve in its highlight (brighter) region
    /// </remarks>
    private static readonly byte[] HighlightGainControl = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x24, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Historical Value
    /// </summary>
    /// <remarks>
    /// Assessment of the historic value
    /// </remarks>
    private static readonly byte[] HistoricalValue_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x02, 0x02, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Honors and Qualifications
    /// </summary>
    /// <remarks>
    /// Personal honours and qualifications
    /// </remarks>
    private static readonly byte[] HonorsQualifications = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x30, 0x06, 0x03, 0x01, 0x06, 0x01, 0x00];
    /// <summary>
    /// Honors and Qualifications
    /// </summary>
    /// <remarks>
    /// Personal honours and qualifications
    /// </remarks>
    private static readonly byte[] HonorsQualifications_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x02, 0x30, 0x06, 0x03, 0x01, 0x06, 0x00, 0x00];
    /// <summary>
    /// Horizontal Action Safe Percentage
    /// </summary>
    /// <remarks>
    /// Specifies the percentage of the image which lies outside the horizontal safe area for action: expressed as the ratio of one side as a percentage of the total width of the scan.
    /// </remarks>
    private static readonly byte[] HorizontalActionSafePercentage = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x01, 0x01, 0x01, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Horizontal Datum
    /// </summary>
    /// <remarks>
    /// Identifies the Digital Geographic Information Exchange Standard (DIGEST) map datum used to derive the  coordinates (UTM or GEO).
    /// </remarks>
    private static readonly byte[] HorizontalDatum_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Horizontal Graphics Safe Percentage
    /// </summary>
    /// <remarks>
    /// Specifies the percentage of the image which lies outside the horizontal safe area for graphics: expressed as the ratio of one side as a percentage of the total width of the scan.
    /// </remarks>
    private static readonly byte[] HorizontalGraphicsSafePercentage = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x01, 0x01, 0x01, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Horizontal Parameters
    /// </summary>
    /// <remarks>
    /// Horizontal scanning information
    /// </remarks>
    private static readonly byte[] HorizontalParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Horizontal Sub-sampling
    /// </summary>
    /// <remarks>
    /// Specifies ratio of luminance subsampling to chrominance subsampling in horizontal direction
    /// </remarks>
    private static readonly byte[] HorizontalSubsampling = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x01, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// HTML DOCTYPE
    /// </summary>
    /// <remarks>
    /// The complete document type declaration for an HTML document
    /// </remarks>
    private static readonly byte[] HTMLDOCTYPE = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x01, 0x03, 0x06, 0x04, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// HTML DOCTYPE
    /// </summary>
    /// <remarks>
    /// The complete document type declaration for an HTML document
    /// </remarks>
    private static readonly byte[] HTMLDOCTYPE_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x01, 0x03, 0x06, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// HTML Meta Description
    /// </summary>
    /// <remarks>
    /// A freeform textual description of a Web page intended for use in the HTML "meta" element
    /// </remarks>
    private static readonly byte[] HTMLMetaDescription = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x03, 0x02, 0x01, 0x06, 0x11, 0x01, 0x00, 0x00];
    /// <summary>
    /// HTML Meta Description
    /// </summary>
    /// <remarks>
    /// A freeform textual description of a Web page intended for use in the HTML "meta" element
    /// </remarks>
    private static readonly byte[] HTMLMetaDescription_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x03, 0x02, 0x01, 0x06, 0x11, 0x00, 0x00, 0x00];
    /// <summary>
    /// Human-Assigned Context Descriptions
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] HumanAssignedContextDescriptions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Human Assigned Descriptors
    /// </summary>
    /// <remarks>
    /// Descriptors (Human Assigned) relating to analysis of the content
    /// </remarks>
    private static readonly byte[] HumanAssignedDescriptors = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// IAB Sample Rate
    /// </summary>
    /// <remarks>
    /// Sample rate of the audio essence contained in the bistream
    /// </remarks>
    private static readonly byte[] IABSampleRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x02, 0x03, 0x01, 0x0F, 0x00, 0x00, 0x00];
    /// <summary>
    /// IBTN
    /// </summary>
    /// <remarks>
    /// EBU International Broadcast Tape Number
    /// </remarks>
    private static readonly byte[] IBTN = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x10, 0x04, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// IdeasUnlimited.TV
    /// </summary>
    /// <remarks>
    /// Metadata registered by IdeasUnlimited.TV for private use
    /// </remarks>
    private static readonly byte[] IdeasUnlimitedTV = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x0E, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Identical GOP Indicator
    /// </summary>
    /// <remarks>
    /// TRUE if every GOP in the sequence is constructed the same, per 13818-1 IBP descriptor
    /// </remarks>
    private static readonly byte[] IdenticalGOP = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x01, 0x06, 0x02, 0x01, 0x07, 0x00, 0x00];
    /// <summary>
    /// Identifier Issuing Authority
    /// </summary>
    /// <remarks>
    /// The authority that issued the identification value
    /// </remarks>
    private static readonly byte[] IdentificationIssuingAuthority = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x02, 0x0A, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Identification List
    /// </summary>
    /// <remarks>
    /// Specifies a vector of references to modification identifiers
    /// </remarks>
    private static readonly byte[] IdentificationList = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x06, 0x04, 0x00, 0x00];
    /// <summary>
    /// Identification UL
    /// </summary>
    /// <remarks>
    /// Specifies the Universal Label that locates the identification kind in a dictionary.
    /// </remarks>
    private static readonly byte[] IdentificationLocator = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Identification Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Identification sets
    /// </remarks>
    private static readonly byte[] IdentificationObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x06, 0x00];
    /// <summary>
    /// Identifier
    /// </summary>
    /// <remarks>
    /// A set of attributes to qualify an identifier associated with the resource
    /// </remarks>
    private static readonly byte[] identifier = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Identifier Attributor Entity Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an entity object to specify the authority attributing of the identifier
    /// </remarks>
    private static readonly byte[] identifierAttributorEntityObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x04, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Identifier Format  Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute format group to specify the format of the identifier
    /// </remarks>
    private static readonly byte[] identifierFormatGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x04, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Identifier Issuing Authority
    /// </summary>
    /// <remarks>
    /// The Authority issuing an identifier
    /// </remarks>
    private static readonly byte[] IdentifierIssuingAuthority_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x0A, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Identifier Kind
    /// </summary>
    /// <remarks>
    /// Specifies the indentification system used - e.g. ISO, UPN etc
    /// </remarks>
    private static readonly byte[] IdentifierKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x01, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Identifier Note
    /// </summary>
    /// <remarks>
    /// A note to provide additional contextual information
    /// </remarks>
    private static readonly byte[] identifierNote = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x04, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Identifier Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to one or more identifiers
    /// </remarks>
    private static readonly byte[] identifierObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// IDENTIFIERS AND LOCATORS
    /// </summary>
    /// <remarks>
    /// Class 1 metadata is reserved for abstract Identifiers and Locators
    /// </remarks>
    private static readonly byte[] IdentifiersAndLocators = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Identifiers and Locators Administration Authorities
    /// </summary>
    /// <remarks>
    /// An Authority of issuing Identifiers and Locators
    /// </remarks>
    private static readonly byte[] IdentifiersAndLocatorsAdministrationAuthorities = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Identifier Text
    /// </summary>
    /// <remarks>
    /// Product Name
    /// </remarks>
    private static readonly byte[] IdentifierText = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x1B, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Identifier Text Length
    /// </summary>
    /// <remarks>
    /// The length of the identifier text
    /// </remarks>
    private static readonly byte[] IdentifierTextLength = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x1A, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Identifier Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group to specify the type of the identifier
    /// </remarks>
    private static readonly byte[] identifierTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x04, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Identifier Value
    /// </summary>
    /// <remarks>
    /// The value of the identifer
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] IdentifierValue_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x01, 0x08, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Identifier Value
    /// </summary>
    /// <remarks>
    /// The value of the identifier attributed to the resource
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] IdentifierValue_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x04, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// IDRef
    /// </summary>
    /// <remarks>
    /// A set of attributes to describe an IDRef
    /// </remarks>
    private static readonly byte[] IDRef = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4B, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// IDRef Value
    /// </summary>
    /// <remarks>
    /// The value of the IDRef
    /// </remarks>
    private static readonly byte[] IDRefValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4B, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// IEEE Device ID
    /// </summary>
    /// <remarks>
    /// Hex number identifying a device by manufacturer and device number
    /// </remarks>
    private static readonly byte[] IEEEDeviceIdentifier = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x20, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// IEEE Manufacturer ID
    /// </summary>
    /// <remarks>
    /// The IEEE registered ID for a particular manufacturer.
    /// </remarks>
    private static readonly byte[] IEEEManufacturerID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x0A, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Alignment Offset
    /// </summary>
    /// <remarks>
    /// Specifies number of bytes to align the start of an image with a defined memory boundary
    /// </remarks>
    private static readonly byte[] ImageAlignmentFactor = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x18, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Presentation Aspect Ratio
    /// </summary>
    /// <remarks>
    /// Specifies the horizontal to vertical aspect ratio of the whole image as it is to be presented to avoid geometric distortion and hence including any black edges.
    /// </remarks>
    private static readonly byte[] ImageAspectRatio = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Aspect Ratio Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an aspect ratio of the image
    /// </remarks>
    private static readonly byte[] imageAspectRatioObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Category
    /// </summary>
    /// <remarks>
    /// Identifies the specific category of imagery (often revealing the nature of the collector or intended use). Format is as defined in NITF v2.0 in addition to those defined here.
    /// </remarks>
    private static readonly byte[] ImageCategory_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x20, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Characteristics
    /// </summary>
    /// <remarks>
    /// The specific category of imagery
    /// </remarks>
    private static readonly byte[] ImageCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x20, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Codec Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a codec object
    /// </remarks>
    private static readonly byte[] imageCodecObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Coordinate System
    /// </summary>
    /// <remarks>
    /// Identifies the Digital Geographic Information Exchange Standard (DIGEST) geo-referenced coordinate system used at image capture.
    /// </remarks>
    private static readonly byte[] ImageCoordinateSystem_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Devices
    /// </summary>
    /// <remarks>
    /// Information about the image device
    /// </remarks>
    private static readonly byte[] ImageDevices = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x20, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Dimensions
    /// </summary>
    /// <remarks>
    /// Length measurements relating to the physical size of the image formed in a capturing device
    /// </remarks>
    private static readonly byte[] ImageDimensions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x09, 0x04, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Encoding Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an encoding object
    /// </remarks>
    private static readonly byte[] imageEncodingObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image End Offset
    /// </summary>
    /// <remarks>
    /// Specifies bytes of fill after end of field
    /// </remarks>
    private static readonly byte[] ImageEndOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x18, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Essence Processing
    /// </summary>
    /// <remarks>
    /// Enhamcement or modification to the image essence
    /// </remarks>
    private static readonly byte[] ImageEssenceProcessing = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Format
    /// </summary>
    /// <remarks>
    /// A set of attributes defining the image format of the material
    /// </remarks>
    private static readonly byte[] imageFormat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Format Definition
    /// </summary>
    /// <remarks>
    /// A definition associated with the image format
    /// </remarks>
    private static readonly byte[] imageFormatDefinition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Format ID
    /// </summary>
    /// <remarks>
    /// An identifier attributed to the image format
    /// </remarks>
    private static readonly byte[] imageFormatID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Format Name
    /// </summary>
    /// <remarks>
    /// A name attributed to the image format
    /// </remarks>
    private static readonly byte[] imageFormatName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Format Profile
    /// </summary>
    /// <remarks>
    /// To define a profile of an image format
    /// </remarks>
    private static readonly byte[] imageFormatProfile = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x0E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Format Profile Level
    /// </summary>
    /// <remarks>
    /// To define a level of an image format
    /// </remarks>
    private static readonly byte[] imageFormatProfileLevel = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x0F, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Format Version ID
    /// </summary>
    /// <remarks>
    /// An identifier attributed to the version of an image format
    /// </remarks>
    private static readonly byte[] imageFormatVersionId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Height Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a height object
    /// </remarks>
    private static readonly byte[] imageHeightObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Note
    /// </summary>
    /// <remarks>
    /// A contextual information note
    /// </remarks>
    private static readonly byte[] imageNote = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Orientation
    /// </summary>
    /// <remarks>
    /// The orientation of the picture (e.g. portrait or landscape)
    /// </remarks>
    private static readonly byte[] imageOrientation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Positional Information
    /// </summary>
    /// <remarks>
    /// Positional information relating to a subset of the whole image
    /// </remarks>
    private static readonly byte[] ImagePositionalInformation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Presence Flag
    /// </summary>
    /// <remarks>
    /// A flag to indicate the presence of an image
    /// </remarks>
    private static readonly byte[] imagePresenceFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Imager Characteristics
    /// </summary>
    /// <remarks>
    /// The specific category of imagery
    /// </remarks>
    private static readonly byte[] ImagerCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x04, 0x20, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Region Delim X Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a dimension object to define the abscisse coordinate of an area associated with width and height objects
    /// </remarks>
    private static readonly byte[] imageRegionDelimXObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image region Delim Y Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a dimension object to define the ordinate coordinate of an area associated with width and height objects
    /// </remarks>
    private static readonly byte[] imageRegionDelimYObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Scan Direction
    /// </summary>
    /// <remarks>
    /// Direction of scanning for line/point-symmetric picture transformation
    /// </remarks>
    private static readonly byte[] ImageScanDirection = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x01, 0x03, 0x01, 0x11, 0x00, 0x00];
    /// <summary>
    /// Image Sensor Decimation Ratio
    /// </summary>
    /// <remarks>
    /// Vertical/horizontal decimation ratio of the reading out of pixels on the image sensor
    /// </remarks>
    private static readonly byte[] ImageSensorDecimationRatio = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x01, 0x03, 0x01, 0x10, 0x00, 0x00];
    /// <summary>
    /// Image Sensor Dimension Effective Height
    /// </summary>
    /// <remarks>
    /// Height of effective image area in micro meters
    /// </remarks>
    private static readonly byte[] ImageSensorDimensionEffectiveHeight = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x01, 0x03, 0x01, 0x06, 0x00, 0x00];
    /// <summary>
    /// Image Sensor Dimension Effective Width
    /// </summary>
    /// <remarks>
    /// Width of effective image area in micro meters
    /// </remarks>
    private static readonly byte[] ImageSensorDimensionEffectiveWidth = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x01, 0x03, 0x01, 0x05, 0x00, 0x00];
    /// <summary>
    /// Image Sensor Readout Mode
    /// </summary>
    /// <remarks>
    /// Image Readout mode defined as a registered code
    /// </remarks>
    private static readonly byte[] ImageSensorReadoutMode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x01, 0x03, 0x01, 0x07, 0x00, 0x00];
    /// <summary>
    /// Image Source Characteristics
    /// </summary>
    /// <remarks>
    /// Fundamental characteristics of the image source
    /// </remarks>
    private static readonly byte[] ImageSourceCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Source Device Kind
    /// </summary>
    /// <remarks>
    /// Indicates the type of the image source device
    /// </remarks>
    private static readonly byte[] ImageSourceDeviceKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x04, 0x20, 0x01, 0x02, 0x01, 0x01, 0x01, 0x00];
    /// <summary>
    /// Image Source Device Kind
    /// </summary>
    /// <remarks>
    /// Indicates the type of the image source device
    /// </remarks>
    private static readonly byte[] ImageSourceDeviceKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x20, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Image Start Offset
    /// </summary>
    /// <remarks>
    /// Specifies bytes of fill before start of field
    /// </remarks>
    private static readonly byte[] ImageStartOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x18, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Technical Attribute AnyURI Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type AnyURI
    /// </remarks>
    private static readonly byte[] imageTechnicalAttributeAnyURIObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x1C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Technical Attribute Boolean Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Boolean
    /// </remarks>
    private static readonly byte[] imageTechnicalAttributeBooleanObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x1D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Technical Attribute Float Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Float
    /// </remarks>
    private static readonly byte[] imageTechnicalAttributeFloatObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x1A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Technical Attribute Int16 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int16
    /// </remarks>
    private static readonly byte[] imageTechnicalAttributeInt16Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x13, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Technical Attribute Int32 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int32
    /// </remarks>
    private static readonly byte[] imageTechnicalAttributeInt32Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x14, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Technical Attribute Int64 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int64
    /// </remarks>
    private static readonly byte[] imageTechnicalAttributeInt64Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x15, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Technical Attribute Int8 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int8
    /// </remarks>
    private static readonly byte[] imageTechnicalAttributeInt8Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x12, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Technical Attribute Rational Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Rational
    /// </remarks>
    private static readonly byte[] imageTechnicalAttributeRationalObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x1B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Technical Attribute String Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type string
    /// </remarks>
    private static readonly byte[] imageTechnicalAttributeStringObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x11, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Technical Attribute UInt16 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt16
    /// </remarks>
    private static readonly byte[] imageTechnicalAttributeUInt16Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x17, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Technical Attribute UInt32 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt32
    /// </remarks>
    private static readonly byte[] imageTechnicalAttributeUInt32Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x18, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Technical Attribute UInt64 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt64
    /// </remarks>
    private static readonly byte[] imageTechnicalAttributeUInt64Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x19, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Technical Attribute UInt8 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt8
    /// </remarks>
    private static readonly byte[] imageTechnicalAttributeUInt8Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x16, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Test Parameters
    /// </summary>
    /// <remarks>
    /// Test information from the original imagery
    /// </remarks>
    private static readonly byte[] ImageTestParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Transfer History
    /// </summary>
    /// <remarks>
    /// History of image transfers occuring in the process
    /// </remarks>
    private static readonly byte[] ImageTransferHistory = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x40, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Width Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a width object
    /// </remarks>
    private static readonly byte[] imageWidthObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x32, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Immersive Audio ID
    /// </summary>
    /// <remarks>
    /// UUID of the Immersive Audio  project
    /// </remarks>
    private static readonly byte[] ImmersiveAudioID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x0E, 0x09, 0x05, 0x09, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Immersive Audio Version
    /// </summary>
    /// <remarks>
    /// Immersive Audio  Coder version used to create the source Bitstream
    /// </remarks>
    private static readonly byte[] ImmersiveAudioVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x0E, 0x09, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Associated Metadata Definition
    /// </summary>
    /// <remarks>
    /// Specifies the metadata definition implemented by the plugin
    /// </remarks>
    private static readonly byte[] ImplementedClass = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x09, 0x0F, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Include Sync
    /// </summary>
    /// <remarks>
    /// Specifies whether synchronization data is included in SMPTE 12M Timecode
    /// </remarks>
    private static readonly byte[] IncludeSync = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x01, 0x01, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Income
    /// </summary>
    /// <remarks>
    /// Income information
    /// </remarks>
    private static readonly byte[] Income = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Cue-In Words
    /// </summary>
    /// <remarks>
    /// The actual words on the sound track or a textual reference to music etc. at the in-cue point
    /// </remarks>
    private static readonly byte[] InCueWords = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x03, 0x02, 0x01, 0x02, 0x0D, 0x01, 0x00, 0x00];
    /// <summary>
    /// Index Byte Count
    /// </summary>
    /// <remarks>
    /// Count of bytes used for index table segments
    /// </remarks>
    private static readonly byte[] IndexByteCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x04, 0x06, 0x09, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Index Duration
    /// </summary>
    /// <remarks>
    /// Specifies the duration of an Index table in content units
    /// </remarks>
    private static readonly byte[] IndexDuration = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x07, 0x02, 0x02, 0x01, 0x01, 0x02, 0x00, 0x00];
    /// <summary>
    /// Index Edit Rate
    /// </summary>
    /// <remarks>
    /// Specifies the indexing rate in hertz
    /// </remarks>
    private static readonly byte[] IndexEditRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x05, 0x30, 0x04, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Index Entry Array
    /// </summary>
    /// <remarks>
    /// Array of values used to index elements from edit unit to edit unit
    /// </remarks>
    private static readonly byte[] IndexEntryArray = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x04, 0x04, 0x02, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Indexing Metadata Coding Characteristics
    /// </summary>
    /// <remarks>
    /// Information about the indexing metadata coding
    /// </remarks>
    private static readonly byte[] IndexingMetadataCodingCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Index Locations
    /// </summary>
    /// <remarks>
    /// Index Locations
    /// </remarks>
    private static readonly byte[] IndexLocations = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x04, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Indexing Start Position
    /// </summary>
    /// <remarks>
    /// Specifies the  position reletive to start of essence, in edit units, where indexing starts
    /// </remarks>
    private static readonly byte[] IndexStartPosition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x07, 0x02, 0x01, 0x03, 0x01, 0x0A, 0x00, 0x00];
    /// <summary>
    /// Index Stream ID
    /// </summary>
    /// <remarks>
    /// Index table stream ID
    /// </remarks>
    private static readonly byte[] IndexStreamID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x01, 0x03, 0x04, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Assigned Category Value
    /// </summary>
    /// <remarks>
    /// Freeform textual value for an assigned category
    /// </remarks>
    private static readonly byte[] IndirectValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x01, 0x02, 0x0A, 0x01, 0x00, 0x00];
    /// <summary>
    /// Individual Award Name
    /// </summary>
    /// <remarks>
    /// Awards granted to individuals
    /// </remarks>
    private static readonly byte[] IndividualAwardName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Individuals and Groups
    /// </summary>
    /// <remarks>
    /// Details of persons or groups of people contributing to or taking part in the production
    /// </remarks>
    private static readonly byte[] IndividualsAndGroups = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Ink Number
    /// </summary>
    /// <remarks>
    /// Ink number
    /// </remarks>
    private static readonly byte[] InkNumber_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Input Segment
    /// </summary>
    /// <remarks>
    /// Specifies the input essence whose timebase is to be converted
    /// </remarks>
    private static readonly byte[] InputSegment = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x02, 0x07, 0x00, 0x00];
    /// <summary>
    /// Input Segments
    /// </summary>
    /// <remarks>
    /// Specifies a vector of references to the input segments used of produce the effect or operation
    /// </remarks>
    private static readonly byte[] InputSegments = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x06, 0x02, 0x00, 0x00];
    /// <summary>
    /// Insert Music Flag
    /// </summary>
    /// <remarks>
    /// Indicates that the associated music is a music insert
    /// </remarks>
    private static readonly byte[] InsertMusicFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x05, 0x01, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Installment Number
    /// </summary>
    /// <remarks>
    /// The number of any repeat payments
    /// </remarks>
    private static readonly byte[] InstallmentNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Instance ID
    /// </summary>
    /// <remarks>
    /// Unique ID of an instance
    /// </remarks>
    private static readonly byte[] InstanceID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x15, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Integrated Loudness
    /// </summary>
    /// <remarks>
    /// The intergated loudness in LUFS
    /// </remarks>
    private static readonly byte[] integratedLoudness = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4C, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Integration Indication
    /// </summary>
    /// <remarks>
    /// A term that describes what the essence is as a unit status of the essence. Terms must be consistent with industry or organizational practices to be useful. Includes segment, clip, shot, item, program etc.
    /// </remarks>
    private static readonly byte[] IntegrationIndication = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x05, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Integration Indication
    /// </summary>
    /// <remarks>
    /// A term that describes what the essence is as a unit status of the essence.  Terms must be consistent with industry or organizational practices to be useful.  Includes segment, clip, shot, item, program etc.
    /// </remarks>
    private static readonly byte[] IntegrationIndication_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Intellectual Property Description
    /// </summary>
    /// <remarks>
    /// A definition of the intellectual property in freeform text
    /// </remarks>
    private static readonly byte[] IntellectualPropertyDescription = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x05, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Intellectual Property Description
    /// </summary>
    /// <remarks>
    /// A definition of the IP in freeform text
    /// </remarks>
    private static readonly byte[] IntellectualPropertyDescription_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x05, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Intellectual Property License Country Code
    /// </summary>
    /// <remarks>
    /// The ISO code that represents a country where IP rights are licensed
    /// </remarks>
    private static readonly byte[] IntellectualPropertyLicenseCountryCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x02, 0x05, 0x00, 0x00];
    /// <summary>
    /// Intellectual Property License Region Code
    /// </summary>
    /// <remarks>
    /// The ISO code that represents a region of a country where IP rights are licensed
    /// </remarks>
    private static readonly byte[] IntellectualPropertyLicenseRegionCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x03, 0x05, 0x00, 0x00];
    /// <summary>
    /// Intellectual Property Rights
    /// </summary>
    /// <remarks>
    /// A freeform text definition of what use can be made of an intellectual property
    /// </remarks>
    private static readonly byte[] IntellectualPropertyRight = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x05, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Intellectual Property Rights
    /// </summary>
    /// <remarks>
    /// A freeform text definition of what use can be made of an IP
    /// </remarks>
    private static readonly byte[] IntellectualPropertyRight_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x05, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Intellectual Property Rights Identifiers
    /// </summary>
    /// <remarks>
    /// Unique IDs allocated by IP Rights organizations
    /// </remarks>
    private static readonly byte[] IntellectualPropertyRightsIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Intellectual Property Rights Options
    /// </summary>
    /// <remarks>
    /// A definition of what options can be excersied within the framework of using an IP Right
    /// </remarks>
    private static readonly byte[] IntellectualPropertyRightsOptions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x05, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Intellectual Rights
    /// </summary>
    /// <remarks>
    /// Intellectual property rights metadata other than copyright
    /// </remarks>
    private static readonly byte[] IntellectualRights = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x05, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Intent Descriptor
    /// </summary>
    /// <remarks>
    /// A freeform textual descrition written before production implementation etc. started - e.g. at the scripting stage.
    /// </remarks>
    private static readonly byte[] IntentDescriptor = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x01, 0x06, 0x06, 0x01, 0x00, 0x00];
    /// <summary>
    /// Intent Descriptor
    /// </summary>
    /// <remarks>
    /// A freeform textual descrition written before production implementation etc. started - e.g. at the scripting stage.
    /// </remarks>
    private static readonly byte[] IntentDescriptor_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x01, 0x06, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Inter Edit Unit Indexing
    /// </summary>
    /// <remarks>
    /// Information about indexing edit units within a container.
    /// </remarks>
    private static readonly byte[] InterEditUnitIndexing = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x04, 0x04, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Interested Party Name
    /// </summary>
    /// <remarks>
    /// A definition or who or what entity has an interest in the right being excercised
    /// </remarks>
    private static readonly byte[] InterestedPartyName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x05, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// International Broadcasting Organization Identifiers
    /// </summary>
    /// <remarks>
    /// Internationally recognized identifiers registered by broadcasting organizations
    /// </remarks>
    private static readonly byte[] InternationalBroadcastingOrganizationIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// International Standard Compound Identifiers
    /// </summary>
    /// <remarks>
    /// Compound Identifiers based on an internationally accepted Standard
    /// </remarks>
    private static readonly byte[] InternationalStandardCompoundIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// International Standard Identifiers
    /// </summary>
    /// <remarks>
    /// Internationally accepted Identifier Schemes
    /// </remarks>
    private static readonly byte[] InternationalStandardIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Interpolation
    /// </summary>
    /// <remarks>
    /// Specifies a reference to the definition of the interpolation to be used
    /// </remarks>
    private static readonly byte[] Interpolation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x01, 0x05, 0x00, 0x00];
    /// <summary>
    /// Interpolation Definitions
    /// </summary>
    /// <remarks>
    /// Specifies a unordered set of references to Interpolation Definitions
    /// </remarks>
    private static readonly byte[] InterpolationDefinitions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x05, 0x09, 0x00, 0x00];
    /// <summary>
    /// INTERPRETIVE
    /// </summary>
    /// <remarks>
    /// Class 3 is reserved for information on interpreting the data
    /// </remarks>
    private static readonly byte[] Interpretive = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Intra Edit Unit Indexing
    /// </summary>
    /// <remarks>
    /// Information about indexing essence elements within an edit unit.
    /// </remarks>
    private static readonly byte[] IntraEditUnitIndexing = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x04, 0x04, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Intrinsic Picture Resolution
    /// </summary>
    /// <remarks>
    /// Indicates the resolution of the primary picture on which Sub-Picture Ancillary Resources are to be rendered
    /// </remarks>
    private static readonly byte[] IntrinsicPictureResolution = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x06, 0x01, 0x01, 0x02, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// IPV Ltd
    /// </summary>
    /// <remarks>
    /// Metadata registered by IPV Ltd for private use
    /// </remarks>
    private static readonly byte[] IPVLtd = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x0E, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Iris F-Number
    /// </summary>
    /// <remarks>
    /// Lens aperture setting in EV/1000h based on 8000h for F16
    /// </remarks>
    private static readonly byte[] IrisFNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Iris Ring Position
    /// </summary>
    /// <remarks>
    /// Iris ring rotation angle in unsigned integer. 0 is for full open, and FFFFh for close
    /// </remarks>
    private static readonly byte[] IrisRingPosition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x02, 0x02, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Iris T-Number
    /// </summary>
    /// <remarks>
    /// Iris position value calculated from the "T-number" that is a measure of the amount of light transmitted through the lens in practice
    /// </remarks>
    private static readonly byte[] IrisTNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x02, 0x02, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// IRT
    /// </summary>
    /// <remarks>
    /// Metadata registered by the Institut fr Rundfunktechnik GmbH for public use
    /// </remarks>
    private static readonly byte[] IRT = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x0D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// ISAN
    /// </summary>
    /// <remarks>
    /// ISO Audio-Visual Number
    /// </remarks>
    private static readonly byte[] ISAN = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x11, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// ISBD
    /// </summary>
    /// <remarks>
    /// International Federation of Library Associations and Institutions Bibliographic Descriptor
    /// </remarks>
    private static readonly byte[] ISBD = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x11, 0x09, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// ISBN
    /// </summary>
    /// <remarks>
    /// ISO Book Number
    /// </remarks>
    private static readonly byte[] ISBN = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x11, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// ISCI
    /// </summary>
    /// <remarks>
    /// American Association of Advertising Industries Commercial Identifier
    /// </remarks>
    private static readonly byte[] ISCI = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x11, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Is Concrete
    /// </summary>
    /// <remarks>
    /// Specifies that the class definition may be used to create a concrete instance (May be used = true)
    /// </remarks>
    private static readonly byte[] IsConcrete = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x07, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Contiguous Data Flag
    /// </summary>
    /// <remarks>
    /// Specifies if the data is stored in contiguous bytes (False=0)
    /// </remarks>
    private static readonly byte[] IsContiguous = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x06, 0x08, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Inter-Society Digital Cinema Forum
    /// </summary>
    /// <remarks>
    /// Metadata registered by Inter-Society Digital Cinema Forum for public use
    /// </remarks>
    private static readonly byte[] ISDCF = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x0D, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Is Dubbed
    /// </summary>
    /// <remarks>
    /// Indicates that the program is dubbed
    /// </remarks>
    private static readonly byte[] IsDubbed = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Is Episode Of
    /// </summary>
    /// <remarks>
    /// A series that the current resource is an episode of
    /// </remarks>
    private static readonly byte[] isEpisodeOf = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x02, 0x0D, 0x00, 0x00];
    /// <summary>
    /// Is Format  Of
    /// </summary>
    /// <remarks>
    /// A resource defining the format with the current resource
    /// </remarks>
    private static readonly byte[] isFormatOf = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x02, 0x0B, 0x00, 0x00];
    /// <summary>
    /// Is Live Production
    /// </summary>
    /// <remarks>
    /// Indicates that the program is a live production
    /// </remarks>
    private static readonly byte[] IsLiveProduction = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Is Live Transmission
    /// </summary>
    /// <remarks>
    /// Indicates that the program is a live transmission
    /// </remarks>
    private static readonly byte[] IsLiveTransmission = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Is Member Of
    /// </summary>
    /// <remarks>
    /// A group that the current resource is a member of
    /// </remarks>
    private static readonly byte[] isMemberOf = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x02, 0x0E, 0x00, 0x00];
    /// <summary>
    /// ISMN
    /// </summary>
    /// <remarks>
    /// ISO Printed Music Number
    /// </remarks>
    private static readonly byte[] ISMN = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x11, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Is Next In Sequence
    /// </summary>
    /// <remarks>
    /// A resource that comes next to the current resource in a sequence
    /// </remarks>
    private static readonly byte[] isNextInSequence = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x02, 0x13, 0x00, 0x00];
    /// <summary>
    /// ISO 3166 Country Code
    /// </summary>
    /// <remarks>
    /// International Standards Organisation Codes for the representation of names of countries and their subdivisions
    /// </remarks>
    private static readonly byte[] ISO3166CountryCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// ISO 639-1 Language Code
    /// </summary>
    /// <remarks>
    /// Codes assigned by ISO 639-1 for the identification of languages
    /// </remarks>
    private static readonly byte[] ISO6391LanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x03, 0x01, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// ISO 639-1 Language Code
    /// </summary>
    /// <remarks>
    /// Codes assigned by ISO 639-1 for the identification of languages
    /// </remarks>
    private static readonly byte[] ISO6391LanguageCode_ISO639 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// ISO 639 Captions Language Code
    /// </summary>
    /// <remarks>
    /// The short code that represents the language used for textual captions displayed on-screen
    /// </remarks>
    private static readonly byte[] ISO639CaptionsLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x03, 0x01, 0x01, 0x02, 0x02, 0x02, 0x00, 0x00];
    /// <summary>
    /// ISO 639 Text Language Code
    /// </summary>
    /// <remarks>
    /// The short code that represents the language used for text
    /// </remarks>
    private static readonly byte[] ISO639TextLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x03, 0x01, 0x01, 0x02, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Is Optional
    /// </summary>
    /// <remarks>
    /// Specifies whether property is optional (false=0)
    /// </remarks>
    private static readonly byte[] IsOptional = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// ISO Sensitivity
    /// </summary>
    /// <remarks>
    /// Sensitivity to light
    /// </remarks>
    private static readonly byte[] ISOSensitivity = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x01, 0x03, 0x01, 0x0A, 0x00, 0x00];
    /// <summary>
    /// ISO Sensitivity in Long Integer
    /// </summary>
    /// <remarks>
    /// Sensitivity to light  for high sensitivity camera
    /// </remarks>
    private static readonly byte[] ISOSensitivityLongInteger = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x01, 0x03, 0x01, 0x0A, 0x01, 0x00];
    /// <summary>
    /// Is Part  Of
    /// </summary>
    /// <remarks>
    /// A resource that the current resources is a part of
    /// </remarks>
    private static readonly byte[] isPartOf = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x02, 0x07, 0x00, 0x00];
    /// <summary>
    /// ISRC
    /// </summary>
    /// <remarks>
    /// ISO Recording Code
    /// </remarks>
    private static readonly byte[] ISRC = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x11, 0x07, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Is Recording
    /// </summary>
    /// <remarks>
    /// Indicates that the program is a studio recording
    /// </remarks>
    private static readonly byte[] IsRecording = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Is Referenced By
    /// </summary>
    /// <remarks>
    /// A resource that references the current resource
    /// </remarks>
    private static readonly byte[] isReferencedBy = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x02, 0x09, 0x00, 0x00];
    /// <summary>
    /// Is Related To
    /// </summary>
    /// <remarks>
    /// A resource to which the current resource in related
    /// </remarks>
    private static readonly byte[] isRelatedTo = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x02, 0x15, 0x00, 0x00];
    /// <summary>
    /// Is Repeat
    /// </summary>
    /// <remarks>
    /// Indicates that the program has been shown before
    /// </remarks>
    private static readonly byte[] IsRepeat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Is Replaced By
    /// </summary>
    /// <remarks>
    /// A resource replacing the current resource
    /// </remarks>
    private static readonly byte[] isReplacedBy = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x02, 0x03, 0x00, 0x00];
    /// <summary>
    /// Is Required By
    /// </summary>
    /// <remarks>
    /// A resource requirring the current resource
    /// </remarks>
    private static readonly byte[] isRequiredBy = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x02, 0x05, 0x00, 0x00];
    /// <summary>
    /// Is RIP Present
    /// </summary>
    /// <remarks>
    /// Specifies whether the file includes a Random Index Pack.
    /// </remarks>
    private static readonly byte[] IsRIPPresent = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x04, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// ISRN
    /// </summary>
    /// <remarks>
    /// ISO Report Number
    /// </remarks>
    private static readonly byte[] ISRN = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x11, 0x08, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Is Searchable
    /// </summary>
    /// <remarks>
    /// Specifies if information is accessible by searching a database (false=0)
    /// </remarks>
    private static readonly byte[] IsSearchable = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Is Season Of
    /// </summary>
    /// <remarks>
    /// A season that the current resource is a series of
    /// </remarks>
    private static readonly byte[] isSeasonOf = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x02, 0x11, 0x00, 0x00];
    /// <summary>
    /// Is Series Of
    /// </summary>
    /// <remarks>
    /// To identify a parent season or brand.
    /// </remarks>
    private static readonly byte[] isSeriesOf = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x02, 0x18, 0x00, 0x00];
    /// <summary>
    /// Is Signed
    /// </summary>
    /// <remarks>
    /// Specifies if the integer is signed (false=unsigned)
    /// </remarks>
    private static readonly byte[] IsSigned = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x02, 0x03, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// ISSN
    /// </summary>
    /// <remarks>
    /// ISO Serial Number
    /// </remarks>
    private static readonly byte[] ISSN = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x11, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Is Sparse
    /// </summary>
    /// <remarks>
    /// Specifies whether a sparse Index Table is in the essence container.
    /// </remarks>
    private static readonly byte[] IsSparse = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x04, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// ISTC
    /// </summary>
    /// <remarks>
    /// ISO Textual Work Code
    /// </remarks>
    private static readonly byte[] ISTC = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x11, 0x0A, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Speed Change Effect Flag
    /// </summary>
    /// <remarks>
    /// Specifies whether the effect changes the perceived speed of the essence (Slow-motion, fast-motion, and freeze effects = True)
    /// </remarks>
    private static readonly byte[] IsTimeWarp = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x30, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Uniform Data Flag
    /// </summary>
    /// <remarks>
    /// TRUE if the compressed data contains the same number of rows per strip throughout the data
    /// </remarks>
    private static readonly byte[] IsUniform = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x02, 0x01, 0x03, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Is Unique Identifier
    /// </summary>
    /// <remarks>
    /// Specifies that the property defined by this item contains a unique identifier (contains Identifier = true)
    /// </remarks>
    private static readonly byte[] IsUniqueIdentifier = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x07, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Is Version Of
    /// </summary>
    /// <remarks>
    /// The resource from which the current version has been derived
    /// </remarks>
    private static readonly byte[] isVersionOf = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Is Voiceover
    /// </summary>
    /// <remarks>
    /// Indicates that the program has a voiceover
    /// </remarks>
    private static readonly byte[] IsVoiceover = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x01, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// ISWC
    /// </summary>
    /// <remarks>
    /// ISO Musical Work Code
    /// </remarks>
    private static readonly byte[] ISWC = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x11, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Item Designator ID
    /// </summary>
    /// <remarks>
    /// Organizationally given identifier that is the 16-byte Item Designator (SMPTE 336M)  for any data or metadata that uses the SMPTE Universal Label
    /// </remarks>
    private static readonly byte[] ItemDesignatorID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x03, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Item ID
    /// </summary>
    /// <remarks>
    /// Identifier of a content item
    /// </remarks>
    private static readonly byte[] ItemID_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Item Name
    /// </summary>
    /// <remarks>
    /// Defines the name of the parameter as a string
    /// </remarks>
    private static readonly byte[] ItemName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x01, 0x02, 0x0A, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Item Name
    /// </summary>
    /// <remarks>
    /// Defines the name of the parameter as a string
    /// </remarks>
    private static readonly byte[] ItemName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x01, 0x02, 0x0A, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Item Value
    /// </summary>
    /// <remarks>
    /// Defines the value of the parameter as a string
    /// </remarks>
    private static readonly byte[] ItemValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x01, 0x02, 0x0A, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Item Value
    /// </summary>
    /// <remarks>
    /// Defines the value of the parameter as a string
    /// </remarks>
    private static readonly byte[] ItemValue_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x01, 0x02, 0x0A, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// J2C Layout
    /// </summary>
    /// <remarks>
    /// The nature and order of the image components in the compressed domain as carried in the J2C codestream.
    /// </remarks>
    private static readonly byte[] J2CLayout = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x03, 0x0E, 0x00, 0x00, 0x00];
    /// <summary>
    /// J2K Corresponding Profile
    /// </summary>
    /// <remarks>
    /// Facilitate the reversible transcoding of HTJ2K codestreams, as specified in ISO/IEC 15444-15, to and from codestreams that conform to Rec. ISO/IEC 15444-1. The value comprises an array of the Pcpf(i) parameters of the CPF Marker Segment, as specified in ISO/IEC 15444-15.
    /// </remarks>
    private static readonly byte[] J2KCorrespondingProfile = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x03, 0x11, 0x00, 0x00, 0x00];
    /// <summary>
    /// J2K Extended Capabilities
    /// </summary>
    /// <remarks>
    /// Signals that extended capabilities were used to create (and are recommended or required to decode) a codestream. The value is a record that comprises the Pcap parameter followed by an array of consisting of the Ccap(i) parameters of the CAP Marker Segment, as specified in ISO/IEC 15444-1.
    /// </remarks>
    private static readonly byte[] J2KExtendedCapabilities = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x03, 0x0F, 0x00, 0x00, 0x00];
    /// <summary>
    /// J2K Profile
    /// </summary>
    /// <remarks>
    /// Signals the profile to which the codestream conforms. Profiles provide limits on the codestream syntax parameters. The value comprises an array of the Pprf(i) parameters of the PRF Marker Segment, as specified in ISO/IEC 15444-1.
    /// </remarks>
    private static readonly byte[] J2KProfile = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x03, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// JFIF JPEG Processing
    /// </summary>
    /// <remarks>
    /// JFIF JPEG processing performed on the  essence
    /// </remarks>
    private static readonly byte[] JFIFJPEGProcessing = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x02, 0x01, 0x03, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// JFIF Marker Description
    /// </summary>
    /// <remarks>
    /// A freeform textual description of the JFIF image
    /// </remarks>
    private static readonly byte[] JFIFMarkerDescription = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x03, 0x02, 0x01, 0x06, 0x10, 0x01, 0x00, 0x00];
    /// <summary>
    /// JFIF Marker Description
    /// </summary>
    /// <remarks>
    /// A freeform textual description of the JFIF image
    /// </remarks>
    private static readonly byte[] JFIFMarkerDescription_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x03, 0x02, 0x01, 0x06, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// Job Function Name
    /// </summary>
    /// <remarks>
    /// The function of the persons(s), organization or public body  eg. Editor, Actor
    /// </remarks>
    private static readonly byte[] JobFunction = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x30, 0x05, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Job Function Code
    /// </summary>
    /// <remarks>
    /// Code for the function of the participating parties (e.g., editor, actor)
    /// </remarks>
    private static readonly byte[] JobFunctionCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x30, 0x05, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Job Function Information
    /// </summary>
    /// <remarks>
    /// Information about the job function or role of participating parties
    /// </remarks>
    private static readonly byte[] JobFunctionInformation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Job Function Name
    /// </summary>
    /// <remarks>
    /// The function of the persons(s), organization or public body  eg. Editor, Actor
    /// </remarks>
    private static readonly byte[] JobFunctionName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Job Title
    /// </summary>
    /// <remarks>
    /// The normal job title for a contact.   Eg.  Manager, Library Services
    /// </remarks>
    private static readonly byte[] JobTitle = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x30, 0x05, 0x03, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Job Title
    /// </summary>
    /// <remarks>
    /// The normal job title for a contact.   Eg.  Manager, Library Services
    /// </remarks>
    private static readonly byte[] JobTitle_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x30, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// JPEG 2000 Coding Parameters
    /// </summary>
    /// <remarks>
    /// Information about JPEG 2000 picture coding
    /// </remarks>
    private static readonly byte[] JPEG2000CodingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// JPEG Processing
    /// </summary>
    /// <remarks>
    /// JPEG processing performed on the  essence
    /// </remarks>
    private static readonly byte[] JPEGProcessing = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x02, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// JPEG Table ID
    /// </summary>
    /// <remarks>
    /// The code of a preapproved TIFF JPEG table ID
    /// </remarks>
    private static readonly byte[] JPEGTableID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x02, 0x01, 0x03, 0x01, 0x02, 0x00, 0x00];
    /// <summary>
    /// JPEG XS Coding Parameters
    /// </summary>
    /// <remarks>
    /// Parameters about JPEG XS Picture Coding
    /// </remarks>
    private static readonly byte[] JPEGXSCodingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x0B, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// JPEG XS Component Table
    /// </summary>
    /// <remarks>
    /// A byte-wise copy of the component_table Marker Segment in the codestream
    /// </remarks>
    private static readonly byte[] JPEGXSComponentTable = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x0B, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// JPEG XS Cw
    /// </summary>
    /// <remarks>
    /// Specifies the width of a precinct
    /// </remarks>
    private static readonly byte[] JPEGXSCw = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x0B, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// JPEG XS Hf
    /// </summary>
    /// <remarks>
    /// Specifies the height of the image
    /// </remarks>
    private static readonly byte[] JPEGXSHf = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x0B, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// JPEG XS Hsl
    /// </summary>
    /// <remarks>
    /// Specifies the height of a slice
    /// </remarks>
    private static readonly byte[] JPEGXSHsl = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x0B, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// JPEG XS Maximum Bit Rate
    /// </summary>
    /// <remarks>
    /// Specifies the maximum bit rate in Mbit/s
    /// </remarks>
    private static readonly byte[] JPEGXSMaximumBitrate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x0B, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// JPEG XS Nc
    /// </summary>
    /// <remarks>
    /// Specifies the number of components in the image
    /// </remarks>
    private static readonly byte[] JPEGXSNc = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x0B, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// JPEG XS Plev
    /// </summary>
    /// <remarks>
    /// Specifies the JPEG XS Level
    /// </remarks>
    private static readonly byte[] JPEGXSPlev = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x0B, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// JPEG XS Ppih
    /// </summary>
    /// <remarks>
    /// Specifies the JPEG XS Profile
    /// </remarks>
    private static readonly byte[] JPEGXSPpih = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x0B, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// JPEG XS Wf
    /// </summary>
    /// <remarks>
    /// Specifies the width of the image
    /// </remarks>
    private static readonly byte[] JPEGXSWf = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x0B, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Jurisdiction
    /// </summary>
    /// <remarks>
    /// The Law to which a Contract is bound in the event of a dispute.
    /// </remarks>
    private static readonly byte[] Jurisdiction = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x04, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Jurisdiction
    /// </summary>
    /// <remarks>
    /// The Law to which a Contract is bound in the event of a dispute.
    /// </remarks>
    private static readonly byte[] Jurisdiction_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x04, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// JVC
    /// </summary>
    /// <remarks>
    /// Metadata registered by Victor Company of Japan, Limited (JVC) for private use
    /// </remarks>
    private static readonly byte[] JVC = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// KAG Size
    /// </summary>
    /// <remarks>
    /// Size of the KLV Alignment Grid (KAG) for this partition, in bytes
    /// </remarks>
    private static readonly byte[] KAGSize = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x01, 0x02, 0x01, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// KDM ID
    /// </summary>
    /// <remarks>
    /// ID of the KDM
    /// </remarks>
    private static readonly byte[] KDMID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x16, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// KDM XML Data
    /// </summary>
    /// <remarks>
    /// KDM XML data
    /// </remarks>
    private static readonly byte[] KDMXMLData = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x14, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// KDM XML Data Length
    /// </summary>
    /// <remarks>
    /// KDM XML data length
    /// </remarks>
    private static readonly byte[] KDMXMLDataLength = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x13, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Key Code
    /// </summary>
    /// <remarks>
    /// Machine readable version of frame code
    /// </remarks>
    private static readonly byte[] KeyCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x07, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Key Data
    /// </summary>
    /// <remarks>
    /// Freeform textual reference to a key piece of data or program in the data set
    /// </remarks>
    private static readonly byte[] KeyData_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x01, 0x02, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Key Data or Program
    /// </summary>
    /// <remarks>
    /// Local archival location information for key data or program
    /// </remarks>
    private static readonly byte[] KeyDataOrProgram_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Key Frame
    /// </summary>
    /// <remarks>
    /// Local archival location information for key frames
    /// </remarks>
    private static readonly byte[] KeyFrame_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x10, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Anchor Offset
    /// </summary>
    /// <remarks>
    /// The offset in edit units from this edit unit to the previous anchor edit unit (e.g. previous I-frame in MPEG-2)
    /// </remarks>
    private static readonly byte[] KeyFrameOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x04, 0x04, 0x04, 0x02, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Key Frames
    /// </summary>
    /// <remarks>
    /// Freeform textual reference to a key frame of video in the data set
    /// </remarks>
    private static readonly byte[] KeyFrames_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x01, 0x02, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Key Frame Sample Count
    /// </summary>
    /// <remarks>
    /// The number of key frame samples in the subject digital video file
    /// </remarks>
    private static readonly byte[] KeyFrameSampleCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x01, 0x02, 0x0F, 0x00, 0x00, 0x00];
    /// <summary>
    /// Keypoint Kind
    /// </summary>
    /// <remarks>
    /// The Kind of keypoint - e.g. shot category, keyword, key picture, key sound etc
    /// </remarks>
    private static readonly byte[] KeypointKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x03, 0x02, 0x01, 0x02, 0x10, 0x01, 0x00, 0x00];
    /// <summary>
    /// Keypoint Kind
    /// </summary>
    /// <remarks>
    /// The Kind of keypoint - e.g. shot category, keyword, key picture, key sound etc
    /// </remarks>
    private static readonly byte[] KeypointKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x03, 0x02, 0x01, 0x02, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// Key Point Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Key Point sets
    /// </remarks>
    private static readonly byte[] KeyPointObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x12, 0x00];
    /// <summary>
    /// Key Time Point
    /// </summary>
    /// <remarks>
    /// Specifies the point at which a key event occurs
    /// </remarks>
    private static readonly byte[] KeypointPosition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x07, 0x02, 0x01, 0x03, 0x01, 0x07, 0x00, 0x00];
    /// <summary>
    /// Keypoint Value
    /// </summary>
    /// <remarks>
    /// The Value of the keypoint - i.e. the kind of framing, lens effect etc or the actual keyword, key texture, key timbre etc.
    /// </remarks>
    private static readonly byte[] KeypointValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x03, 0x02, 0x01, 0x02, 0x11, 0x01, 0x00, 0x00];
    /// <summary>
    /// Keypoint Value
    /// </summary>
    /// <remarks>
    /// The Value of the keypoint - i.e. the kind of framing, lens effect etc or the actual keyword, key texture, key timbre etc.
    /// </remarks>
    private static readonly byte[] KeypointValue_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x03, 0x02, 0x01, 0x02, 0x11, 0x00, 0x00, 0x00];
    /// <summary>
    /// Key Sound
    /// </summary>
    /// <remarks>
    /// Local archival location information for keys sounds
    /// </remarks>
    private static readonly byte[] KeySound_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x10, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Key Sounds
    /// </summary>
    /// <remarks>
    /// Freeform textual reference to a key sound in the data set
    /// </remarks>
    private static readonly byte[] KeySounds_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x01, 0x02, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Key Text
    /// </summary>
    /// <remarks>
    /// Local archival location information for key text
    /// </remarks>
    private static readonly byte[] KeyText_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Keywords
    /// </summary>
    /// <remarks>
    /// Words or phrases summarizing an aspect of the data set.
    /// </remarks>
    private static readonly byte[] Keywords = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x01, 0x02, 0x05, 0x01, 0x00, 0x00];
    /// <summary>
    /// Keywords
    /// </summary>
    /// <remarks>
    /// Words or phrases summarizing an aspect of the data set.
    /// </remarks>
    private static readonly byte[] Keywords_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x01, 0x02, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// KLV Data Definitions
    /// </summary>
    /// <remarks>
    /// Specifies a unordered set of references to KLV Data Definitions
    /// </remarks>
    private static readonly byte[] KLVDataDefinitions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x06, 0x01, 0x01, 0x04, 0x05, 0x0A, 0x00, 0x00];
    /// <summary>
    /// KLV Data Parent Properties
    /// </summary>
    /// <remarks>
    /// Specifies an unordered set of references to the definitions of properties which may contain this KLVData
    /// </remarks>
    private static readonly byte[] KLVDataParentProperties = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x06, 0x01, 0x01, 0x04, 0x03, 0x04, 0x00, 0x00];
    /// <summary>
    /// KLV Data Type
    /// </summary>
    /// <remarks>
    /// Specifies a reference to the definition of  the type of a KLV packet
    /// </remarks>
    private static readonly byte[] KLVDataType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x06, 0x01, 0x01, 0x04, 0x01, 0x09, 0x00, 0x00];
    /// <summary>
    /// KLV Data Value
    /// </summary>
    /// <remarks>
    /// An entire KLV triplet encoded as the value
    /// </remarks>
    private static readonly byte[] KLVDataValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x02, 0x10, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// KLV Interpretations
    /// </summary>
    /// <remarks>
    /// Defining information about interpreting the KLV construct
    /// </remarks>
    private static readonly byte[] KLVInterpretations = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// KLV Metadata Sequence
    /// </summary>
    /// <remarks>
    /// A sequence of KLV packets
    /// </remarks>
    private static readonly byte[] KLVMetadataSequence = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x02, 0x10, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Knee Point
    /// </summary>
    /// <remarks>
    /// Separation point (K_S,K_F) between the linear part and the curved part of the tone mapping function, ordered K_S,K_F
    /// </remarks>
    private static readonly byte[] KneePoint = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x3F, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Language
    /// </summary>
    /// <remarks>
    /// A set to define languages and their usage in a resource
    /// </remarks>
    private static readonly byte[] language = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x12, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Language Code
    /// </summary>
    /// <remarks>
    /// Codes assigned by BCP-47 for the identification of languages
    /// </remarks>
    private static readonly byte[] languageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x12, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Language Codes
    /// </summary>
    /// <remarks>
    /// Language Codes
    /// </remarks>
    private static readonly byte[] LanguageCodes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Language Name
    /// </summary>
    /// <remarks>
    /// The International Standards Organisation name for a language
    /// </remarks>
    private static readonly byte[] LanguageName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x01, 0x02, 0x10, 0x01, 0x01, 0x00];
    /// <summary>
    /// Language Name
    /// </summary>
    /// <remarks>
    /// The International Standards Organisation name for a language
    /// </remarks>
    private static readonly byte[] LanguageName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x01, 0x02, 0x10, 0x01, 0x00, 0x00];
    /// <summary>
    /// Language Names
    /// </summary>
    /// <remarks>
    /// Language Names
    /// </remarks>
    private static readonly byte[] LanguageNames = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x01, 0x02, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// Language Note
    /// </summary>
    /// <remarks>
    /// A note to provide additional contextual information
    /// </remarks>
    private static readonly byte[] languageNote = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x12, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Language Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to one or more languages
    /// </remarks>
    private static readonly byte[] languageObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x02, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Language Purpose Set
    /// </summary>
    /// <remarks>
    /// A reference to an attribute type group to define the function / purpose associated with the language
    /// </remarks>
    private static readonly byte[] languagePurposeObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x12, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Language Value Object
    /// </summary>
    /// <remarks>
    /// Language name assigned by BCP-47
    /// </remarks>
    private static readonly byte[] languageValueObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x12, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Last Number in Sequence
    /// </summary>
    /// <remarks>
    /// The last number in a sequence
    /// </remarks>
    private static readonly byte[] LastNumberInSequence = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x10, 0x10, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Last Showing Flag
    /// </summary>
    /// <remarks>
    /// A flag to identify a last publication ('True' if set to '1')
    /// </remarks>
    private static readonly byte[] lastShowingFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1C, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Latency
    /// </summary>
    /// <remarks>
    /// Information about response times
    /// </remarks>
    private static readonly byte[] Latency = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Layer Number
    /// </summary>
    /// <remarks>
    /// The layer number of the digital coding
    /// </remarks>
    private static readonly byte[] LayerNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x02, 0x04, 0x03, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Leading Lines
    /// </summary>
    /// <remarks>
    /// Specifies the number of leading lines in the processed image to be blanked before display
    /// </remarks>
    private static readonly byte[] LeadingLines = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x03, 0x02, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Legacy (315M)
    /// </summary>
    /// <remarks>
    /// Legacy usage by SMPTE 315M
    /// </remarks>
    private static readonly byte[] Legacy_315M = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Legal Personalities
    /// </summary>
    /// <remarks>
    /// A person or body in whom legal responsibility can be vested
    /// </remarks>
    private static readonly byte[] LegalPersonalities = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Length
    /// </summary>
    /// <remarks>
    /// Descriptive information about length  (Default is Metric system, metres)
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] Length_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Length
    /// </summary>
    /// <remarks>
    /// The intended length of the advertisement between SOM and EOM
    /// Namespace: http://www.smpte-ra.org/reg/335/2012/13/13
    /// </remarks>
    private static readonly byte[] Length_13 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x0D, 0x0D, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Length System Name
    /// </summary>
    /// <remarks>
    /// Metric, Imperial etc
    /// </remarks>
    private static readonly byte[] LengthSystemName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Length Unit Kind
    /// </summary>
    /// <remarks>
    /// Units of measurements of length and distance (feet, metres etc)
    /// </remarks>
    private static readonly byte[] LengthUnitKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x03, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Lens Aperture
    /// </summary>
    /// <remarks>
    /// Aperture of the lens at the time of collection
    /// </remarks>
    private static readonly byte[] LensAperture = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x20, 0x02, 0x01, 0x01, 0x06, 0x00, 0x00];
    /// <summary>
    /// Lens Attributes
    /// </summary>
    /// <remarks>
    /// Informative description of the lens in use (as a text string).
    /// </remarks>
    private static readonly byte[] LensAttributes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x03, 0x02, 0x03, 0x02, 0x02, 0x10, 0x01, 0x00];
    /// <summary>
    /// Lens Zoom 35mm Still Camera Equivalent
    /// </summary>
    /// <remarks>
    /// 35-mm still camera equivalent focal length in meters
    /// </remarks>
    private static readonly byte[] LensZoom35mmStillCameraEquivalent = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x02, 0x02, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Lens Zoom Actual Focal Length
    /// </summary>
    /// <remarks>
    /// Length in meters between the lens optical center and the image sensor
    /// </remarks>
    private static readonly byte[] LensZoomActualFocalLength = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x02, 0x02, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// License Options Description
    /// </summary>
    /// <remarks>
    /// Options for prolongation or renewal of license
    /// </remarks>
    private static readonly byte[] LicenseOptionsDescription_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x05, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Line Number
    /// </summary>
    /// <remarks>
    /// Specifies the video line number to which a block of essence data corresponds
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] LineNumber_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x01, 0x03, 0x02, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Line Number
    /// </summary>
    /// <remarks>
    /// The line number of this stored ANC packet according to SMPTE 377M-2004 E.1.5
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] LineNumber_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x38, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Linked Application Plug-In Instance ID
    /// </summary>
    /// <remarks>
    /// Weak Reference to the Application PlugIn Object that (directly or indirectly) strongly references this Application Metadata Referenced Object Set.
    /// </remarks>
    private static readonly byte[] LinkedApplicationPluginInstanceID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x05, 0x20, 0x07, 0x01, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Linked Data Stream ID
    /// </summary>
    /// <remarks>
    /// Unique identifer of Data Stream described by this SubDescriptor
    /// </remarks>
    private static readonly byte[] LinkedDataStreamID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x06, 0x01, 0x01, 0x02, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Linked Descriptive Framework Plug-In ID
    /// </summary>
    /// <remarks>
    /// Weak Reference to the DM Segment that (directly or indirectly) strongly references this Description instance
    /// </remarks>
    private static readonly byte[] LinkedDescriptiveFrameworkPluginID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x05, 0x20, 0x07, 0x01, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Linked Descriptive Object Plug-In ID
    /// </summary>
    /// <remarks>
    /// Weak Reference to the DM Segment that (directly or indirectly) strongly references this Description instance
    /// </remarks>
    private static readonly byte[] LinkedDescriptiveObjectPluginID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x05, 0x20, 0x07, 0x01, 0x11, 0x00, 0x00, 0x00];
    /// <summary>
    /// Linked Generation ID
    /// </summary>
    /// <remarks>
    /// Specifies the reference to an overall modification
    /// </remarks>
    private static readonly byte[] LinkedGenerationID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x07, 0x01, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Linked Package ID
    /// </summary>
    /// <remarks>
    /// Specifes a reference to a package associated with Essence Data
    /// </remarks>
    private static readonly byte[] LinkedPackageID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x06, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Linked Timecode Track ID
    /// </summary>
    /// <remarks>
    /// AES3 association of SMPTE 337M time stamp to Timecode Track IDs.
    /// </remarks>
    private static readonly byte[] LinkedTimecodeTrackID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x04, 0x02, 0x05, 0x01, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Linked Track ID
    /// </summary>
    /// <remarks>
    /// Link to (i.e. value of) the Track ID of the Track in this Package to which the Essence Descriptor applies.
    /// </remarks>
    private static readonly byte[] LinkedTrackID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x03, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Linking Name
    /// </summary>
    /// <remarks>
    /// A link used between family, given and other names (e.g. den, ten, van den, von)
    /// </remarks>
    private static readonly byte[] LinkingName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x02, 0x30, 0x06, 0x03, 0x01, 0x0A, 0x01, 0x00];
    /// <summary>
    /// Linking Name
    /// </summary>
    /// <remarks>
    /// A link used between family, given and other names (e.g. den, ten, van den, von)
    /// </remarks>
    private static readonly byte[] LinkingName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x02, 0x30, 0x06, 0x03, 0x01, 0x0A, 0x00, 0x00];
    /// <summary>
    /// Live Production Flag
    /// </summary>
    /// <remarks>
    /// A flag to indicate that production was being made live
    /// </remarks>
    private static readonly byte[] liveProductionFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1C, 0x11, 0x00, 0x00, 0x00];
    /// <summary>
    /// Live Publication Flag
    /// </summary>
    /// <remarks>
    /// A flag to identify a live publication ('True' if set to '1')
    /// </remarks>
    private static readonly byte[] livePublicationFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1C, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// LOC_ApplicationSpecifications_Elements
    /// </summary>
    /// <remarks>
    /// Library of Congress Application Specifications Elements
    /// </remarks>
    private static readonly byte[] LOC_ApplicationSpecifications_Elements = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// LOC_ApplicationSpecifications_Elements_V1
    /// </summary>
    /// <remarks>
    /// Library of Congress Application Specifications Elements V1
    /// </remarks>
    private static readonly byte[] LOC_ApplicationSpecifications_Elements_V1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// LOC_Elements
    /// </summary>
    /// <remarks>
    /// Metadata registered by the Library of Congress for public use
    /// </remarks>
    private static readonly byte[] LOC_Elements = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x0D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Local Creation Date-Time
    /// </summary>
    /// <remarks>
    /// Identifies date and time at the point of creation.
    /// </remarks>
    private static readonly byte[] LocalCreationDateTime_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x10, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Local Data Relationships
    /// </summary>
    /// <remarks>
    /// Generic Relationships between data
    /// </remarks>
    private static readonly byte[] LocalDataRelationships = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x09, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Local Datum Absolute Position
    /// </summary>
    /// <remarks>
    /// The absolute position of a local datum
    /// </remarks>
    private static readonly byte[] LocalDatumAbsolutePosition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Local Datum Absolute Position Accuracy
    /// </summary>
    /// <remarks>
    /// The accuracy with which the measurement of absolute position of the local datum is made, (default metres)
    /// </remarks>
    private static readonly byte[] LocalDatumAbsolutePositionAccuracy = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Local Datum Relative Position
    /// </summary>
    /// <remarks>
    /// The relative position of a local datum to another specified datum
    /// </remarks>
    private static readonly byte[] LocalDatumRelativePosition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Local Datum Relative Position Accuracy
    /// </summary>
    /// <remarks>
    /// The accuracy with which the measurement of relative position of the local datum is made
    /// </remarks>
    private static readonly byte[] LocalDatumRelativePositionAccuracy = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x02, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Local End Date-Time
    /// </summary>
    /// <remarks>
    /// Absolute time at end of creating the segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] LocalEndDateTime_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x02, 0x03, 0x02, 0x00, 0x00];
    /// <summary>
    /// Local Event End Date-Time
    /// </summary>
    /// <remarks>
    /// The absolute ending date and time of the project, mission, scene, editing event, license, publication etc
    /// </remarks>
    private static readonly byte[] LocalEventEndDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x07, 0x02, 0x01, 0x02, 0x09, 0x02, 0x01, 0x00];
    /// <summary>
    /// Local Event Start Date-Time
    /// </summary>
    /// <remarks>
    /// The absolute beginning date and time of the project, mission, scene, editing event, license, publication etc
    /// </remarks>
    private static readonly byte[] LocalEventStartDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x07, 0x02, 0x01, 0x02, 0x07, 0x02, 0x01, 0x00];
    /// <summary>
    /// Local File Path
    /// </summary>
    /// <remarks>
    /// The local path to a complete digital media, data, metadata etc file
    /// </remarks>
    private static readonly byte[] LocalFilePath = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x04, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Local File Path
    /// </summary>
    /// <remarks>
    /// The local path to a complete digital media, data, metadata etc file
    /// </remarks>
    private static readonly byte[] LocalFilePath_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Local Film ID
    /// </summary>
    /// <remarks>
    /// Organizationally given identifiers for film
    /// </remarks>
    private static readonly byte[] LocalFilmID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Local ID
    /// </summary>
    /// <remarks>
    /// Specifies a local identifier used by the container format to identity a property
    /// </remarks>
    private static readonly byte[] LocalIdentification = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x07, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Local Identifiers
    /// </summary>
    /// <remarks>
    /// Local identifiers which are not unique other than at low level
    /// </remarks>
    private static readonly byte[] LocalIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Local Last Modification Date-Time
    /// </summary>
    /// <remarks>
    /// Absolute time of the last modification of the segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] LocalLastModificationDateTime_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x02, 0x05, 0x02, 0x00, 0x00];
    /// <summary>
    /// Locally Unique Identifiers
    /// </summary>
    /// <remarks>
    /// Identifier unique to the local context
    /// </remarks>
    private static readonly byte[] LocallyUniqueIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Locally Unique Locators
    /// </summary>
    /// <remarks>
    /// Locally unique path definitions
    /// </remarks>
    private static readonly byte[] LocallyUniqueLocators = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Local Modification Date-Time
    /// </summary>
    /// <remarks>
    /// Identifies date and time at the point of modification
    /// </remarks>
    private static readonly byte[] LocalModificationDateTime_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x10, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Local Object Identifiers
    /// </summary>
    /// <remarks>
    /// Object identifiers
    /// </remarks>
    private static readonly byte[] LocalObjectIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Local Physical Media Identifiers
    /// </summary>
    /// <remarks>
    /// Organizationally given identifiers for physical media
    /// </remarks>
    private static readonly byte[] LocalPhysicalMediaIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Local Start Date-Time
    /// </summary>
    /// <remarks>
    /// Absolute time at start of creating the segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] LocalStartDateTime_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x02, 0x01, 0x02, 0x00, 0x00];
    /// <summary>
    /// Local Tag Value
    /// </summary>
    /// <remarks>
    /// A locally unique registry identifier - the value is the local Tag in the local Registry
    /// </remarks>
    private static readonly byte[] LocalTag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x03, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Local Tag Entries
    /// </summary>
    /// <remarks>
    /// Specifies an unordered batch of local tag/UID pairs used to map UIDs to the local tags of a local set.
    /// </remarks>
    private static readonly byte[] LocalTagEntries = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x07, 0x15, 0x00, 0x00, 0x00];
    /// <summary>
    /// Local Tag Unique ID
    /// </summary>
    /// <remarks>
    /// A Unique Identifier of which the local tag is an alias
    /// </remarks>
    private static readonly byte[] LocalTagUniqueID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x03, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Local Tape Identifiers
    /// </summary>
    /// <remarks>
    /// Organizationally given identifiers for tape
    /// </remarks>
    private static readonly byte[] LocalTapeIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Local Tape Number
    /// </summary>
    /// <remarks>
    /// An organizationally given number for a tape.
    /// </remarks>
    private static readonly byte[] LocalTapeNumber_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Local Target ID
    /// </summary>
    /// <remarks>
    /// A free-text, locally defined name or ID of one or more individual targets or target areas in a motion imagery stream. The image originators are free to populate this field as needed with values from their own target naming or numbering system.
    /// </remarks>
    private static readonly byte[] LocalTargetID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x01, 0x03, 0x01, 0x07, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Local Target ID
    /// </summary>
    /// <remarks>
    /// A free-text, locally defined name or ID of one or more individual targets or target areas in a motion imagery stream. The image originators are free to populate this field as needed with values from their own target naming or numbering system.
    /// </remarks>
    private static readonly byte[] LocalTargetID_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x03, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Local User Date-Time
    /// </summary>
    /// <remarks>
    /// Time stamp application defined by user application
    /// </remarks>
    private static readonly byte[] LocalUserDateTime_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x01, 0x01, 0x02, 0x00, 0x00];
    /// <summary>
    /// Location
    /// </summary>
    /// <remarks>
    /// Location details
    /// </remarks>
    private static readonly byte[] location = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x15, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Location Code
    /// </summary>
    /// <remarks>
    /// A code associated with a location
    /// </remarks>
    private static readonly byte[] locationCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x15, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Location Coordinates Set
    /// </summary>
    /// <remarks>
    /// A strong reference to associated coordinates
    /// </remarks>
    private static readonly byte[] locationCoordinatesObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x15, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Location Definition Note
    /// </summary>
    /// <remarks>
    /// A reference to an attribute type group
    /// </remarks>
    private static readonly byte[] locationDefinitionNote = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x15, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Location Description
    /// </summary>
    /// <remarks>
    /// The description of a location covered by a data set.
    /// </remarks>
    private static readonly byte[] LocationDescription = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x07, 0x01, 0x20, 0x02, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Location Description
    /// </summary>
    /// <remarks>
    /// The description of a location covered by a data set.
    /// </remarks>
    private static readonly byte[] LocationDescription_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x07, 0x01, 0x20, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Location Dimensions
    /// </summary>
    /// <remarks>
    /// Length measurements relating to the size of the location or studio in which the essence was catured
    /// </remarks>
    private static readonly byte[] LocationDimensions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x09, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Location ID
    /// </summary>
    /// <remarks>
    /// An identifier associated with a location
    /// </remarks>
    private static readonly byte[] locationID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x15, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Location Kind
    /// </summary>
    /// <remarks>
    /// The kind of location - e.g. the location of the camera, the location of the action etc
    /// </remarks>
    private static readonly byte[] LocationKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x07, 0x01, 0x20, 0x02, 0x03, 0x01, 0x00, 0x00];
    /// <summary>
    /// Location Kind
    /// </summary>
    /// <remarks>
    /// The kind of location - e.g. the location of the camera, the location of the action etc
    /// </remarks>
    private static readonly byte[] LocationKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x07, 0x01, 0x20, 0x02, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Media Location
    /// </summary>
    /// <remarks>
    /// A description of the physical location of media - e.g. which archive, place, rack, shelf, position on shelf
    /// </remarks>
    private static readonly byte[] LocationName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x04, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Physical Media Location
    /// </summary>
    /// <remarks>
    /// A description of the physical location of media - e.g. which archive, place, rack, shelf, position on shelf
    /// </remarks>
    private static readonly byte[] LocationName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x04, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Location Name Sets
    /// </summary>
    /// <remarks>
    /// One or more names associated with a location optionally in different languages
    /// </remarks>
    private static readonly byte[] locationNameObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x15, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Shot Location Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Location sets
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] LocationObjects_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x16, 0x00];
    /// <summary>
    /// Location Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to location objects
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] LocationObjects_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x14, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Location Region Set
    /// </summary>
    /// <remarks>
    /// A reference to a region set
    /// </remarks>
    private static readonly byte[] locationRegionObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x15, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Location Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of generalized weak (global) references to Location sets
    /// </remarks>
    private static readonly byte[] Locations = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x03, 0x40, 0x16, 0x00];
    /// <summary>
    /// Location Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group to specify the type of location information being provided
    /// </remarks>
    private static readonly byte[] locationTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x15, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Locator
    /// </summary>
    /// <remarks>
    /// A set of attributes to define a locator
    /// </remarks>
    private static readonly byte[] locator = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x47, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Essence Locators
    /// </summary>
    /// <remarks>
    /// Specifies a vector of references to essence locators
    /// </remarks>
    private static readonly byte[] Locators = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x06, 0x03, 0x00, 0x00];
    /// <summary>
    /// Locator Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a type group to define the type of locator
    /// </remarks>
    private static readonly byte[] locatorTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x47, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Locator Value Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a value of locator
    /// </remarks>
    private static readonly byte[] locatorValueObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x47, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Locked Indicator
    /// </summary>
    /// <remarks>
    /// TRUE if number of samples per frame is locked to video
    /// </remarks>
    private static readonly byte[] Locked = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x04, 0x02, 0x03, 0x01, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Logo Flag
    /// </summary>
    /// <remarks>
    /// Flag indicates all instances of a shot (specifically) contain an on-screen logo.  True=contains logo; False=no logo
    /// </remarks>
    private static readonly byte[] LogoFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Loudness Correction Type
    /// </summary>
    /// <remarks>
    /// Correction type for the audio, e.g. file-based or real-time.
    /// </remarks>
    private static readonly byte[] loudnessCorrectionType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4C, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Loudness Max Momentary
    /// </summary>
    /// <remarks>
    /// The MaxMomentaryLoudness in LUFS
    /// </remarks>
    private static readonly byte[] loudnessMaxMomentary = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4C, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Loudness Max Short Term
    /// </summary>
    /// <remarks>
    /// The MaxShortTermLoudness in LUFS
    /// </remarks>
    private static readonly byte[] loudnessMaxShortTerm = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4C, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Loudness Max True Peak
    /// </summary>
    /// <remarks>
    /// The max TruePeak Level (TPL) in dBTP
    /// </remarks>
    private static readonly byte[] loudnessMaxTruePeak = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4C, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Loudness Metadata
    /// </summary>
    /// <remarks>
    /// A set of attributes to describe loudness
    /// </remarks>
    private static readonly byte[] loudnessMetadata = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4C, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Loudness Method
    /// </summary>
    /// <remarks>
    /// The method used to measure loudness
    /// </remarks>
    private static readonly byte[] loudnessMethod = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4C, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Loudness Range
    /// </summary>
    /// <remarks>
    /// The Loudness Range (LRA) in LU
    /// </remarks>
    private static readonly byte[] loudnessRange = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4C, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Loudness Recommendation Type
    /// </summary>
    /// <remarks>
    /// Regional recommendend practice for correcting loudness levels.
    /// </remarks>
    private static readonly byte[] loudnessRecType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x4C, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Low Delay Indicator
    /// </summary>
    /// <remarks>
    /// TRUE if low delay mode was used in the sequence
    /// </remarks>
    private static readonly byte[] LowDelay = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x01, 0x06, 0x02, 0x01, 0x05, 0x00, 0x00];
    /// <summary>
    /// Lower Right Corner
    /// </summary>
    /// <remarks>
    /// Coordinate of the bottom-right pixel of the Processing Window
    /// </remarks>
    private static readonly byte[] LowerRightCorner = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// LUID
    /// </summary>
    /// <remarks>
    /// A 4 byte locally unique ID
    /// </remarks>
    private static readonly byte[] LUID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Luma Equation
    /// </summary>
    /// <remarks>
    /// Specifies the equation used to derive luma and chroma from gamma-corrected RGB signals
    /// </remarks>
    private static readonly byte[] LumaEquation_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x02, 0x01, 0x01, 0x02, 0x00, 0x00];
    /// <summary>
    /// Luminance Code Range
    /// </summary>
    /// <remarks>
    /// Video level limitation and scaling
    /// </remarks>
    private static readonly byte[] LuminanceCodeRange = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x01, 0x03, 0x01, 0x12, 0x00, 0x00];
    /// <summary>
    /// Luminance Lower Bound
    /// </summary>
    /// <remarks>
    /// Encoding of a lower bound of luminance
    /// </remarks>
    private static readonly byte[] LuminanceLowerBound = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x19, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Luminance Range Selector
    /// </summary>
    /// <remarks>
    /// True indicates inner luminance range
    /// </remarks>
    private static readonly byte[] LuminanceRangeSelector = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x1B, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Luminance Sample Rate
    /// </summary>
    /// <remarks>
    /// The luminance sample rate
    /// </remarks>
    private static readonly byte[] LuminanceSampleRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Luminance Upper Bound
    /// </summary>
    /// <remarks>
    /// Encoding of an upper bound of luminance
    /// </remarks>
    private static readonly byte[] LuminanceUpperBound = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x1A, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Machine-Assigned or Computed Descriptions
    /// </summary>
    /// <remarks>
    /// Descriptors (Machine Assigned or Computed) relating to analysis of the content
    /// </remarks>
    private static readonly byte[] MachineAssignedOrComputedDescriptions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Macro Setting
    /// </summary>
    /// <remarks>
    /// Indicates the capability of the lens macro function for close-up work with a limited focal range. True = On, False = Off
    /// </remarks>
    private static readonly byte[] MacroSetting = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x02, 0x02, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Magnetic Disk Number
    /// </summary>
    /// <remarks>
    /// An organizationally given number for a magnetic disc or disc pack.
    /// </remarks>
    private static readonly byte[] MagneticDiskNumber_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x03, 0x02, 0x03, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Magnetic Disks
    /// </summary>
    /// <remarks>
    /// Information about magnetic disks.
    /// </remarks>
    private static readonly byte[] MagneticDisks = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x03, 0x02, 0x03, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Magnetic Track
    /// </summary>
    /// <remarks>
    /// The kind of magnetic track from which the sound was recovered
    /// </remarks>
    private static readonly byte[] MagneticTrack_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x08, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Main Catalog Number
    /// </summary>
    /// <remarks>
    /// The main catalogue number for a recording
    /// </remarks>
    private static readonly byte[] MainCatalogNumber_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x10, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Main Name
    /// </summary>
    /// <remarks>
    /// The main name by which the group is known
    /// </remarks>
    private static readonly byte[] MainName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x30, 0x06, 0x03, 0x02, 0x01, 0x01, 0x00];
    /// <summary>
    /// Main Name
    /// </summary>
    /// <remarks>
    /// The main name by which the group is known
    /// </remarks>
    private static readonly byte[] MainName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x06, 0x03, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Main Sponsor Name
    /// </summary>
    /// <remarks>
    /// Contains the name of the sponsor of the program
    /// </remarks>
    private static readonly byte[] MainSponsorName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x0A, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Main Title
    /// </summary>
    /// <remarks>
    /// The main title
    /// </remarks>
    private static readonly byte[] MainTitle = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x05, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Main Title
    /// </summary>
    /// <remarks>
    /// The main title
    /// </remarks>
    private static readonly byte[] MainTitle_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Major Version
    /// </summary>
    /// <remarks>
    /// A major version number.  A change in a major version implies non-backwards compatibility
    /// </remarks>
    private static readonly byte[] MajorVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x03, 0x01, 0x02, 0x01, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Male Lead Actor Name
    /// </summary>
    /// <remarks>
    /// Contains the name of the male lead actor of the program
    /// </remarks>
    private static readonly byte[] MaleLeadActorName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x0A, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Manipulation
    /// </summary>
    /// <remarks>
    /// Information about content manipulation
    /// </remarks>
    private static readonly byte[] Manipulation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Manufacturer ID
    /// </summary>
    /// <remarks>
    /// An identifier for the manufacturer or maker of the device
    /// </remarks>
    private static readonly byte[] ManufacturerID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x0A, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Manufacturer Identifiers
    /// </summary>
    /// <remarks>
    /// Unique Identifiers for Manufacturers
    /// </remarks>
    private static readonly byte[] ManufacturerIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x0A, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Manufacturer Information Object
    /// </summary>
    /// <remarks>
    /// Specifies a reference to an object that provides information about the manufacturer
    /// </remarks>
    private static readonly byte[] ManufacturerInfo = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x02, 0x0B, 0x00, 0x00];
    /// <summary>
    /// Manufacturing Organization Identifiers
    /// </summary>
    /// <remarks>
    /// Unique Identifiers for Manufacturing Organizations
    /// </remarks>
    private static readonly byte[] ManufacturingOrganizationIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x0A, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Map Datum Used
    /// </summary>
    /// <remarks>
    /// Identifies the Digital Geographic Information Exchange Standard (DIGEST) map datum used to derive the  coordinates (UTM or GEO).
    /// </remarks>
    private static readonly byte[] MapDatumUsed_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Mark In
    /// </summary>
    /// <remarks>
    /// Specifies an optional IN point mark. The position is measured relative to the origin, in edit units, and applies to the track of material in which it is specified.
    /// </remarks>
    private static readonly byte[] MarkIn = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x07, 0x02, 0x01, 0x03, 0x01, 0x0C, 0x00, 0x00];
    /// <summary>
    /// Mark Out
    /// </summary>
    /// <remarks>
    /// Specifies an optional OUT point mark. The position is measured relative to the origin, in edit units, and applies to the track of material in which it is specified.
    /// </remarks>
    private static readonly byte[] MarkOut = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x07, 0x02, 0x01, 0x03, 0x02, 0x03, 0x00, 0x00];
    /// <summary>
    /// Mass
    /// </summary>
    /// <remarks>
    /// Descriptive information about Mass (Default is Metric system, Kilogramme)
    /// </remarks>
    private static readonly byte[] Mass = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Mastering Display Actual Peak Luminance
    /// </summary>
    /// <remarks>
    /// Two-input sampled function representing the normalized actual peak luminance of the mastering display, in units of 1/15. The four most significant bits in each UInt8 are zero.
    /// </remarks>
    private static readonly byte[] MasteringDisplayActualPeakLuminance = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x38, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Mastering Display Characteristics
    /// </summary>
    /// <remarks>
    /// Information about mastering display devices as configured for the mastering process
    /// </remarks>
    private static readonly byte[] MasteringDisplayCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Mastering Display Color Volume
    /// </summary>
    /// <remarks>
    /// Information about the color volume of a mastering display device as configured for the mastering process
    /// </remarks>
    private static readonly byte[] MasteringDisplayColorVolume = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x04, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Mastering Display Maximum Luminance
    /// </summary>
    /// <remarks>
    /// Maximum Display Mastering Luminance metadata as specified in ST 2086
    /// </remarks>
    private static readonly byte[] MasteringDisplayMaximumLuminance = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x04, 0x01, 0x01, 0x03, 0x00, 0x00];
    /// <summary>
    /// Mastering Display Minimum Luminance
    /// </summary>
    /// <remarks>
    /// Minimum Display Mastering Luminance metadata as specified in ST 2086
    /// </remarks>
    private static readonly byte[] MasteringDisplayMinimumLuminance = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x04, 0x01, 0x01, 0x04, 0x00, 0x00];
    /// <summary>
    /// Mastering Display Primaries
    /// </summary>
    /// <remarks>
    /// Display Primaries metadata as specified in ST 2086
    /// </remarks>
    private static readonly byte[] MasteringDisplayPrimaries = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x04, 0x01, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Mastering Display White Point Chromaticity
    /// </summary>
    /// <remarks>
    /// Chromaticity of White Point metadata as specified in ST 2086
    /// </remarks>
    private static readonly byte[] MasteringDisplayWhitePointChromaticity = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x04, 0x01, 0x01, 0x02, 0x00, 0x00];
    /// <summary>
    /// Material Absolute Duration
    /// </summary>
    /// <remarks>
    /// The absolute duration of the segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] MaterialAbsoluteDuration = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x02, 0x01, 0x02, 0x02, 0x00, 0x00];
    /// <summary>
    /// Material Absolute Duration
    /// </summary>
    /// <remarks>
    /// The absolute duration of the segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] MaterialAbsoluteDuration_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x02, 0x01, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Material Absolute Durations
    /// </summary>
    /// <remarks>
    /// The absolute duration of the segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] MaterialAbsoluteDurations = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x02, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Material End Relative Times
    /// </summary>
    /// <remarks>
    /// The relative end time of the segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] MaterialEndRelativeTimes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x03, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Material End Time Address
    /// </summary>
    /// <remarks>
    /// Media time at end of segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] MaterialEndTimeAddress = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Material End Timecode Offset
    /// </summary>
    /// <remarks>
    /// The relative end time of the segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] MaterialEndTimecodeOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x03, 0x02, 0x02, 0x00, 0x00];
    /// <summary>
    /// Material End Time Offset
    /// </summary>
    /// <remarks>
    /// The relative end time of the segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] MaterialEndTimeOffset_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x03, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Material End True Date-Time
    /// </summary>
    /// <remarks>
    /// Absolute time at end of creating the segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] MaterialEndTrueDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Material Occurrence Time Address
    /// </summary>
    /// <remarks>
    /// Media time of the last modification of the segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] MaterialOccurrenceTimeAddress = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x02, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Material Occurrence True Date-Time
    /// </summary>
    /// <remarks>
    /// Absolute time of an occurance to the segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] MaterialOccurrenceTrueDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x02, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Material Offsets
    /// </summary>
    /// <remarks>
    /// Information about material offset timing
    /// </remarks>
    private static readonly byte[] MaterialOffsets = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x03, 0x10, 0x01, 0x00, 0x00];
    /// <summary>
    /// Material Start Relative Times
    /// </summary>
    /// <remarks>
    /// The relative start time of the segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] MaterialStartRelativeTimes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Material Start Time Address
    /// </summary>
    /// <remarks>
    /// Media time at start of segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] MaterialStartTimeAddress = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Material Start True Date-Time
    /// </summary>
    /// <remarks>
    /// Absolute time at start of creating the segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] MaterialStartTrueDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Maximum B Picture Count
    /// </summary>
    /// <remarks>
    /// Specifies the maximum number of B pictures between P or I frames, equivalent to 13818-2 annex D (M-1)
    /// </remarks>
    private static readonly byte[] MaxBPictureCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x01, 0x06, 0x02, 0x01, 0x09, 0x00, 0x00];
    /// <summary>
    /// Max Channel Count
    /// </summary>
    /// <remarks>
    /// Maximum number of audio channels in the bitstream
    /// </remarks>
    private static readonly byte[] MaxChannelCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x0E, 0x09, 0x05, 0x07, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Maximum Supported Engine Version
    /// </summary>
    /// <remarks>
    /// Most-recent tested version of the Engine
    /// </remarks>
    private static readonly byte[] MaxEngineVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x09, 0x07, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Maximum GOP Size
    /// </summary>
    /// <remarks>
    /// Specifies the maximum occurring spacing between I frames, per 13818-1 IBP descriptor. A value of 0 or the absence of this property implies no limit to the maximum GOP
    /// </remarks>
    private static readonly byte[] MaxGOP = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x01, 0x06, 0x02, 0x01, 0x08, 0x00, 0x00];
    /// <summary>
    /// Maximum Content Light Level
    /// </summary>
    /// <remarks>
    /// Maximum Content Light Level as specified in Rec. ITU-T H.265
    /// </remarks>
    private static readonly byte[] MaximumContentLightLevel = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x42, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Maximum Frame Average Light Level
    /// </summary>
    /// <remarks>
    /// Maximum Frame Average Light Level as specified in Rec. ITU-T H.265
    /// </remarks>
    private static readonly byte[] MaximumFrameAverageLightLevel = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x43, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Maximum PQ-encoded maxRGB
    /// </summary>
    /// <remarks>
    /// The highest PQ-encoded maxRGB value of the reduced pixel set
    /// </remarks>
    private static readonly byte[] MaximumPqencodedMaxrgb = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x0F, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Maximum PQ-encoded maxRGB Offset
    /// </summary>
    /// <remarks>
    /// Offset to be added to Maximum PQ-encoded maxRGB
    /// </remarks>
    private static readonly byte[] MaximumPqencodedMaxrgbOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x12, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Maximum Use Count
    /// </summary>
    /// <remarks>
    /// Maximum number of usages or repeats
    /// </remarks>
    private static readonly byte[] MaxNumberOfUsages = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x05, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Max Object Count
    /// </summary>
    /// <remarks>
    /// Maximum number of audio objects in the bitstream
    /// </remarks>
    private static readonly byte[] MaxObjectCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x0E, 0x09, 0x05, 0x08, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Maximum Supported Platform Version
    /// </summary>
    /// <remarks>
    /// Most-recent tested version of the platform
    /// </remarks>
    private static readonly byte[] MaxPlatformVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x09, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Maximum API Version
    /// </summary>
    /// <remarks>
    /// Most-recent tested version of the API
    /// </remarks>
    private static readonly byte[] MaxPluginAPI = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x09, 0x0A, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Maximum Scene Color Component Levels
    /// </summary>
    /// <remarks>
    /// Maximum of each component of linearized RGB values
    /// </remarks>
    private static readonly byte[] MaxSCL = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x3A, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// MCA Additional Language Attributes
    /// </summary>
    /// <remarks>
    /// Indication of whether each RFC 5646 language tag in RFC 5646 Additional Spoken Languages references original audio or dubbed audio
    /// </remarks>
    private static readonly byte[] MCAAdditionalLanguageAttributes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x03, 0x02, 0x01, 0x02, 0x28, 0x00, 0x00, 0x00];
    /// <summary>
    /// MCA Audio Content Kind
    /// </summary>
    /// <remarks>
    /// The MCA Audio Content Kind item shall indicate the kind of content contained in the audio essence as described in SMPTE RP 428-4.
    /// </remarks>
    private static readonly byte[] MCAAudioContentKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x03, 0x02, 0x01, 0x02, 0x20, 0x00, 0x00, 0x00];
    /// <summary>
    /// MCA Audio Element Kind
    /// </summary>
    /// <remarks>
    /// The MCA Audio Element Kind item shall indicate the kind of audio element contained in the audio essence as described in SMPTE RP 428-4.
    /// </remarks>
    private static readonly byte[] MCAAudioElementKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x03, 0x02, 0x01, 0x02, 0x21, 0x00, 0x00, 0x00];
    /// <summary>
    /// MCA Channel ID
    /// </summary>
    /// <remarks>
    /// The numerical channel identifier within the essence, as defined in SMPTE ST 377-1:2011 Amendment1:2012 (Annex B.23 extension, if applicable).
    /// </remarks>
    private static readonly byte[] MCAChannelID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x01, 0x03, 0x04, 0x0A, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// MCA Content
    /// </summary>
    /// <remarks>
    /// Unique value that identifies the content contained in the audio essence
    /// </remarks>
    private static readonly byte[] MCAContent = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x03, 0x02, 0x01, 0x02, 0x22, 0x00, 0x00, 0x00];
    /// <summary>
    /// MCA Content Differentiator
    /// </summary>
    /// <remarks>
    /// Label that distinguishes between audio that otherwise has the same MCALabelSubDescriptor values
    /// </remarks>
    private static readonly byte[] MCAContentDifferentiator = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x03, 0x02, 0x01, 0x02, 0x25, 0x00, 0x00, 0x00];
    /// <summary>
    /// MCA Content Subtype
    /// </summary>
    /// <remarks>
    /// Supplemental modifier to MCA Content
    /// </remarks>
    private static readonly byte[] MCAContentSubtype = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x03, 0x02, 0x01, 0x02, 0x24, 0x00, 0x00, 0x00];
    /// <summary>
    /// MCA Episode
    /// </summary>
    /// <remarks>
    /// Episode of an MCA title.
    /// </remarks>
    private static readonly byte[] MCAEpisode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x01, 0x05, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// MCA Label Dictionary ID
    /// </summary>
    /// <remarks>
    /// The globally registered UL that defines the meaning of the MCALabelSubDescriptor instance.
    /// </remarks>
    private static readonly byte[] MCALabelDictionaryID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x01, 0x03, 0x07, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// MCA Link ID
    /// </summary>
    /// <remarks>
    /// Uniquely identifies the audio channel, soundfield group and group of soundfield groups instance described by the MCALabelSubDescriptor and is used to link instances of MCALabelSubDescriptors.
    /// </remarks>
    private static readonly byte[] MCALinkID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x01, 0x03, 0x07, 0x01, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// MCA Partition Kind
    /// </summary>
    /// <remarks>
    /// Partition kind of a complete program such as a "Part", "Post Production Reel" or "Act".
    /// </remarks>
    private static readonly byte[] MCAPartitionKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x01, 0x04, 0x01, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// MCA Partition Number
    /// </summary>
    /// <remarks>
    /// The position of the partition in the sequence of partitions that make up the complete program such as "3" for Reel 3.
    /// </remarks>
    private static readonly byte[] MCAPartitionNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x01, 0x04, 0x01, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// MCA Spoken Language Attribute
    /// </summary>
    /// <remarks>
    /// Depiction of whether the RFC 5646 Spoken Language is the original language or a dubbed language
    /// </remarks>
    private static readonly byte[] MCASpokenLanguageAttribute = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x03, 0x02, 0x01, 0x02, 0x26, 0x00, 0x00, 0x00];
    /// <summary>
    /// MCA Tag Name
    /// </summary>
    /// <remarks>
    /// Optional text string that may be given to the MCALabelSubDescriptor to further describe it in human readable form, e.g. "Left Surround" for an AudioChannelLabelSubDescriptor Name, "5.1" for a SoundfieldGroupLabelSubDescriptor Name.
    /// </remarks>
    private static readonly byte[] MCATagName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x01, 0x03, 0x07, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// MCA Tag Symbol
    /// </summary>
    /// <remarks>
    /// Symbol identifying this MCALabelSubDescriptor, which mnemonically reflects the meaning as defined in the MCA Label Dictionary ID, e.g. "cLs" for an AudioChannelLabelSubDescriptor Symbol, "c51" for a SoundfieldGroupLabelSubDescriptor Symbol.
    /// </remarks>
    private static readonly byte[] MCATagSymbol = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x01, 0x03, 0x07, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// MCA Title
    /// </summary>
    /// <remarks>
    /// Name of the overall program to which the audio essence track belongs
    /// </remarks>
    private static readonly byte[] MCATitle = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x01, 0x05, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// MCA Title Sub-Version
    /// </summary>
    /// <remarks>
    /// Sub-version of the program to which the audio belongs such as a localized rendition that has the same cut as depicted in MCA Version.
    /// </remarks>
    private static readonly byte[] MCATitleSubVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x01, 0x05, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// MCA Title Version
    /// </summary>
    /// <remarks>
    /// Version of the program to which the audio belongs, such as a specific cut of a movie.
    /// </remarks>
    private static readonly byte[] MCATitleVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x01, 0x05, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// MCA Use Class
    /// </summary>
    /// <remarks>
    /// Unique value that identifies the class of the audio essence with respect to its completeness and usability
    /// </remarks>
    private static readonly byte[] MCAUseClass = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x03, 0x02, 0x01, 0x02, 0x23, 0x00, 0x00, 0x00];
    /// <summary>
    /// MD Color Volume
    /// </summary>
    /// <remarks>
    /// Information about the color volume of a mastering display device as configured for the mastering process
    /// </remarks>
    private static readonly byte[] MDColorVolume = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x04, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// MD Maximum Luminance
    /// </summary>
    /// <remarks>
    /// Maximum Display Mastering Luminance metadata as specified in ST 2086
    /// </remarks>
    private static readonly byte[] MDMaximumLuminance = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x04, 0x01, 0x02, 0x03, 0x00, 0x00];
    /// <summary>
    /// MD Minimum Luminance
    /// </summary>
    /// <remarks>
    /// Minimum Display Mastering Luminance metadata as specified in ST 2086
    /// </remarks>
    private static readonly byte[] MDMinimumLuminance = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x04, 0x01, 0x02, 0x04, 0x00, 0x00];
    /// <summary>
    /// MD Primaries
    /// </summary>
    /// <remarks>
    /// Display Primaries metadata as specified in ST 2086
    /// </remarks>
    private static readonly byte[] MDPrimaries = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x04, 0x01, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// MD White Point Chromaticity
    /// </summary>
    /// <remarks>
    /// Chromaticity of White Point metadata as specified in ST 2086
    /// </remarks>
    private static readonly byte[] MDWhitePointChromaticity = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x04, 0x01, 0x02, 0x02, 0x00, 0x00];
    /// <summary>
    /// Media Dimensions
    /// </summary>
    /// <remarks>
    /// Length measurements relating to the physical size of the image formed in a capturing device
    /// </remarks>
    private static readonly byte[] MediaDimensions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x09, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Media Locators
    /// </summary>
    /// <remarks>
    /// Local paths for a digital media, data, metadata file etc
    /// </remarks>
    private static readonly byte[] MediaLocators = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Media Type
    /// </summary>
    /// <remarks>
    /// Specifies the Media Type as defined by IETF
    /// </remarks>
    private static readonly byte[] MediaType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x09, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Medium
    /// </summary>
    /// <remarks>
    /// A set of attributes to describe a medium
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] medium_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3D, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Medium
    /// </summary>
    /// <remarks>
    /// Medium - Television/Radio/Print etc
    /// Namespace: http://www.smpte-ra.org/reg/335/2012/13/13
    /// </remarks>
    private static readonly byte[] medium_13 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x0D, 0x0D, 0x01, 0x09, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Medium Characteristics
    /// </summary>
    /// <remarks>
    /// Characteristics describing the medium containing the essence for transport or storage
    /// </remarks>
    private static readonly byte[] MediumCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// MediumIID
    /// </summary>
    /// <remarks>
    /// An identifier attributed to a medium
    /// </remarks>
    private static readonly byte[] mediumID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3D, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Medium Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group to define the type of medium
    /// </remarks>
    private static readonly byte[] mediumTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3D, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Member Name List
    /// </summary>
    /// <remarks>
    /// Specifies, as a single string value, a list of names zero delineated between each name in a record
    /// </remarks>
    private static readonly byte[] MemberNames = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x02, 0x03, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Member Of
    /// </summary>
    /// <remarks>
    /// Specified the class in which this property may be present
    /// </remarks>
    private static readonly byte[] MemberOf = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x06, 0x01, 0x01, 0x07, 0x22, 0x00, 0x00, 0x00];
    /// <summary>
    /// Member Types
    /// </summary>
    /// <remarks>
    /// Specifies a vector to an ordered array of references to the types of the members in the record type
    /// </remarks>
    private static readonly byte[] MemberTypes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x07, 0x11, 0x00, 0x00, 0x00];
    /// <summary>
    /// Memory Storage Alignment Characteristics
    /// </summary>
    /// <remarks>
    /// Information about aligning data with defined memory boundaries
    /// </remarks>
    private static readonly byte[] MemoryStorageAlignmentCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x18, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Memory Storage Characteristics
    /// </summary>
    /// <remarks>
    /// Information about persistent and transient memory parameters
    /// </remarks>
    private static readonly byte[] MemoryStorageCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Characteristics
    /// </summary>
    /// <remarks>
    /// Operating characteristics of the device creating the metadata
    /// </remarks>
    private static readonly byte[] MetadataCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Color Coding Workspace
    /// </summary>
    /// <remarks>
    /// Enumerator of the color components and quantization range
    /// </remarks>
    private static readonly byte[] MetadataColorCodingWorkspace = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x28, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Compression
    /// </summary>
    /// <remarks>
    /// Information about metadata compression.
    /// </remarks>
    private static readonly byte[] MetadataCompression = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Compression History
    /// </summary>
    /// <remarks>
    /// Audit history of compression for payload.
    /// </remarks>
    private static readonly byte[] MetadataCompressionHistory = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Date Last Modified
    /// </summary>
    /// <remarks>
    /// The date when the schema was last modified/updated
    /// </remarks>
    private static readonly byte[] metadataDateLastModified = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x03, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Encoding Scheme Code
    /// </summary>
    /// <remarks>
    /// The code that indicates the manner in which the metadata for the motion imagery was encoded.
    /// </remarks>
    private static readonly byte[] MetadataEncodingSchemeCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x04, 0x06, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Format
    /// </summary>
    /// <remarks>
    /// A structure to define the characteristics of a metadata track
    /// </remarks>
    private static readonly byte[] metadataFormat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x59, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Format Definition
    /// </summary>
    /// <remarks>
    /// A definition of a metadata format
    /// </remarks>
    private static readonly byte[] metadataFormatDefinition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x59, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Format Id
    /// </summary>
    /// <remarks>
    /// The identifier of a metadata format
    /// </remarks>
    private static readonly byte[] metadataFormatId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x59, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Format Name
    /// </summary>
    /// <remarks>
    /// The name of a metadata format
    /// </remarks>
    private static readonly byte[] metadataFormatName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x59, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Format Version Id
    /// </summary>
    /// <remarks>
    /// The version identifier of a metadata format
    /// </remarks>
    private static readonly byte[] metadataFormatVersionId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x59, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Framework Text Language
    /// </summary>
    /// <remarks>
    /// Codes assigned by ISO 639-1 for the identification of languages. The (main) language of the metadata
    /// </remarks>
    private static readonly byte[] metadataFrameworkTextLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Identifiers
    /// </summary>
    /// <remarks>
    /// 16-byte Identifiers for metadata elements
    /// </remarks>
    private static readonly byte[] MetadataIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x03, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Namespace
    /// </summary>
    /// <remarks>
    /// The namespace of the schema
    /// </remarks>
    private static readonly byte[] metadataNamespace = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x03, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Namespace Prefix
    /// </summary>
    /// <remarks>
    /// The prefix associated with EBUCore metadata namespace in the xml domain
    /// </remarks>
    private static readonly byte[] metadataNamespacePrefix = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x03, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Processing
    /// </summary>
    /// <remarks>
    /// Enhamcement or modification to the metadata
    /// </remarks>
    private static readonly byte[] MetadataProcessing = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x20, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Processor Settings
    /// </summary>
    /// <remarks>
    /// The settings of a specific device in the system
    /// </remarks>
    private static readonly byte[] MetadataProcessorSettings = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Provider Entity Set
    /// </summary>
    /// <remarks>
    /// A strong reference to ane entity identified as the provider of the schema
    /// </remarks>
    private static readonly byte[] metadataProviderEntityObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x03, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Schema
    /// </summary>
    /// <remarks>
    /// The name of the reference schema
    /// </remarks>
    private static readonly byte[] metadataSchema = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata  Schema Information
    /// </summary>
    /// <remarks>
    /// A set of schema related properties
    /// </remarks>
    private static readonly byte[] metadataSchemaInformation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata  Schema Information Set
    /// </summary>
    /// <remarks>
    /// A strong reference to information about the EBUCore schema (version...)
    /// </remarks>
    private static readonly byte[] metadataSchemaInformationObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x01, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Schema Version
    /// </summary>
    /// <remarks>
    /// The version of the schema
    /// </remarks>
    private static readonly byte[] metadataSchemaVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x03, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Server Locators
    /// </summary>
    /// <remarks>
    /// Specifies a vector of an ordered set of references to Locators for metadata servers
    /// </remarks>
    private static readonly byte[] MetadataServerLocators = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x06, 0x0C, 0x00, 0x00];
    /// <summary>
    /// Metadata Technical Attribute AnyURI Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type AnyURI
    /// </remarks>
    private static readonly byte[] metadataTechnicalAttributeAnyURIObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x59, 0x11, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Technical Attribute Boolean Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Boolean
    /// </remarks>
    private static readonly byte[] metadataTechnicalAttributeBooleanObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x59, 0x12, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Technical Attribute Float Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Float
    /// </remarks>
    private static readonly byte[] metadataTechnicalAttributeFloatObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x59, 0x0F, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Technical Attribute Int16 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int16
    /// </remarks>
    private static readonly byte[] metadataTechnicalAttributeInt16Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x59, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Technical Attribute Int32 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int32
    /// </remarks>
    private static readonly byte[] metadataTechnicalAttributeInt32Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x59, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Technical Attribute Int64 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int64
    /// </remarks>
    private static readonly byte[] metadataTechnicalAttributeInt64Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x59, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Technical Attribute Int8 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int8
    /// </remarks>
    private static readonly byte[] metadataTechnicalAttributeInt8Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x59, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Technical Attribute Rational Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Rational
    /// </remarks>
    private static readonly byte[] metadataTechnicalAttributeRationalObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x59, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Technical Attribute String Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type string
    /// </remarks>
    private static readonly byte[] metadataTechnicalAttributeStringObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x59, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Technical Attribute UInt16 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt16
    /// </remarks>
    private static readonly byte[] metadataTechnicalAttributeUInt16Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x59, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Technical Attribute UInt32 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt32
    /// </remarks>
    private static readonly byte[] metadataTechnicalAttributeUInt32Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x59, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Technical Attribute UInt64 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt64
    /// </remarks>
    private static readonly byte[] metadataTechnicalAttributeUInt64Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x59, 0x0E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Technical Attribute UInt8 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt8
    /// </remarks>
    private static readonly byte[] metadataTechnicalAttributeUInt8Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x59, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Test Parameters
    /// </summary>
    /// <remarks>
    /// Data test parameters from the original recording
    /// </remarks>
    private static readonly byte[] MetadataTestParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Time Last Modified
    /// </summary>
    /// <remarks>
    /// The time when the schema was last modified/updated
    /// </remarks>
    private static readonly byte[] metadataTimeLastModified = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x03, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata to Essence Relationships
    /// </summary>
    /// <remarks>
    /// The relationship between metadata and essence
    /// </remarks>
    private static readonly byte[] MetadataToEssenceRelationships = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x06, 0x01, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata to Metadata Relationships
    /// </summary>
    /// <remarks>
    /// The relationship between metadata and metadata
    /// </remarks>
    private static readonly byte[] MetadataToMetadataRelationships = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x06, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata to Object Relationships
    /// </summary>
    /// <remarks>
    /// The relationship between metadata and an object
    /// </remarks>
    private static readonly byte[] MetadataToObjectRelationships = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x06, 0x01, 0x01, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Metadata Track Sets
    /// </summary>
    /// <remarks>
    /// The metadata tracks
    /// </remarks>
    private static readonly byte[] metadataTrackObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x59, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// MetaDefinition Description
    /// </summary>
    /// <remarks>
    /// Provides an explanation of the use of the item being defined
    /// </remarks>
    private static readonly byte[] MetaDefinitionDescription = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x07, 0x14, 0x01, 0x00, 0x00];
    /// <summary>
    /// MetaDefinition Identification
    /// </summary>
    /// <remarks>
    /// Specifies the unique identifier for the item being defined
    /// </remarks>
    private static readonly byte[] MetaDefinitionIdentification = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x07, 0x13, 0x00, 0x00, 0x00];
    /// <summary>
    /// MetaDefinition Name
    /// </summary>
    /// <remarks>
    /// Specifies the display name of the item being defined
    /// </remarks>
    private static readonly byte[] MetaDefinitionName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x04, 0x01, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// MetaDefinition Name
    /// </summary>
    /// <remarks>
    /// Specifies the display name of the item being defined
    /// </remarks>
    private static readonly byte[] MetaDefinitionName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x03, 0x02, 0x04, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Meta-Definitions
    /// </summary>
    /// <remarks>
    /// References all the MetaDefinitions in this Extension Scheme when they are contained in the MXF file
    /// </remarks>
    private static readonly byte[] MetaDefinitions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x06, 0x01, 0x01, 0x07, 0x1F, 0x00, 0x00, 0x00];
    /// <summary>
    /// MGA Audio Metadata Coding Parameters
    /// </summary>
    /// <remarks>
    /// Parameters about MGA Audio Metadata Coding
    /// </remarks>
    private static readonly byte[] MGAAudioMetadataCodingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x02, 0x03, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// MGA Audio Metadata Identifier
    /// </summary>
    /// <remarks>
    /// Specifies the MGA Audio Metadata Identifier
    /// </remarks>
    private static readonly byte[] MGAAudioMetadataIdentifier = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x02, 0x03, 0x05, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// MGA Audio Metadata Index
    /// </summary>
    /// <remarks>
    /// Specifies the MGA Audio Metadata Index
    /// </remarks>
    private static readonly byte[] MGAAudioMetadataIndex = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x02, 0x03, 0x05, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// MGA Audio Metadata Payload UL Array
    /// </summary>
    /// <remarks>
    /// Specifies an Array of MGA Audio Metadata Payload ULs
    /// </remarks>
    private static readonly byte[] MGAAudioMetadataPayloadULArray = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x02, 0x03, 0x05, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// MGA Link ID
    /// </summary>
    /// <remarks>
    /// Specifies the MGA Link ID
    /// </remarks>
    private static readonly byte[] MGALinkID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x02, 0x03, 0x05, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// MGA Metadata Section Link ID
    /// </summary>
    /// <remarks>
    /// Specifies the MGA Metadata Section Link ID
    /// </remarks>
    private static readonly byte[] MGAMetadataSectionLinkID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x02, 0x03, 0x06, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// MGA Sound Essence Average Bytes Per Second
    /// </summary>
    /// <remarks>
    /// Specifies the average data rate in Bytes per Second
    /// </remarks>
    private static readonly byte[] MGASoundEssenceAverageBytesPerSecond = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x02, 0x03, 0x04, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// MGA Sound Essence Block Align
    /// </summary>
    /// <remarks>
    /// Specifies the block alignment of the data in Bytes
    /// </remarks>
    private static readonly byte[] MGASoundEssenceBlockAlign = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x02, 0x03, 0x04, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// MGA Sound Essence Coding Parameters
    /// </summary>
    /// <remarks>
    /// Parameters about MGA Sound Essence Coding
    /// </remarks>
    private static readonly byte[] MGASoundEssenceCodingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// MGA Sound Essence Sequence Offset
    /// </summary>
    /// <remarks>
    /// Specifies the Sequence Offset
    /// </remarks>
    private static readonly byte[] MGASoundEssenceSequenceOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x02, 0x03, 0x04, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// MGA Soundfield Group Label Coding Parameters
    /// </summary>
    /// <remarks>
    /// Parameters about MGA Soundfield Group Label Coding
    /// </remarks>
    private static readonly byte[] MGASoundfieldGroupLabelCodingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x02, 0x03, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// MIC
    /// </summary>
    /// <remarks>
    /// The Message Integrity Check (Keyed HMAC)
    /// </remarks>
    private static readonly byte[] MIC = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x02, 0x09, 0x03, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// MIC Algorithm
    /// </summary>
    /// <remarks>
    /// The hashing algorithm used for Digital Cinema message integrity check
    /// </remarks>
    private static readonly byte[] MICAlgorithm = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x02, 0x09, 0x03, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// MICCarriage
    /// </summary>
    /// <remarks>
    /// Informs decoder where to find MIC value. Absent Value indicates use of Encrypted Triplets
    /// </remarks>
    private static readonly byte[] MICCarriage = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x01, 0x01, 0x07, 0x04, 0x03, 0x00];
    /// <summary>
    /// Microphone Characteristics
    /// </summary>
    /// <remarks>
    /// Information about microphones used
    /// </remarks>
    private static readonly byte[] MicrophoneCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x20, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Microphone Placement Techniques
    /// </summary>
    /// <remarks>
    /// spaced omnis, spaced cardioids, close miking
    /// </remarks>
    private static readonly byte[] MicrophonePlacementTechniques_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x01, 0x02, 0x04, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Mid-Tone Width Adjustment Factor
    /// </summary>
    /// <remarks>
    /// Control for the width of the mid-tone region of the curve
    /// </remarks>
    private static readonly byte[] MidToneWidthAdjustmentFactor = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x25, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// MIME Char Set
    /// </summary>
    /// <remarks>
    /// Specifies the registered character set used by both the internal and external representation of the data as defined by IETF RFC 2048 and http://www.iana.org/assignmnets/character-sets
    /// </remarks>
    private static readonly byte[] MIMECharSet_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x04, 0x09, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// MIME Encoding
    /// </summary>
    /// <remarks>
    /// Specifies the registered character set used by the external representation of the data as defined by IETF RFC 2048 and http://www.iana.org/assignmnets/character-sets
    /// </remarks>
    private static readonly byte[] MIMEEncoding = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x04, 0x09, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// MIME Encoding
    /// </summary>
    /// <remarks>
    /// Specifies the registered character set used by the external representation of the data as defined by IETF RFC 2048 and http://www.iana.org/assignmnets/character-sets
    /// </remarks>
    private static readonly byte[] MIMEEncoding_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x04, 0x09, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// MIME Media Type
    /// </summary>
    /// <remarks>
    /// Specifies the MIME media type as defined by IETF
    /// </remarks>
    private static readonly byte[] MIMEMediaType_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x04, 0x09, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// MIME Media Type
    /// </summary>
    /// <remarks>
    /// Specifies the MIME media type as defined by IETF
    /// </remarks>
    private static readonly byte[] MIMEType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x04, 0x09, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Mime Type Set
    /// </summary>
    /// <remarks>
    /// The medium used to carry the resource
    /// </remarks>
    private static readonly byte[] mimeTypeObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3C, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Minimum Supported Engine Version
    /// </summary>
    /// <remarks>
    /// Earliest supported version of the Engine
    /// </remarks>
    private static readonly byte[] MinEngineVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x09, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Minimum PQ-encoded maxRGB
    /// </summary>
    /// <remarks>
    /// The lowest PQ-encoded maxRGB value of the reduced pixel set
    /// </remarks>
    private static readonly byte[] MinimumPqencodedMaxrgb = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x0D, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Minimum PQ-encoded maxRGB Offset
    /// </summary>
    /// <remarks>
    /// Offset to be added to Minimum PQ-encoded maxRGB
    /// </remarks>
    private static readonly byte[] MinimumPqencodedMaxrgbOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x10, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Minor Version
    /// </summary>
    /// <remarks>
    /// A minor version number.  A change in a minor version implies some measure of backwards compatibility
    /// </remarks>
    private static readonly byte[] MinorVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x03, 0x01, 0x02, 0x01, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Minimum Supported Platform Version
    /// </summary>
    /// <remarks>
    /// Earliest supported version of the platform
    /// </remarks>
    private static readonly byte[] MinPlatformVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x09, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Minimum API Version
    /// </summary>
    /// <remarks>
    /// Earliest supported version of the API
    /// </remarks>
    private static readonly byte[] MinPluginAPI = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x09, 0x09, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// MISB Classified
    /// </summary>
    /// <remarks>
    /// Classified metadata registered by MISB (Motion Imagery Standards Board) for Systems and ASPA
    /// </remarks>
    private static readonly byte[] MISBClassified = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0E, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// MISB Systems
    /// </summary>
    /// <remarks>
    /// Unclassified metadata registered by MISB (Motion Imagery Standards Board) for Systems
    /// </remarks>
    private static readonly byte[] MISBSystems = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Mission ID
    /// </summary>
    /// <remarks>
    /// A locally defined identifier for the platform mission number
    /// </remarks>
    private static readonly byte[] MissionIdentifier = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x05, 0x09, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Mission ID
    /// </summary>
    /// <remarks>
    /// A locally defined identifier for the platform mission number
    /// </remarks>
    private static readonly byte[] MissionIdentifier_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x05, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Mixed Content Kind
    /// </summary>
    /// <remarks>
    /// Numerical ID for the kind of mixed content: 0 - undefined, 1 - complete main, 2 - mixed, 3 - hearing impaired.
    /// </remarks>
    private static readonly byte[] mixedContentkind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x63, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Mobile Telephone Number
    /// </summary>
    /// <remarks>
    /// Mobile telephone number
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] MobileTelephoneNumber_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x07, 0x01, 0x20, 0x01, 0x10, 0x03, 0x05, 0x00];
    /// <summary>
    /// Mobile Telephone Number
    /// </summary>
    /// <remarks>
    /// A mobile telephone number
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] MobileTelephoneNumber_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x25, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Modification Date-Time
    /// </summary>
    /// <remarks>
    /// Identifies date and time at the point of modification
    /// </remarks>
    private static readonly byte[] ModificationDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x10, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Modification Information
    /// </summary>
    /// <remarks>
    /// Modification informaation
    /// </remarks>
    private static readonly byte[] ModificationInformation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Monitoring and Control Characteristics
    /// </summary>
    /// <remarks>
    /// Operating characteristics of the device creating the system and control information
    /// </remarks>
    private static readonly byte[] MonitoringAndControlCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Monitoring and Control Test Parameters
    /// </summary>
    /// <remarks>
    /// Monitoring and Control metadata test parameters from the original recording
    /// </remarks>
    private static readonly byte[] MonitoringAndControlTestParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x05, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Mono Source Track IDs
    /// </summary>
    /// <remarks>
    /// Specifies an ordered array of Tracks within the referenced precursor
    /// </remarks>
    private static readonly byte[] MonoSourceTrackIDs = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x06, 0x01, 0x01, 0x03, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// MPEG-1 Audio Coding Parameters
    /// </summary>
    /// <remarks>
    /// Information about MPEG audio coding
    /// </remarks>
    private static readonly byte[] MPEG1AudioCodingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x04, 0x03, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// MPEG-2 Coding Parameters
    /// </summary>
    /// <remarks>
    /// Information about MPEG video coding
    /// </remarks>
    private static readonly byte[] MPEG2CodingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x06, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// MPEG-2 Processing
    /// </summary>
    /// <remarks>
    /// MPEG processing performed on the  essence
    /// </remarks>
    private static readonly byte[] MPEG2Processing = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x02, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// MPEG-4 Visual Bit Rate
    /// </summary>
    /// <remarks>
    /// Maximum bit rate of MPEG-4 Part.2 video ES in bit/s.An example is  defined in ISO/IEC 14496-2 bit_rate property.
    /// </remarks>
    private static readonly byte[] MPEG4VisualBitRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x06, 0x02, 0x02, 0x0B, 0x00, 0x00];
    /// <summary>
    /// MPEG-4 Visual B-VOP Count
    /// </summary>
    /// <remarks>
    /// Specifies the maximum number of B-VOPs between P or I-VOPs.
    /// </remarks>
    private static readonly byte[] MPEG4VisualBVOPCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x06, 0x02, 0x02, 0x09, 0x00, 0x00];
    /// <summary>
    /// MPEG-4 Visual Closed GOV
    /// </summary>
    /// <remarks>
    /// TRUE if closed_gov is set in all GOV headers. An example is defined in closed_gop_flag of ISO/IEC 13818-1 IBP descriptor.
    /// </remarks>
    private static readonly byte[] MPEG4VisualClosedGOV = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x06, 0x02, 0x02, 0x06, 0x00, 0x00];
    /// <summary>
    /// MPEG-4 Visual Coded Content Type
    /// </summary>
    /// <remarks>
    /// 0= "Unknown" 1=  "Progressive" 2=  "Interlaced" 3=  "Mixed" An enumerated value which tells if the underlying content which was MPEG coded was of a known type.
    /// </remarks>
    private static readonly byte[] MPEG4VisualCodedContentType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x06, 0x02, 0x02, 0x04, 0x00, 0x00];
    /// <summary>
    /// MPEG-4 Visual Coding Parameters
    /// </summary>
    /// <remarks>
    /// Describes MPEG-4 Visual coding parameters.
    /// </remarks>
    private static readonly byte[] MPEG4VisualCodingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x06, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// MPEG-4 Visual Constant B-VOPs
    /// </summary>
    /// <remarks>
    /// TRUE if the number of B-VOPs is always constant.
    /// </remarks>
    private static readonly byte[] MPEG4VisualConstantBVOPs = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x06, 0x02, 0x02, 0x03, 0x00, 0x00];
    /// <summary>
    /// MPEG-4 Visual Identical GOV
    /// </summary>
    /// <remarks>
    /// TRUE if every GOV in the sequence is constructed the same. An example is defined in identical_gop_flag of ISO/IEC 13818-1 IBP descriptor.
    /// </remarks>
    private static readonly byte[] MPEG4VisualIdenticalGOV = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x06, 0x02, 0x02, 0x07, 0x00, 0x00];
    /// <summary>
    /// MPEG-4 Visual Low Delay
    /// </summary>
    /// <remarks>
    /// TRUE if the VOL contains no B-VOPs.
    /// </remarks>
    private static readonly byte[] MPEG4VisualLowDelay = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x06, 0x02, 0x02, 0x05, 0x00, 0x00];
    /// <summary>
    /// MPEG-4 Visual Max GOV
    /// </summary>
    /// <remarks>
    /// Specifies the maximum occurring spacing between I frames. An example is defined in max_gop_length of ISO/IEC 13818-1 IBP descriptor. A value of 0 or the absence of this property implies no limit to the maximum GOV or the maximum GOV is unknown.
    /// </remarks>
    private static readonly byte[] MPEG4VisualMaxGOV = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x06, 0x02, 0x02, 0x08, 0x00, 0x00];
    /// <summary>
    /// MPEG-4 Visual Profile And Level
    /// </summary>
    /// <remarks>
    /// Specifies the MPEG-4 Part 2 video profile and level. The meaning of the bits is given in Table G.1 of ISO/IEC 14496-2.
    /// </remarks>
    private static readonly byte[] MPEG4VisualProfileAndLevel = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x06, 0x02, 0x02, 0x0A, 0x00, 0x00];
    /// <summary>
    /// MPEG-4 Visual Single Sequence
    /// </summary>
    /// <remarks>
    /// TRUE if the essence consists of a single MPEG sequence. False if there are a number of sequences. This flag implies that the sequence header information is not varying in the essence stream.
    /// </remarks>
    private static readonly byte[] MPEG4VisualSingleSequence = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x06, 0x02, 0x02, 0x02, 0x00, 0x00];
    /// <summary>
    /// MPEG-4 Visual VOP Coding Type
    /// </summary>
    /// <remarks>
    /// Identifies whether a VOP is an intra-coded VOP (I), predictive-coded VOP (P), bidirectionally predictive-coded (B) or sprite coded (S).
    /// </remarks>
    private static readonly byte[] MPEG4VisualVOPCodingType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x06, 0x02, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// MPEG-7 BiM Access Unit Frames
    /// </summary>
    /// <remarks>
    /// Simultaneously streamed MPEG-7 BiM Access Unit frames
    /// </remarks>
    private static readonly byte[] MPEG7BiMAccessUnitFrames = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x02, 0x20, 0x02, 0x02, 0x00, 0x00];
    /// <summary>
    /// MPEG-7 BiM Access Unit Frame (Stream 1)
    /// </summary>
    /// <remarks>
    /// Stream 1 MPEG-7 BiM Access Unit frames
    /// </remarks>
    private static readonly byte[] MPEG7BiMAccessUnitFrameStream1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x02, 0x20, 0x02, 0x02, 0x01, 0x00];
    /// <summary>
    /// MPEG-7 BiM Access Unit Frame (Stream 2)
    /// </summary>
    /// <remarks>
    /// Stream 2 MPEG-7 BiM Access Unit frames
    /// </remarks>
    private static readonly byte[] MPEG7BiMAccessUnitFrameStream2 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x02, 0x20, 0x02, 0x02, 0x02, 0x00];
    /// <summary>
    /// MPEG-7 BiM Access Unit Frame (Stream 3)
    /// </summary>
    /// <remarks>
    /// Stream 3 MPEG-7 BiM Access Unit frames
    /// </remarks>
    private static readonly byte[] MPEG7BiMAccessUnitFrameStream3 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x02, 0x20, 0x02, 0x02, 0x03, 0x00];
    /// <summary>
    /// MPEG-7 BiM Access Unit Frame (Stream 4)
    /// </summary>
    /// <remarks>
    /// Stream 4 MPEG-7 BiM Access Unit frames
    /// </remarks>
    private static readonly byte[] MPEG7BiMAccessUnitFrameStream4 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x02, 0x20, 0x02, 0x02, 0x04, 0x00];
    /// <summary>
    /// MPEG-7 BiM Access Unit Frame (Stream 5)
    /// </summary>
    /// <remarks>
    /// Stream 5 MPEG-7 BiM Access Unit frames
    /// </remarks>
    private static readonly byte[] MPEG7BiMAccessUnitFrameStream5 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x02, 0x20, 0x02, 0x02, 0x05, 0x00];
    /// <summary>
    /// MPEG-7 BiM Access Unit Frame (Stream 6)
    /// </summary>
    /// <remarks>
    /// Stream 6 MPEG-7 BiM Access Unit frames
    /// </remarks>
    private static readonly byte[] MPEG7BiMAccessUnitFrameStream6 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x02, 0x20, 0x02, 0x02, 0x06, 0x00];
    /// <summary>
    /// MPEG-7 BiM Access Unit Frame (Stream 7)
    /// </summary>
    /// <remarks>
    /// Stream 7 MPEG-7 BiM Access Unit frames
    /// </remarks>
    private static readonly byte[] MPEG7BiMAccessUnitFrameStream7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x02, 0x20, 0x02, 0x02, 0x07, 0x00];
    /// <summary>
    /// MPEG-7 BiM Access Unit Frame (Stream 8)
    /// </summary>
    /// <remarks>
    /// Stream 8 MPEG-7 BiM Access Unit frames
    /// </remarks>
    private static readonly byte[] MPEG7BiMAccessUnitFrameStream8 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x02, 0x20, 0x02, 0x02, 0x08, 0x00];
    /// <summary>
    /// MPEG-7 BiM Decoder Init Frames
    /// </summary>
    /// <remarks>
    /// Simultaneously streamed MPEG-7 BiM DecoderInit frames
    /// </remarks>
    private static readonly byte[] MPEG7BiMDecoderInitFrames = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x02, 0x20, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// MPEG-7 BiM Decoder Init Frame (Stream 1)
    /// </summary>
    /// <remarks>
    /// Stream 1 MPEG-7 BiM Decoder Init frames
    /// </remarks>
    private static readonly byte[] MPEG7BiMDecoderInitFrameStream1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x02, 0x20, 0x02, 0x01, 0x01, 0x00];
    /// <summary>
    /// MPEG-7 BiM Decoder Init Frame (Stream 2)
    /// </summary>
    /// <remarks>
    /// Stream 2 MPEG-7 BiM Decoder Init frames
    /// </remarks>
    private static readonly byte[] MPEG7BiMDecoderInitFrameStream2 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x02, 0x20, 0x02, 0x01, 0x02, 0x00];
    /// <summary>
    /// MPEG-7 BiM Decoder Init Frame (Stream 3)
    /// </summary>
    /// <remarks>
    /// Stream 3 MPEG-7 BiM Decoder Init frames
    /// </remarks>
    private static readonly byte[] MPEG7BiMDecoderInitFrameStream3 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x02, 0x20, 0x02, 0x01, 0x03, 0x00];
    /// <summary>
    /// MPEG-7 BiM Decoder Init Frame (Stream 4)
    /// </summary>
    /// <remarks>
    /// Stream 4 MPEG-7 BiM Decoder Init frames
    /// </remarks>
    private static readonly byte[] MPEG7BiMDecoderInitFrameStream4 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x02, 0x20, 0x02, 0x01, 0x04, 0x00];
    /// <summary>
    /// MPEG-7 BiM Decoder Init Frame (Stream 5)
    /// </summary>
    /// <remarks>
    /// Stream 5 MPEG-7 BiM Decoder Init frames
    /// </remarks>
    private static readonly byte[] MPEG7BiMDecoderInitFrameStream5 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x02, 0x20, 0x02, 0x01, 0x05, 0x00];
    /// <summary>
    /// MPEG-7 BiM Decoder Init Frame (Stream 6)
    /// </summary>
    /// <remarks>
    /// Stream 6 MPEG-7 BiM Decoder Init frames
    /// </remarks>
    private static readonly byte[] MPEG7BiMDecoderInitFrameStream6 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x02, 0x20, 0x02, 0x01, 0x06, 0x00];
    /// <summary>
    /// MPEG-7 BiM Decoder Init Frame (Stream 7)
    /// </summary>
    /// <remarks>
    /// Stream 7 MPEG-7 BiM Decoder Init frames
    /// </remarks>
    private static readonly byte[] MPEG7BiMDecoderInitFrameStream7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x02, 0x20, 0x02, 0x01, 0x07, 0x00];
    /// <summary>
    /// MPEG-7 BiM Decoder Init Frame (Stream 8)
    /// </summary>
    /// <remarks>
    /// Stream 8 MPEG-7 BiM Decoder Init frames
    /// </remarks>
    private static readonly byte[] MPEG7BiMDecoderInitFrameStream8 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x02, 0x20, 0x02, 0x01, 0x08, 0x00];
    /// <summary>
    /// MPEG Audio Bit Rate
    /// </summary>
    /// <remarks>
    /// Specifies the rate of a compressed MPEG audio bitstream in kbit/s. The allowed values are typically determined by a given MPEG audio layer and mode.
    /// </remarks>
    private static readonly byte[] MPEGAudioBitRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x02, 0x04, 0x03, 0x01, 0x02, 0x00, 0x00];
    /// <summary>
    /// MPEG Audio Channel Assignment
    /// </summary>
    /// <remarks>
    /// UL enumerating the channel assignment in use
    /// </remarks>
    private static readonly byte[] MPEGAudioChannelAssignment = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x02, 0x04, 0x03, 0x01, 0x05, 0x00, 0x00];
    /// <summary>
    /// MPEG Audio Coding Parameters
    /// </summary>
    /// <remarks>
    /// Information about MPEG audio coding
    /// </remarks>
    private static readonly byte[] MPEGAudioCodingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// MPEG Audio Recoding Dataset
    /// </summary>
    /// <remarks>
    /// Audio coding history as per SMPTEXXXX
    /// </remarks>
    private static readonly byte[] MPEGAudioRecodingDataset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x40, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// MPEG Coding Parameters
    /// </summary>
    /// <remarks>
    /// Information about MPEG video coding
    /// </remarks>
    private static readonly byte[] MPEGCodingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// MPEG Processing
    /// </summary>
    /// <remarks>
    /// MPEG processing performed on the  essence
    /// </remarks>
    private static readonly byte[] MPEGProcessing = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x02, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// MPEG Video Recoding Dataset
    /// </summary>
    /// <remarks>
    /// Audit history of video coding - see SMPTE327.
    /// </remarks>
    private static readonly byte[] MPEGVideoRecodingDataset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x40, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Music Flags
    /// </summary>
    /// <remarks>
    /// Information about music used in the Process
    /// </remarks>
    private static readonly byte[] MusicFlags = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x05, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Music Industry Identifiers
    /// </summary>
    /// <remarks>
    /// Identifiers associated with the Music Industry
    /// </remarks>
    private static readonly byte[] MusicIndustryIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x10, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// MXF Descriptive Metadata Schemes
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] MXFDescriptiveMetadataSchemes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// MXF-DMS Structure Version-1
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] MXFDMSStructureVersion1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// MXF Generic Stream Data Element Key
    /// </summary>
    /// <remarks>
    /// Default key used for the Generic Stream Payload in a MXF Generic Stream Partition
    /// </remarks>
    private static readonly byte[] MXFGenericStreamDataElementKey = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x0D, 0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Namespace Prefix
    /// </summary>
    /// <remarks>
    /// A Namespace Prefix used in Qnames in an XML document
    /// </remarks>
    private static readonly byte[] NamespacePrefix = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x01, 0x03, 0x06, 0x05, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Namespace Prefix
    /// </summary>
    /// <remarks>
    /// A Namespace Prefix used in Qnames in an XML document
    /// </remarks>
    private static readonly byte[] NamespacePrefix_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x01, 0x03, 0x06, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Namespace Prefixes
    /// </summary>
    /// <remarks>
    /// A list of Namespace Prefixes used in Qnames in an XML document
    /// </remarks>
    private static readonly byte[] NamespacePrefixes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x01, 0x03, 0x06, 0x06, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Namespace Prefixes
    /// </summary>
    /// <remarks>
    /// A list of Namespace Prefixes used in Qnames in an XML document
    /// </remarks>
    private static readonly byte[] NamespacePrefixes_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x01, 0x03, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Namespace URI
    /// </summary>
    /// <remarks>
    /// A URI associated with a Namespace Prefix used in Qnames in an XML document
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] NamespaceURI_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x01, 0x02, 0x01, 0x05, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Namespace URI
    /// </summary>
    /// <remarks>
    /// Identifies the default namespace of the essence XML documents
    /// Namespace: http://www.smpte-ra.org/reg/335/2012/14/9
    /// </remarks>
    private static readonly byte[] NamespaceURI_9 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x0E, 0x09, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Namespace URI
    /// </summary>
    /// <remarks>
    /// A URI associated with a Namespace Prefix used in Qnames in an XML document
    /// </remarks>
    private static readonly byte[] NamespaceURI_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x01, 0x02, 0x01, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Namespace URIs
    /// </summary>
    /// <remarks>
    /// A list of URIs associated with Namespace Prefixes used in Qnames in an XML document
    /// </remarks>
    private static readonly byte[] NamespaceURIs = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x01, 0x02, 0x01, 0x06, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Namespace URIs
    /// </summary>
    /// <remarks>
    /// A list of URIs associated with Namespace Prefixes used in Qnames in an XML document
    /// </remarks>
    private static readonly byte[] NamespaceURIs_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x01, 0x02, 0x01, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Name Suffix
    /// </summary>
    /// <remarks>
    /// A suffix to a name (e.g. Jr, Sr, III)
    /// </remarks>
    private static readonly byte[] NameSuffix = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x02, 0x30, 0x06, 0x03, 0x01, 0x0B, 0x01, 0x00];
    /// <summary>
    /// Name Suffix
    /// </summary>
    /// <remarks>
    /// A suffix to a name (e.g. Jr, Sr, III)
    /// </remarks>
    private static readonly byte[] NameSuffix_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x02, 0x30, 0x06, 0x03, 0x01, 0x0B, 0x00, 0x00];
    /// <summary>
    /// Name-Value Construct Interpretations
    /// </summary>
    /// <remarks>
    /// Defining information about interpreting name-value constructs
    /// </remarks>
    private static readonly byte[] NameValueConstructInterpretations = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x01, 0x02, 0x0A, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Name-Value Sets
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] NameValueSets = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x1F, 0x00];
    /// <summary>
    /// Nationality
    /// </summary>
    /// <remarks>
    /// Nationaility of an individual by origin, birth, or naturalization
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] Nationality_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x02, 0x30, 0x06, 0x03, 0x01, 0x0D, 0x01, 0x00];
    /// <summary>
    /// Nationality
    /// </summary>
    /// <remarks>
    /// The nationality of a contact/person
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] Nationality_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x22, 0x14, 0x00, 0x00, 0x00];
    /// <summary>
    /// Nationality
    /// </summary>
    /// <remarks>
    /// Nationaility of an individual by origin, birth, or naturalization
    /// </remarks>
    private static readonly byte[] Nationality_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x02, 0x30, 0x06, 0x03, 0x01, 0x0D, 0x00, 0x00];
    /// <summary>
    /// Nature of Personality (Individual or Group)
    /// </summary>
    /// <remarks>
    /// Group, Individual etc
    /// </remarks>
    private static readonly byte[] NatureOfPersonalityIndividualOrGroup = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x30, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Nature of Personality (Individual or Group)
    /// </summary>
    /// <remarks>
    /// Group, Individual etc
    /// </remarks>
    private static readonly byte[] NatureOfPersonalityIndividualOrGroup_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Nested Scope Tracks
    /// </summary>
    /// <remarks>
    /// Specifies a vector of references to segments
    /// </remarks>
    private static readonly byte[] NestedScopeTracks = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x06, 0x07, 0x00, 0x00];
    /// <summary>
    /// Network and Stream Identifiers
    /// </summary>
    /// <remarks>
    /// Information about channel numbering
    /// </remarks>
    private static readonly byte[] NetworkAndStreamIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Neutral Density Filter Wheel Setting
    /// </summary>
    /// <remarks>
    /// Neutral Density Filter Wheel setting as an integer value where the value 1 means a clear filter.
    /// </remarks>
    private static readonly byte[] NeutralDensityFilterWheelSetting = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x01, 0x03, 0x01, 0x04, 0x00, 0x00];
    /// <summary>
    /// Next Number in Sequence
    /// </summary>
    /// <remarks>
    /// The next number in a sequence
    /// </remarks>
    private static readonly byte[] NextNumberInSequence = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x10, 0x10, 0x04, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Next Number in Sequence
    /// </summary>
    /// <remarks>
    /// The next number in a sequence
    /// </remarks>
    private static readonly byte[] NextNumberInSequence_Int32 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x10, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Next Report Start Time
    /// </summary>
    /// <remarks>
    /// Timestamp representing the beginning of the time window for the next request
    /// </remarks>
    private static readonly byte[] NextReportStartTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x25, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// NHK
    /// </summary>
    /// <remarks>
    /// Metadata registered by Nippon Hoso Kyokai (NHK) for private use
    /// </remarks>
    private static readonly byte[] NHK = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x0E, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Nickname
    /// </summary>
    /// <remarks>
    /// The nickname of a contact/person
    /// </remarks>
    private static readonly byte[] nickname = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x22, 0x15, 0x00, 0x00, 0x00];
    /// <summary>
    /// NITF Layer Target ID
    /// </summary>
    /// <remarks>
    /// A free-text, locally defined name or ID of one or more individual targets or target areas from an NITF (National Imagery Transmission Format) still image layer
    /// </remarks>
    private static readonly byte[] NITFLayerTargetID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x01, 0x03, 0x01, 0x09, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// NITF Layer Target ID
    /// </summary>
    /// <remarks>
    /// A free-text, locally defined name or ID of one or more individual targets or target areas from an NITF (National Imagery Transmission Format) still image layer
    /// </remarks>
    private static readonly byte[] NITFLayerTargetID_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x01, 0x03, 0x01, 0x09, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// NL Technology, LLC
    /// </summary>
    /// <remarks>
    /// Metadata registered by NL Technology, LLC for private use
    /// </remarks>
    private static readonly byte[] NLTechnologyLLC = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x0E, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// NMEA-0183 GPS Document Text
    /// </summary>
    /// <remarks>
    /// National Marine Electronics Association (NMEA) text document complying with the NMEA-0183 Interface Standard when used to describe GPS positional information.
    /// </remarks>
    private static readonly byte[] NMEA0183GPSDocumentText_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x07, 0x01, 0x02, 0x01, 0x02, 0x30, 0x00, 0x00];
    /// <summary>
    /// Noise Reduction Processing
    /// </summary>
    /// <remarks>
    /// Information about any noise reduction process
    /// </remarks>
    private static readonly byte[] NoiseReductionProcessing = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Nominal Value
    /// </summary>
    /// <remarks>
    /// The nominal value of the rational expression
    /// </remarks>
    private static readonly byte[] nominalValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3F, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Nomination Category
    /// </summary>
    /// <remarks>
    /// Nomination category of the award (e.g. best actor, best director etc.)
    /// </remarks>
    private static readonly byte[] NominationCategory = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x03, 0x02, 0x02, 0x01, 0x06, 0x01, 0x00, 0x00];
    /// <summary>
    /// Nomination Category
    /// </summary>
    /// <remarks>
    /// Nomination category of the award (e.g. best actor, best director etc.)
    /// </remarks>
    private static readonly byte[] NominationCategory_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x03, 0x02, 0x02, 0x01, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Non Dialogue Content Kind
    /// </summary>
    /// <remarks>
    /// Numerical ID for the kind of non-dialogue content: 0 - undefined, 1 - music, 2 - effect.
    /// </remarks>
    private static readonly byte[] nonDialogueContentKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x63, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Non-US Classifying Country Code
    /// </summary>
    /// <remarks>
    /// ISO 3166 code of non-US country setting the security classification
    /// </remarks>
    private static readonly byte[] NonUSClassifyingCountry = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x02, 0x08, 0x00, 0x00];
    /// <summary>
    /// Country Code Method
    /// </summary>
    /// <remarks>
    /// The coding method used to identify the Non-US classifying country and countries in the releasing instructions
    /// </remarks>
    private static readonly byte[] NonUSClassifyingCountryAndReleasingInstructionsCountryCodeMethod = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x02, 0x07, 0x00, 0x00];
    /// <summary>
    /// Normal Play Time
    /// </summary>
    /// <remarks>
    /// Time expressed in HH:MM:SS.mmm
    /// </remarks>
    private static readonly byte[] normalPlayTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x58, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Numerical Sequence
    /// </summary>
    /// <remarks>
    /// information about numerical sequences
    /// </remarks>
    private static readonly byte[] NumericalSequence = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x06, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Object Area Dimension
    /// </summary>
    /// <remarks>
    /// Count of the number of pixels comprising an object in the frame or field of view.
    /// </remarks>
    private static readonly byte[] ObjectAreaDimension = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Object Characteristics
    /// </summary>
    /// <remarks>
    /// Object Characteristics
    /// </remarks>
    private static readonly byte[] ObjectCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Object Class
    /// </summary>
    /// <remarks>
    /// Specifies a reference to the definition of a class of object
    /// </remarks>
    private static readonly byte[] ObjectClass = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Object Comments and Descriptions
    /// </summary>
    /// <remarks>
    /// Comments or descriptions relating to Objects
    /// </remarks>
    private static readonly byte[] ObjectCommentsAndDescriptions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Object Country Code
    /// </summary>
    /// <remarks>
    /// The country code or text that represents the country depicted in the essence.
    /// </remarks>
    private static readonly byte[] ObjectCountryCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x02, 0x01, 0x01, 0x00];
    /// <summary>
    /// Object Country Code
    /// </summary>
    /// <remarks>
    /// The ISO code that represents the country depicted in the essence.
    /// </remarks>
    private static readonly byte[] ObjectCountryCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Object Country Code Method
    /// </summary>
    /// <remarks>
    /// The coding method used to identify the object country code
    /// </remarks>
    private static readonly byte[] ObjectCountryCodeMethod_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x02, 0x06, 0x00, 0x00];
    /// <summary>
    /// Object Description
    /// </summary>
    /// <remarks>
    /// Provides human informative description about the object
    /// </remarks>
    private static readonly byte[] ObjectDescription_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x03, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Object Description Code
    /// </summary>
    /// <remarks>
    /// Provides human informative description about the object as a code
    /// </remarks>
    private static readonly byte[] ObjectDescriptionCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x03, 0x01, 0x02, 0x02, 0x00, 0x00];
    /// <summary>
    /// Object Dictionary to Metadata Relationships
    /// </summary>
    /// <remarks>
    /// The relationship between dictionary definitions and the structure of the metadata
    /// </remarks>
    private static readonly byte[] ObjectDictionaryToMetadataRelationships = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Object Horizontal Average Dimension
    /// </summary>
    /// <remarks>
    /// Average number of horizontal pixels when a bounding rectangle is placed around an object in the frame or field of view.
    /// </remarks>
    private static readonly byte[] ObjectHorizontalAverageDimension = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Object Identification Confidence
    /// </summary>
    /// <remarks>
    /// Percentage confidence that an identified object in the current field of view is the same object  identified, detected or tracked in another or previous view.  This is an indication that the track of a moving object has been maintained.
    /// </remarks>
    private static readonly byte[] ObjectIdentificationConfidence = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Object Identifiers
    /// </summary>
    /// <remarks>
    /// Object identifiers
    /// </remarks>
    private static readonly byte[] ObjectIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Object Kind
    /// </summary>
    /// <remarks>
    /// Specifies the kind of Object.  E.g. a plugin
    /// </remarks>
    private static readonly byte[] ObjectKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x03, 0x01, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Object Kind
    /// </summary>
    /// <remarks>
    /// Specifies the kind of Object.  E.g. a plugin
    /// </remarks>
    private static readonly byte[] ObjectKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Object Model Version
    /// </summary>
    /// <remarks>
    /// Specifies the Internal Object Storage Mechanism Version Number
    /// </remarks>
    private static readonly byte[] ObjectModelVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x02, 0x01, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Object Name
    /// </summary>
    /// <remarks>
    /// Specifies the name of the object
    /// </remarks>
    private static readonly byte[] ObjectName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x04, 0x01, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Object Names
    /// </summary>
    /// <remarks>
    /// Descriptive names assigned to Objects
    /// </remarks>
    private static readonly byte[] ObjectNames = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Object Region Code
    /// </summary>
    /// <remarks>
    /// The ISO code that represents the region in a country where object is depicted
    /// </remarks>
    private static readonly byte[] ObjectRegionCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x03, 0x01, 0x00, 0x00];
    /// <summary>
    /// Object Region Name
    /// </summary>
    /// <remarks>
    /// Region in a country where object is depicted
    /// </remarks>
    private static readonly byte[] ObjectRegionName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x03, 0x01, 0x01, 0x00];
    /// <summary>
    /// Object to Object Relationships
    /// </summary>
    /// <remarks>
    /// The relationship value in terms of Parent of;  Child of;  Item of;
    /// </remarks>
    private static readonly byte[] ObjectToObjectRelationships = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x06, 0x01, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Object Type
    /// </summary>
    /// <remarks>
    /// A strong reference to a type of (business) object (e.g. clip, segment, item, series, episode...)
    /// </remarks>
    private static readonly byte[] objectType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0F, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Object Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group to specify a type of (business) object (e.g. clip, segment, item, series, episode...)
    /// </remarks>
    private static readonly byte[] objectTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0F, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Object Type Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to one or more object types (e.g. clip, segment, item, series, episode)
    /// </remarks>
    private static readonly byte[] objectTypeObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0E, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Object Vertical Average Dimension
    /// </summary>
    /// <remarks>
    /// Average number of vertical pixels or lines when a bounding rectangle is placed around an object in the frame or field of view.
    /// </remarks>
    private static readonly byte[] ObjectVerticalAverageDimension = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Obliquity Angle
    /// </summary>
    /// <remarks>
    /// Obliquity angle of image expressed in degrees.  The inverse of sensor depression angle.
    /// </remarks>
    private static readonly byte[] ObliquityAngle = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x10, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Occupation
    /// </summary>
    /// <remarks>
    /// The occupation of the contact / person e.g. in an organization
    /// </remarks>
    private static readonly byte[] occupation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x22, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Offset
    /// </summary>
    /// <remarks>
    /// Offset value in seconds
    /// </remarks>
    private static readonly byte[] Offset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x07, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Offsets
    /// </summary>
    /// <remarks>
    /// Information about offset times
    /// </remarks>
    private static readonly byte[] Offsets = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x03, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// Offset to Index Table
    /// </summary>
    /// <remarks>
    /// Offset between current location and metadata
    /// </remarks>
    private static readonly byte[] OffsetToIndexTable = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x08, 0x02, 0x02, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Offset to Index Table
    /// </summary>
    /// <remarks>
    /// Offset between current location and metadata
    /// </remarks>
    private static readonly byte[] OffsetToIndexTable_Int32 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x08, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Offset to Metadata
    /// </summary>
    /// <remarks>
    /// Offset between current location and metadata
    /// </remarks>
    private static readonly byte[] OffsetToMetadata = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x08, 0x02, 0x02, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Offset to Metadata
    /// </summary>
    /// <remarks>
    /// Offset between current location and metadata
    /// </remarks>
    private static readonly byte[] OffsetToMetadata_Int32 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x08, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// OMB Status
    /// </summary>
    /// <remarks>
    /// OMB Status
    /// </remarks>
    private static readonly byte[] OMBStatus = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Omneon Video Networks
    /// </summary>
    /// <remarks>
    /// Metadata registered by Omneon Video Networks for private use
    /// </remarks>
    private static readonly byte[] OmneonVideoNetworks = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x0E, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// On Off Interact
    /// </summary>
    /// <remarks>
    /// Set to true to allow interaction.
    /// </remarks>
    private static readonly byte[] onOffInteract = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x64, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Operating System Interpretations
    /// </summary>
    /// <remarks>
    /// 1-byte code for distinction of common operating systems
    /// </remarks>
    private static readonly byte[] OperatingSystemInterpretations = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Operation
    /// </summary>
    /// <remarks>
    /// Specifies the Effect or Transition used in an operation
    /// </remarks>
    private static readonly byte[] Operation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x30, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Operational Pattern UL
    /// </summary>
    /// <remarks>
    /// Specifies the SMPTE Universal Label that locates an Operational Pattern
    /// </remarks>
    private static readonly byte[] OperationalPattern = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x02, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Operation Category
    /// </summary>
    /// <remarks>
    /// Specifies the Category of the Effect or Transformation
    /// </remarks>
    private static readonly byte[] OperationCategory = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x30, 0x05, 0x0A, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Operation Data Definition
    /// </summary>
    /// <remarks>
    /// Basic essence kind resulting from the defined Operation
    /// </remarks>
    private static readonly byte[] OperationDataDefinition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x30, 0x05, 0x09, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Operation Definitions
    /// </summary>
    /// <remarks>
    /// Specifies a unordered set of references to Operation Definitions
    /// </remarks>
    private static readonly byte[] OperationDefinitions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x05, 0x03, 0x00, 0x00];
    /// <summary>
    /// Input Segment Count
    /// </summary>
    /// <remarks>
    /// Specifies the number of input segments
    /// </remarks>
    private static readonly byte[] OperationInputCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x30, 0x05, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Operation Message Identifiers
    /// </summary>
    /// <remarks>
    /// Identifiers relating to the operation message.
    /// </remarks>
    private static readonly byte[] OperationMessageIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x03, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Operation Parameters
    /// </summary>
    /// <remarks>
    /// Specifies references to the paramater definitions that may be used with the effect
    /// </remarks>
    private static readonly byte[] OperationParametersDefined = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x03, 0x02, 0x00, 0x00];
    /// <summary>
    /// Qlty Operator Comment
    /// </summary>
    /// <remarks>
    /// String of Operator comments concerning the capturing of the sound signal, from the BWF &lt;qlty&gt; chunk
    /// </remarks>
    private static readonly byte[] OperatorComment = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x05, 0x02, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Optical Anti-Aliasing Filter
    /// </summary>
    /// <remarks>
    /// Roll off frequency of the optical filter placed before the image sensor
    /// </remarks>
    private static readonly byte[] OpticalAntiAliasingFilter = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x01, 0x03, 0x01, 0x0F, 0x00, 0x00];
    /// <summary>
    /// Optical Characteristics
    /// </summary>
    /// <remarks>
    /// Information about optics
    /// </remarks>
    private static readonly byte[] OpticalCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x20, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Optical Device Parameters
    /// </summary>
    /// <remarks>
    /// Information about the optical device used (examples: lens, ice block)
    /// </remarks>
    private static readonly byte[] OpticalDeviceParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x20, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Optical Disc Number
    /// </summary>
    /// <remarks>
    /// An organizationally given number for an optical disc or disc pack.
    /// </remarks>
    private static readonly byte[] OpticalDiscNumber_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x03, 0x02, 0x03, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Optical Discs
    /// </summary>
    /// <remarks>
    /// Information about optical discs.
    /// </remarks>
    private static readonly byte[] OpticalDiscs = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x03, 0x02, 0x03, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Optical Extender Magnification
    /// </summary>
    /// <remarks>
    /// Magnification factor setup of an optical extender or conversion lens where present
    /// </remarks>
    private static readonly byte[] OpticalExtenderMagnification = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x02, 0x02, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Optical Inversion
    /// </summary>
    /// <remarks>
    /// Upside-down and/or right-side-left imaging depending on the lens system
    /// </remarks>
    private static readonly byte[] OpticalInversion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x02, 0x02, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Optical Shooting Parameters
    /// </summary>
    /// <remarks>
    /// Optical shooting/setting parameters during acquisition
    /// </remarks>
    private static readonly byte[] OpticalShootingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Optical Test Parameter Name
    /// </summary>
    /// <remarks>
    /// The specific parameter under test, (example: Flare)
    /// </remarks>
    private static readonly byte[] OpticalTestParameterName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x20, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Optical Test Parameters
    /// </summary>
    /// <remarks>
    /// Optical test parameters from the original recording
    /// </remarks>
    private static readonly byte[] OpticalTestParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x20, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Optical Test Result
    /// </summary>
    /// <remarks>
    /// The result from the specified test
    /// </remarks>
    private static readonly byte[] OpticalTestResult = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x20, 0x02, 0x01, 0x01, 0x03, 0x00, 0x00];
    /// <summary>
    /// Optical Test Result
    /// </summary>
    /// <remarks>
    /// The result from the specified test
    /// </remarks>
    private static readonly byte[] OpticalTestResult_Float = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x20, 0x02, 0x01, 0x01, 0x02, 0x00, 0x00];
    /// <summary>
    /// Optical Track
    /// </summary>
    /// <remarks>
    /// The kind of optical track from which the sound was recovered
    /// </remarks>
    private static readonly byte[] OpticalTrack_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Opto-Electronic Formulation
    /// </summary>
    /// <remarks>
    /// Fundamental opto-elecronic transfer etc characteristics
    /// </remarks>
    private static readonly byte[] OptoElectronicFormulation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Ordered Group Flag
    /// </summary>
    /// <remarks>
    /// A flag indicating if a related group is ordered, when applicable
    /// </remarks>
    private static readonly byte[] orderedGroupFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x01, 0x05, 0x00, 0x00];
    /// <summary>
    /// Organization
    /// </summary>
    /// <remarks>
    /// A set of attributes to provide Information about an organization
    /// </remarks>
    private static readonly byte[] organization = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x23, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organizationally Registered as Private
    /// </summary>
    /// <remarks>
    /// Organizationally Registered as Private
    /// </remarks>
    private static readonly byte[] OrganizationallyRegisteredasPrivate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organizationally Registered for Public Use
    /// </summary>
    /// <remarks>
    /// Organizationally Registered for Public Use
    /// </remarks>
    private static readonly byte[] OrganizationallyRegisteredforPublicUse = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organizational Program Identifiers
    /// </summary>
    /// <remarks>
    /// Program identifiers unique within an organization
    /// </remarks>
    private static readonly byte[] OrganizationalProgramIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x03, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organizational Program Number
    /// </summary>
    /// <remarks>
    /// An Identifier, unique only within an organization, for a program
    /// </remarks>
    private static readonly byte[] OrganizationalProgramNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x03, 0x05, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organizational Program Number
    /// </summary>
    /// <remarks>
    /// An Identifier, unique only within an organization, for a program
    /// </remarks>
    private static readonly byte[] OrganizationalProgramNumber_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x03, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organization Code
    /// </summary>
    /// <remarks>
    /// The identifying Code for an organization
    /// </remarks>
    private static readonly byte[] OrganizationCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x01, 0x0A, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organization Code
    /// </summary>
    /// <remarks>
    /// The identifying Code for an organization
    /// </remarks>
    private static readonly byte[] OrganizationCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x01, 0x0A, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organization Code Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to codes attributed to an organization
    /// </remarks>
    private static readonly byte[] organizationCodeObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x23, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organization Department Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a department within an organization
    /// </remarks>
    private static readonly byte[] organizationDepartmentObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x23, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organization Description
    /// </summary>
    /// <remarks>
    /// Information about an organization
    /// </remarks>
    private static readonly byte[] organizationDescription = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x23, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organization Details Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to details about an organization
    /// </remarks>
    private static readonly byte[] organizationDetailsObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x23, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organization ID
    /// </summary>
    /// <remarks>
    /// The internationally recognized unique identifier for a broadcasting organization
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] OrganizationID_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x10, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organization ID
    /// </summary>
    /// <remarks>
    /// an identifier attributed to the organization
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] OrganizationID_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x23, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organization ID
    /// </summary>
    /// <remarks>
    /// The broadcasting organization concerned
    /// </remarks>
    private static readonly byte[] OrganizationID_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organization Identifiers
    /// </summary>
    /// <remarks>
    /// Unique Identifiers for non-Broadcasting Organizations
    /// </remarks>
    private static readonly byte[] OrganizationIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organization ID Kind
    /// </summary>
    /// <remarks>
    /// Specifies the identification system in use.  E.g. OUT, ITU, EBU, Callsign etc
    /// </remarks>
    private static readonly byte[] OrganizationIDKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x01, 0x01, 0x10, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organization ID Kind
    /// </summary>
    /// <remarks>
    /// Specifies the identification system in use.  E.g. OUT, ITU, EBU, Callsign etc
    /// </remarks>
    private static readonly byte[] OrganizationIDKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x01, 0x01, 0x10, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organization Kind
    /// </summary>
    /// <remarks>
    /// Limited company, government department etc.
    /// </remarks>
    private static readonly byte[] OrganizationKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x30, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organization Kind
    /// </summary>
    /// <remarks>
    /// Limited company, government department etc.
    /// </remarks>
    private static readonly byte[] OrganizationKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organization Last Update
    /// </summary>
    /// <remarks>
    /// The date when the organization information has been last updated
    /// </remarks>
    private static readonly byte[] organizationLastUpdate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x23, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organization Link To Logo
    /// </summary>
    /// <remarks>
    /// A pointer to the location of a visual identifier of an organization
    /// </remarks>
    private static readonly byte[] organizationLinkToLogo = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x23, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organization Main Name
    /// </summary>
    /// <remarks>
    /// The main name by which an organization is known
    /// </remarks>
    private static readonly byte[] OrganizationMainName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x30, 0x06, 0x03, 0x03, 0x01, 0x01, 0x00];
    /// <summary>
    /// Organization Main Name
    /// </summary>
    /// <remarks>
    /// The main name by which an organization is known
    /// </remarks>
    private static readonly byte[] OrganizationMainName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x06, 0x03, 0x03, 0x01, 0x00, 0x00];
    /// <summary>
    /// Organization Name Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to names associated with the organization
    /// </remarks>
    private static readonly byte[] organizationNameObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x23, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organization Names
    /// </summary>
    /// <remarks>
    /// Name information for organizations
    /// </remarks>
    private static readonly byte[] OrganizationNames = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x06, 0x03, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organization Nationality
    /// </summary>
    /// <remarks>
    /// The nationality of an organization
    /// </remarks>
    private static readonly byte[] organizationNationality = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x23, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organization Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of one or more strong references to Organization sets
    /// </remarks>
    private static readonly byte[] OrganizationObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x15, 0x00];
    /// <summary>
    /// Organization Related Contact Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to contact objects (entity)
    /// </remarks>
    private static readonly byte[] organizationRelatedContactObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x23, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organization Related Information Link Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to links to e.g. a webpage where more information can be found
    /// </remarks>
    private static readonly byte[] organizationRelatedInformationLinkObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x23, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organizations and Public Bodies
    /// </summary>
    /// <remarks>
    /// Details of Organizations and Public Bodies contributing to or taking part in the production
    /// </remarks>
    private static readonly byte[] OrganizationsAndPublicBodies = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Organization Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of generalized weak (global) references to  Organization sets
    /// </remarks>
    private static readonly byte[] OrganizationSets = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x03, 0x40, 0x15, 0x00];
    /// <summary>
    /// Organization Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group to define the type of organization being described
    /// </remarks>
    private static readonly byte[] organizationTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x23, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Origin
    /// </summary>
    /// <remarks>
    /// Specifies the point, in edit units, in a track from which relative times are measured.
    /// </remarks>
    private static readonly byte[] Origin = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x07, 0x02, 0x01, 0x03, 0x01, 0x03, 0x00, 0x00];
    /// <summary>
    /// Original Extended Spoken Primary Language Code
    /// </summary>
    /// <remarks>
    /// The RFC-3066-compliant code that specifies the base ISO code for the language as well as regional variant information for the original primary spoken language
    /// </remarks>
    private static readonly byte[] OriginalExtendedSpokenLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x01, 0x02, 0x03, 0x13, 0x00, 0x00];
    /// <summary>
    /// Original Producer Name
    /// </summary>
    /// <remarks>
    /// The name of the original content Producer.
    /// </remarks>
    private static readonly byte[] OriginalProducerName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x02, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Original Producer Name
    /// </summary>
    /// <remarks>
    /// The name of the original content Producer.
    /// </remarks>
    private static readonly byte[] OriginalProducerName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Original Property
    /// </summary>
    /// <remarks>
    /// Specifies the original definition of the reused Property
    /// </remarks>
    private static readonly byte[] OriginalProperty = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x06, 0x01, 0x01, 0x07, 0x20, 0x00, 0x00, 0x00];
    /// <summary>
    /// Original Title
    /// </summary>
    /// <remarks>
    /// The original title of a production
    /// </remarks>
    private static readonly byte[] OriginalTitle = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x0B, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Original Title
    /// </summary>
    /// <remarks>
    /// The original title of a production
    /// </remarks>
    private static readonly byte[] OriginalTitle_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Origin Code
    /// </summary>
    /// <remarks>
    /// Code indicating the type of source of material
    /// </remarks>
    private static readonly byte[] OriginCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x10, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Other Given Name
    /// </summary>
    /// <remarks>
    /// A batch of strong references to given names other than the first given name
    /// </remarks>
    private static readonly byte[] otherGivenName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x22, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// Other Given Names
    /// </summary>
    /// <remarks>
    /// Other given names for an individual
    /// </remarks>
    private static readonly byte[] OtherGivenNames = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x30, 0x06, 0x03, 0x01, 0x08, 0x01, 0x00];
    /// <summary>
    /// Other Given Names
    /// </summary>
    /// <remarks>
    /// Other given names for an individual
    /// </remarks>
    private static readonly byte[] OtherGivenNames_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x30, 0x06, 0x03, 0x01, 0x08, 0x00, 0x00];
    /// <summary>
    /// Other Values
    /// </summary>
    /// <remarks>
    /// Assessment of other relevant qualities
    /// </remarks>
    private static readonly byte[] OtherValues_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x02, 0x02, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Cue-Out Words
    /// </summary>
    /// <remarks>
    /// The words on the sound track or a textual reference to music etc. at the out-cue point
    /// </remarks>
    private static readonly byte[] OutCueWords = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x03, 0x02, 0x01, 0x02, 0x0E, 0x01, 0x00, 0x00];
    /// <summary>
    /// Overlap Process Option
    /// </summary>
    /// <remarks>
    /// Enumerator that indicates one of the two methods of combining rendered pixels
    /// </remarks>
    private static readonly byte[] OverlapProcessOption = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x35, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Package Attributes
    /// </summary>
    /// <remarks>
    /// Specifies a set of references to Tagged Values associated with the entire package
    /// </remarks>
    private static readonly byte[] PackageAttributes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x02, 0x10, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Package ID
    /// </summary>
    /// <remarks>
    /// Identifies the Metadata Object with a  a unique identifier
    /// </remarks>
    private static readonly byte[] PackageID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x15, 0x10, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Package Identifiers
    /// </summary>
    /// <remarks>
    /// Local identifiers which are not unique other than at package level
    /// </remarks>
    private static readonly byte[] PackageIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Package Info
    /// </summary>
    /// <remarks>
    /// A set of attribute to provide information on the package
    /// </remarks>
    private static readonly byte[] packageInfo = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3C, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Package KLV Data
    /// </summary>
    /// <remarks>
    /// Specifies a set of references to KLV data associated with the entire package
    /// </remarks>
    private static readonly byte[] PackageKLVData = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x02, 0x10, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Package Last Modification Date-Time
    /// </summary>
    /// <remarks>
    /// Identifies date and time at the point of most recent modification of the package
    /// </remarks>
    private static readonly byte[] PackageLastModified = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x07, 0x02, 0x01, 0x10, 0x02, 0x05, 0x00, 0x00];
    /// <summary>
    /// Package Locator
    /// </summary>
    /// <remarks>
    /// A strong reference to a locator from where the package can be accessed
    /// </remarks>
    private static readonly byte[] packageLocatorObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3C, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Package Marker Object
    /// </summary>
    /// <remarks>
    /// A strong reference to a Package Marker object
    /// </remarks>
    private static readonly byte[] PackageMarkerObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x06, 0x01, 0x01, 0x04, 0x02, 0x0F, 0x00, 0x00];
    /// <summary>
    /// Package Mark In Position
    /// </summary>
    /// <remarks>
    /// Specifies an optional start of playback position. The position is measured relative to the origin, in edit units, and applies to all tracks of the material.
    /// </remarks>
    private static readonly byte[] PackageMarkInPosition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x07, 0x02, 0x01, 0x03, 0x01, 0x0E, 0x00, 0x00];
    /// <summary>
    /// Package Mark Out Position
    /// </summary>
    /// <remarks>
    /// Specifies an optional end of playback position. The position is measured relative to the origin, in edit units, and applies to all tracks of the material.
    /// </remarks>
    private static readonly byte[] PackageMarkOutPosition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x07, 0x02, 0x01, 0x03, 0x02, 0x04, 0x00, 0x00];
    /// <summary>
    /// Package Name
    /// </summary>
    /// <remarks>
    /// Identifies a metadata package by name
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] PackageName_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Package Name
    /// </summary>
    /// <remarks>
    /// The name of the package
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] PackageName_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3C, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Package Name
    /// </summary>
    /// <remarks>
    /// Identifies a metadata package by name
    /// </remarks>
    private static readonly byte[] PackageName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x01, 0x03, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Package Overall Bitrate Set
    /// </summary>
    /// <remarks>
    /// To specify the overall bitrate of a mixed package composed of e.g. audio, video and data.
    /// </remarks>
    private static readonly byte[] packageOverallBitRateObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3C, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Packages
    /// </summary>
    /// <remarks>
    /// Specifies a unordered set of references to Packages
    /// </remarks>
    private static readonly byte[] Packages = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x05, 0x01, 0x00, 0x00];
    /// <summary>
    /// Package Size
    /// </summary>
    /// <remarks>
    /// A strong reference to a dimension object
    /// </remarks>
    private static readonly byte[] packageSize = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3C, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Package Timeline Marker Object
    /// </summary>
    /// <remarks>
    /// A strong reference to a Package Marker object
    /// </remarks>
    private static readonly byte[] PackageTimelineMarkerObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x06, 0x01, 0x01, 0x04, 0x02, 0x10, 0x00, 0x00];
    /// <summary>
    /// Package Tracks
    /// </summary>
    /// <remarks>
    /// Specifies a vector of references to tracks
    /// </remarks>
    private static readonly byte[] PackageTracks = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x06, 0x05, 0x00, 0x00];
    /// <summary>
    /// Package Usage Kind
    /// </summary>
    /// <remarks>
    /// Indicates the role of a Package (also known as Mob) as a sub-clip, adjusted clip, template clip or other
    /// </remarks>
    private static readonly byte[] PackageUsage = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x05, 0x01, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Package User Comments
    /// </summary>
    /// <remarks>
    /// Specifies a vector of references to categorized package comments
    /// </remarks>
    private static readonly byte[] PackageUserComments = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x01, 0x02, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Pack Length
    /// </summary>
    /// <remarks>
    /// Big-endian overall length of set or pack
    /// </remarks>
    private static readonly byte[] PackLength = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x04, 0x06, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Padding Bits
    /// </summary>
    /// <remarks>
    /// Specifies the number of bits to pad each pixel so that the next pixel starts on a defined boundary
    /// </remarks>
    private static readonly byte[] PaddingBits = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x18, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Palette
    /// </summary>
    /// <remarks>
    /// Specifies, as a single string, the fixed length values of each color in the palette used.
    /// </remarks>
    private static readonly byte[] Palette = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x01, 0x05, 0x03, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Palette Layout
    /// </summary>
    /// <remarks>
    /// Specifies pixel quantisation and order in the palette as a data structure.
    /// </remarks>
    private static readonly byte[] PaletteLayout = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x01, 0x05, 0x03, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Pan-and-Scan Image Dimensions
    /// </summary>
    /// <remarks>
    /// Length measurements relating to pan and scan subsetting of a captured image
    /// </remarks>
    private static readonly byte[] PanAndScanImageDimensions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x09, 0x04, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Panasonic
    /// </summary>
    /// <remarks>
    /// Metadata registered by Panasonic for private use
    /// </remarks>
    private static readonly byte[] Panasonic = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Pan Scan Information
    /// </summary>
    /// <remarks>
    /// The Pan-Scan information is a concatenated series of codes, flags, and values that describe a variable image viewport and the output aspect ratio.
    /// </remarks>
    private static readonly byte[] PanScanInformation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x04, 0x01, 0x01, 0x01, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Parameter Definition
    /// </summary>
    /// <remarks>
    /// Specifies a reference to the definition of a Parameter
    /// </remarks>
    private static readonly byte[] ParameterDefinitionReference = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x01, 0x04, 0x00, 0x00];
    /// <summary>
    /// Parameter Definitions
    /// </summary>
    /// <remarks>
    /// Specifies a unordered set of references to Parameter Definitions
    /// </remarks>
    private static readonly byte[] ParameterDefinitions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x05, 0x04, 0x00, 0x00];
    /// <summary>
    /// Display Units
    /// </summary>
    /// <remarks>
    /// Specifies the displayable name of the units of a parameter
    /// </remarks>
    private static readonly byte[] ParameterDisplayUnits = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x30, 0x05, 0x0B, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Parameters
    /// </summary>
    /// <remarks>
    /// Specifies a vector of an unordered set of references to the effect or operation parameters
    /// </remarks>
    private static readonly byte[] Parameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x06, 0x0A, 0x00, 0x00];
    /// <summary>
    /// Parameter Data Type
    /// </summary>
    /// <remarks>
    /// Specifies a reference to the definition of  the type of a parameter
    /// </remarks>
    private static readonly byte[] ParameterType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x01, 0x06, 0x00, 0x00];
    /// <summary>
    /// PARAMETRIC
    /// </summary>
    /// <remarks>
    /// Class 4 is reserved for parametric and configuration metadata.
    /// </remarks>
    private static readonly byte[] Parametric = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Parent
    /// </summary>
    /// <remarks>
    /// Parent - the parent company of the advertiser
    /// </remarks>
    private static readonly byte[] parent = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x0D, 0x0D, 0x01, 0x0B, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Parent Class
    /// </summary>
    /// <remarks>
    /// Specifies a reference to the class definition of the parent
    /// </remarks>
    private static readonly byte[] ParentClass = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x07, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Part
    /// </summary>
    /// <remarks>
    /// A set of attributes used to describe a part
    /// </remarks>
    private static readonly byte[] part = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x43, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Part Definition
    /// </summary>
    /// <remarks>
    /// An definition associated with a part/segment or clip
    /// </remarks>
    private static readonly byte[] partDefinition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x44, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Part Duration Object
    /// </summary>
    /// <remarks>
    /// To express the duration of a part
    /// </remarks>
    private static readonly byte[] partDurationTimeObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x44, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Participant ID
    /// </summary>
    /// <remarks>
    /// Unique identifier of a Participant set as the target of a generalized weak (global) reference
    /// </remarks>
    private static readonly byte[] ParticipantID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x01, 0x01, 0x15, 0x40, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Shot Participant Role Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to ParticipantRole sets
    /// </remarks>
    private static readonly byte[] ParticipantObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x13, 0x00];
    /// <summary>
    /// Participant Organization Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of generalized weak (global) references to  Organization sets for Participant Roles
    /// </remarks>
    private static readonly byte[] ParticipantOrganizations = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x03, 0x40, 0x15, 0x01];
    /// <summary>
    /// Participant Role Sets
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] ParticipantRoleSets = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x03, 0x40, 0x13, 0x00];
    /// <summary>
    /// Participating Parties
    /// </summary>
    /// <remarks>
    /// Details of all parties,  contributing to or taking part in the production - staff, contributors, and including those receiving Credits etc
    /// </remarks>
    private static readonly byte[] ParticipatingParties = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Part  ID
    /// </summary>
    /// <remarks>
    /// An Identifier associated with a part/segment or clip
    /// </remarks>
    private static readonly byte[] partID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x44, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Part  Metadata
    /// </summary>
    /// <remarks>
    /// A set of attributes to provide the metadata describing a part
    /// </remarks>
    private static readonly byte[] partMetadata = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x44, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Part  Metadata  Set
    /// </summary>
    /// <remarks>
    /// A strong reference to the part metadata set
    /// </remarks>
    private static readonly byte[] partMetadataObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x43, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Part Meta Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a core metadata object
    /// </remarks>
    private static readonly byte[] partMetaObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x44, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Part Name
    /// </summary>
    /// <remarks>
    /// An name associated with a part/segment or clip
    /// </remarks>
    private static readonly byte[] partName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x44, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Part Number
    /// </summary>
    /// <remarks>
    /// The part number
    /// </remarks>
    private static readonly byte[] partNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x44, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Part Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to one or more parts/segments (editorial, technical parameter timeline...) within the resource
    /// </remarks>
    private static readonly byte[] partObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x02, 0x15, 0x00, 0x00, 0x00];
    /// <summary>
    /// Part Start Time Object
    /// </summary>
    /// <remarks>
    /// To express the start time of a part
    /// </remarks>
    private static readonly byte[] partStartTimeObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x44, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Part Total Number
    /// </summary>
    /// <remarks>
    /// The total number of parts
    /// </remarks>
    private static readonly byte[] partTotalNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x44, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Part Type Group Set
    /// </summary>
    /// <remarks>
    /// The strong reference to a type group to define a type of Part  (e.g. editorial or technical)
    /// </remarks>
    private static readonly byte[] partTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x44, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Password
    /// </summary>
    /// <remarks>
    /// An individual password for access to the system
    /// </remarks>
    private static readonly byte[] Password = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x08, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Password
    /// </summary>
    /// <remarks>
    /// An individual password for access to the system
    /// </remarks>
    private static readonly byte[] Password_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x08, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Payee Account Name
    /// </summary>
    /// <remarks>
    /// The name of the account into which a payment is to be made
    /// </remarks>
    private static readonly byte[] PayeeAccountName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x06, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Payee Account Number
    /// </summary>
    /// <remarks>
    /// The number of an account into which a payment is to be made
    /// </remarks>
    private static readonly byte[] PayeeAccountNumber_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x06, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Payee Account Sort Code
    /// </summary>
    /// <remarks>
    /// The sort code for the account into which a payment is to be made
    /// </remarks>
    private static readonly byte[] PayeeAccountSortCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x06, 0x02, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Payer Account Name
    /// </summary>
    /// <remarks>
    /// The name of the account from which a payment is to come
    /// </remarks>
    private static readonly byte[] PayerAccountName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x06, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Payer Account Number
    /// </summary>
    /// <remarks>
    /// The number of an account from which a payment is to come
    /// </remarks>
    private static readonly byte[] PayerAccountNumber_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x06, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Payer Account Sort Code
    /// </summary>
    /// <remarks>
    /// The sort code for the account from which a payment is to come
    /// </remarks>
    private static readonly byte[] PayerAccountSortCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x06, 0x03, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Payment Due Date-Time
    /// </summary>
    /// <remarks>
    /// The due Date and time of a payment
    /// </remarks>
    private static readonly byte[] PaymentDueDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x07, 0x02, 0x01, 0x20, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Payments and Costs
    /// </summary>
    /// <remarks>
    /// Payments and costing information
    /// </remarks>
    private static readonly byte[] PaymentsAndCosts = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Payments Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Payments sets
    /// </remarks>
    private static readonly byte[] PaymentsSets = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x1B, 0x00];
    /// <summary>
    /// PBS
    /// </summary>
    /// <remarks>
    /// Metadata registered by the Public Broadcasting Service for public use
    /// </remarks>
    private static readonly byte[] PBS = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x0D, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Peak Channel Count
    /// </summary>
    /// <remarks>
    /// Number of peak channels
    /// </remarks>
    private static readonly byte[] PeakChannels = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x04, 0x02, 0x03, 0x01, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Peak Envelope
    /// </summary>
    /// <remarks>
    /// Peak envelope information - value contains a header followed by the data of the peak points.
    /// </remarks>
    private static readonly byte[] PeakEnvelope = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x03, 0x01, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Peak Envelope Block Size
    /// </summary>
    /// <remarks>
    /// Number of audio samples used to generate each peak frame
    /// </remarks>
    private static readonly byte[] PeakEnvelopeBlockSize = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x04, 0x02, 0x03, 0x01, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Peak Envelope Data
    /// </summary>
    /// <remarks>
    /// The peak envelope data stream
    /// </remarks>
    private static readonly byte[] PeakEnvelopeData = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x04, 0x02, 0x03, 0x01, 0x0E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Peak Envelope Format
    /// </summary>
    /// <remarks>
    /// Data format of the peak envelope data
    /// </remarks>
    private static readonly byte[] PeakEnvelopeFormat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x04, 0x02, 0x03, 0x01, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Peak Envelope Timestamp
    /// </summary>
    /// <remarks>
    /// Timestamp of the creation of the peak data
    /// </remarks>
    private static readonly byte[] PeakEnvelopeTimestamp = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x04, 0x02, 0x03, 0x01, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Peak Envelope Version
    /// </summary>
    /// <remarks>
    /// Version number of the peak envelope data format specification
    /// </remarks>
    private static readonly byte[] PeakEnvelopeVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x04, 0x02, 0x03, 0x01, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Peak Frame Count
    /// </summary>
    /// <remarks>
    /// Number of peak frames
    /// </remarks>
    private static readonly byte[] PeakFrames = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x04, 0x02, 0x03, 0x01, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Peak Of Peaks Position
    /// </summary>
    /// <remarks>
    /// Offset of the first audio sample whose absolute value in the maximum value of the entire audio file
    /// </remarks>
    private static readonly byte[] PeakOfPeaksPosition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x04, 0x02, 0x03, 0x01, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Perceived Display Format Name
    /// </summary>
    /// <remarks>
    /// Colloquial description of the image when viewed in its intended aspect ratio on a display of another aspect ratio - e.g. pillarbox, letterbox, mixed etc.
    /// </remarks>
    private static readonly byte[] PerceivedDisplayFormat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x01, 0x01, 0x01, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Perceived Display Format Code
    /// </summary>
    /// <remarks>
    /// A code for the colloquial description of the image when viewed in its intended aspect ratio on a display of another aspect ratio (e.g., a code for pillarbox, letterbox, mixed)
    /// </remarks>
    private static readonly byte[] PerceivedDisplayFormatCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x01, 0x01, 0x01, 0x08, 0x01, 0x00, 0x00];
    /// <summary>
    /// Perforations Per Frame
    /// </summary>
    /// <remarks>
    /// Specifies number of perforations per frame [e.g. 2, 3, 4, 5, 8, 10, 12, 15]
    /// </remarks>
    private static readonly byte[] PerforationsPerFrame = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x10, 0x01, 0x03, 0x01, 0x03, 0x00, 0x00];
    /// <summary>
    /// Perforations Per Frame
    /// </summary>
    /// <remarks>
    /// Specifies number of perforations per frame [e.g. 2, 3, 4, 5, 8, 10, 12, 15] or non-integer values
    /// </remarks>
    private static readonly byte[] PerforationsPerFrame_Rational = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x10, 0x01, 0x03, 0x01, 0x03, 0x01, 0x00];
    /// <summary>
    /// Period End Date
    /// </summary>
    /// <remarks>
    /// The ending date of the time period
    /// </remarks>
    private static readonly byte[] periodEndDate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x18, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Period End Time
    /// </summary>
    /// <remarks>
    /// The ending time of the time period
    /// </remarks>
    private static readonly byte[] periodEndTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x18, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Period End Year
    /// </summary>
    /// <remarks>
    /// The ending year of the time period
    /// </remarks>
    private static readonly byte[] periodEndYear = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x18, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Period ID
    /// </summary>
    /// <remarks>
    /// An idenitifer associated with the time period
    /// </remarks>
    private static readonly byte[] periodID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x18, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Period Name Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to names associated with the time period optionally in different languages
    /// </remarks>
    private static readonly byte[] periodNameObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x18, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Period Of Time
    /// </summary>
    /// <remarks>
    /// A set of attributes to define a time period
    /// </remarks>
    private static readonly byte[] periodOfTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x18, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Period Of Time Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to time period objects
    /// </remarks>
    private static readonly byte[] periodOfTimeObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x17, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Period Start Date
    /// </summary>
    /// <remarks>
    /// The starting date of the time period
    /// </remarks>
    private static readonly byte[] periodStartDate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x18, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Period Start Time
    /// </summary>
    /// <remarks>
    /// The starting time of the time period
    /// </remarks>
    private static readonly byte[] periodStartTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x18, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Period Start Year
    /// </summary>
    /// <remarks>
    /// The starting year of the time period
    /// </remarks>
    private static readonly byte[] periodStartYear = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x18, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Person Description
    /// </summary>
    /// <remarks>
    /// Description of a person used to distinguish them from other persons of the same name - e.g. farmer, poet, American dentist.
    /// </remarks>
    private static readonly byte[] PersonDescription = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x30, 0x06, 0x03, 0x01, 0x07, 0x01, 0x00];
    /// <summary>
    /// Person Description
    /// </summary>
    /// <remarks>
    /// Description of a person used to distinguish them from other persons of the same name - e.g. farmer, poet, American dentist.
    /// </remarks>
    private static readonly byte[] PersonDescription_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x30, 0x06, 0x03, 0x01, 0x07, 0x00, 0x00];
    /// <summary>
    /// Person Names
    /// </summary>
    /// <remarks>
    /// Name information for persons
    /// </remarks>
    private static readonly byte[] PersonNames = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x06, 0x03, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Shot Person Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of one or more strong references to Person sets
    /// </remarks>
    private static readonly byte[] PersonObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x14, 0x00];
    /// <summary>
    /// Person Organization Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of generalized weak (global) references to  Organization sets for Persons
    /// </remarks>
    private static readonly byte[] PersonOrganizations = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x03, 0x40, 0x15, 0x02];
    /// <summary>
    /// Person or Organization Details
    /// </summary>
    /// <remarks>
    /// The name of  person(s), organization or public body
    /// </remarks>
    private static readonly byte[] PersonOrOrganizationDetails = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Person Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of generalized weak (global) references to  Person sets
    /// </remarks>
    private static readonly byte[] Persons = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x03, 0x40, 0x14, 0x00];
    /// <summary>
    /// Film to Video Transfer Phase
    /// </summary>
    /// <remarks>
    /// Specifies the history of the position of the starting frame in the pulldown sequence (A is 0)
    /// </remarks>
    private static readonly byte[] PhaseFrame = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x40, 0x10, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Physical Instance Kind
    /// </summary>
    /// <remarks>
    /// Category of physical copy (e.g., master copy, copy, broadcast copy)
    /// </remarks>
    private static readonly byte[] PhysicalInstanceKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x01, 0x01, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Physical Media Identifiers
    /// </summary>
    /// <remarks>
    /// Physical media identifiers
    /// </remarks>
    private static readonly byte[] PhysicalMediaIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Physical Media Length
    /// </summary>
    /// <remarks>
    /// The physical length of the medium on which the essence was captured
    /// </remarks>
    private static readonly byte[] PhysicalMediaLength = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x10, 0x01, 0x03, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Picture Component Sizing
    /// </summary>
    /// <remarks>
    /// Array of picture components where each component comprises 3 bytes named Ssizi, XRSizi, YRSizi (as defined in ISO/IEC 15444-1 Annex A.5.1). The array of 3-byte groups is preceded by the array header comprising a 4-byte value of the number of components followed by a 4-byte value of '3'.
    /// </remarks>
    private static readonly byte[] PictureComponentSizing = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x06, 0x03, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Coding Scheme ID
    /// </summary>
    /// <remarks>
    /// Specifies the Compression scheme used
    /// </remarks>
    private static readonly byte[] PictureCompression = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x01, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Picture Display Rate
    /// </summary>
    /// <remarks>
    /// The rate at which pictures must be displayed in order to achieve the intended editorial effect, expressed in pictures per second.
    /// </remarks>
    private static readonly byte[] PictureDisplayRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x01, 0x03, 0x01, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Image Format Set
    /// </summary>
    /// <remarks>
    /// A strong reference to the Image Format set
    /// </remarks>
    private static readonly byte[] PictureFormatObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x02, 0x40, 0x1D, 0x00];
    /// <summary>
    /// PII
    /// </summary>
    /// <remarks>
    /// American Chemical Society Publisher Item Identifier
    /// </remarks>
    private static readonly byte[] PII = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x13, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Pixel Layout
    /// </summary>
    /// <remarks>
    /// Specifies pixel quantisation and order as a data structure.
    /// </remarks>
    private static readonly byte[] PixelLayout = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x01, 0x05, 0x03, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Place Descriptions
    /// </summary>
    /// <remarks>
    /// Place descriptions
    /// </remarks>
    private static readonly byte[] PlaceDescriptions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Place Keyword
    /// </summary>
    /// <remarks>
    /// The geographic name(s) of location(s) covered by a data set.
    /// </remarks>
    private static readonly byte[] PlaceKeyword = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x01, 0x01, 0x01, 0x00];
    /// <summary>
    /// Place Keyword
    /// </summary>
    /// <remarks>
    /// The geographic name(s) of location(s) covered by a data set.
    /// </remarks>
    private static readonly byte[] PlaceKeyword_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Place Name
    /// </summary>
    /// <remarks>
    /// The place name of an address as string (e.g., "The Post Office")
    /// </remarks>
    private static readonly byte[] PlaceName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x14, 0x01];
    /// <summary>
    /// Place Name
    /// </summary>
    /// <remarks>
    /// The place name of an address as string (e.g., "The Post Office")
    /// </remarks>
    private static readonly byte[] PlaceName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x14, 0x00];
    /// <summary>
    /// Place Names
    /// </summary>
    /// <remarks>
    /// Place information
    /// </remarks>
    private static readonly byte[] PlaceNames = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Plaintext Offset
    /// </summary>
    /// <remarks>
    /// The position within an encrypted value at which plaintext ends and ciphertext begins
    /// </remarks>
    private static readonly byte[] PlaintextOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x06, 0x09, 0x02, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Planning
    /// </summary>
    /// <remarks>
    /// A set of attributes needed to define a planning
    /// </remarks>
    private static readonly byte[] planning = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2C, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Planning Event Objects
    /// </summary>
    /// <remarks>
    /// A batch of strong references to planning/publication events
    /// </remarks>
    private static readonly byte[] planningEventObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2C, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Planning Id
    /// </summary>
    /// <remarks>
    /// An identifyer associated with a planning
    /// </remarks>
    private static readonly byte[] planningId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2C, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Planning Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a set of planning information (planned where, when, how)
    /// </remarks>
    private static readonly byte[] planningObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x02, 0x11, 0x00, 0x00, 0x00];
    /// <summary>
    /// Platform Designation
    /// </summary>
    /// <remarks>
    /// Identifies the generic name of the platform carrying the device used in capturing or generating the essence
    /// </remarks>
    private static readonly byte[] PlatformDesignation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x01, 0x01, 0x21, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Platform Designation
    /// </summary>
    /// <remarks>
    /// Identifies the generic name of the platform carrying the device used in capturing or generating the essence
    /// </remarks>
    private static readonly byte[] PlatformDesignation_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x21, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Platform Heading Angle
    /// </summary>
    /// <remarks>
    /// Heading angle of platform expressed in degrees. The Heading of an airborne platform is the angle from True North of its longitudinal axis projected onto the horizontal plane. Range of values is 000 to almost 360 degrees; North is 000, East is 090; South is 180, and West is 270.
    /// </remarks>
    private static readonly byte[] PlatformHeadingAngle = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x07, 0x01, 0x10, 0x01, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Platform Identifiers
    /// </summary>
    /// <remarks>
    /// Organizationally given identifiers for platforms, vehicles, or mounts carrying devices or sensors
    /// </remarks>
    private static readonly byte[] PlatformIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Platform Model
    /// </summary>
    /// <remarks>
    /// Identifies the platform model carrying the device used in capturing or generating the essence.
    /// </remarks>
    private static readonly byte[] PlatformModel_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x21, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Platform Pitch Angle
    /// </summary>
    /// <remarks>
    /// Pitch angle of platform expressed in degrees.The Pitch of an airborne platform describes the angle of its longitudinal (front-to-back) axis makes with the horizontal (i.e., equi-potential gravitational surface); positive (negative) angles describe a nose up (down) orientation. Range of values is -90 to +90 degrees.
    /// </remarks>
    private static readonly byte[] PlatformPitchAngle = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x07, 0x01, 0x10, 0x01, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Platform Roll Angle
    /// </summary>
    /// <remarks>
    /// Roll angle of platform expressed in degrees. The Roll of an airborne platform is rotation about its longitudinal (front-to-back) axis; wings level is zero degrees, positive (negative) angles describe a platform orientation with the right wing down(up). Range of values is -180 to +180 degrees
    /// </remarks>
    private static readonly byte[] PlatformRollAngle = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x07, 0x01, 0x10, 0x01, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Platform Serial Number
    /// </summary>
    /// <remarks>
    /// Alphanumeric serial number identifying the individual platform carrying the device used in capturing or generating the essence.
    /// </remarks>
    private static readonly byte[] PlatformSerialNumber_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x21, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Plug-In API ID
    /// </summary>
    /// <remarks>
    /// Identifies the hardware platform of the API
    /// </remarks>
    private static readonly byte[] PluginAPI = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x09, 0x08, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Plug-In Category ID
    /// </summary>
    /// <remarks>
    /// Identifies the general purpose of the plugin
    /// </remarks>
    private static readonly byte[] PluginCategory = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x09, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Plug-In Definitions
    /// </summary>
    /// <remarks>
    /// Specifies a unordered set of references to Plugin Definitions
    /// </remarks>
    private static readonly byte[] PluginDefinitions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x05, 0x06, 0x00, 0x00];
    /// <summary>
    /// Plug-In Locator Set
    /// </summary>
    /// <remarks>
    /// Specifies vector of references to web locators
    /// </remarks>
    private static readonly byte[] PluginLocators = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x09, 0x0D, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Plug-In Platform ID
    /// </summary>
    /// <remarks>
    /// Identifies the hardware platform of the plugin
    /// </remarks>
    private static readonly byte[] PluginPlatform = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x09, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Version Number
    /// </summary>
    /// <remarks>
    /// Specifies the version number of the code
    /// </remarks>
    private static readonly byte[] PluginVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x03, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Version Number String
    /// </summary>
    /// <remarks>
    /// Specifies the string version number of the  code
    /// </remarks>
    private static readonly byte[] PluginVersionString = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x03, 0x01, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Version Number String
    /// </summary>
    /// <remarks>
    /// Specifies the string version number of the  code
    /// </remarks>
    private static readonly byte[] PluginVersionString_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x03, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Control Point List
    /// </summary>
    /// <remarks>
    /// Specifies a vector of references to time-specific operation control values
    /// </remarks>
    private static readonly byte[] PointList = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x06, 0x06, 0x00, 0x00];
    /// <summary>
    /// Points Per Peak Value
    /// </summary>
    /// <remarks>
    /// Number of peak points per peak value
    /// </remarks>
    private static readonly byte[] PointsPerPeakValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x04, 0x02, 0x03, 0x01, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Polar Characteristic
    /// </summary>
    /// <remarks>
    /// polar patterns
    /// </remarks>
    private static readonly byte[] PolarCharacteristic_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x20, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Positional Information
    /// </summary>
    /// <remarks>
    /// Information about absolute and relative position in space
    /// </remarks>
    private static readonly byte[] PositionalInformation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Positional System Information
    /// </summary>
    /// <remarks>
    /// Information about absolute system in use
    /// </remarks>
    private static readonly byte[] PositionalSystemInformation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Position and Space Vectors
    /// </summary>
    /// <remarks>
    /// Information about position in space and associated vectors (if any)
    /// </remarks>
    private static readonly byte[] PositionAndSpaceVectors = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Position in Sequence
    /// </summary>
    /// <remarks>
    /// 1, 2, 3 etc
    /// </remarks>
    private static readonly byte[] PositionInSequence = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x06, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Position Interact
    /// </summary>
    /// <remarks>
    /// Set to true to allow position interaction.
    /// </remarks>
    private static readonly byte[] positionInteract = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x64, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Position Interaction Range
    /// </summary>
    /// <remarks>
    /// To specify the supportes range of supported position interaction.
    /// </remarks>
    private static readonly byte[] positionInteractionRange = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x66, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Position Interaction Range Bound
    /// </summary>
    /// <remarks>
    /// Set attribute to either "min" or "max" to set whether the axis needs a minimum or maximum range for positioning limiting.
    /// </remarks>
    private static readonly byte[] positionInteractionRangeBound = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x66, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Position Interaction Range Coordinate
    /// </summary>
    /// <remarks>
    /// Set attribute to either "X", "Y", "Z", "azimuth", "elevation" or "distance" to set which axis requires limiting.
    /// </remarks>
    private static readonly byte[] positionInteractionRangeCoordinate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x66, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Position Interaction Range Sets
    /// </summary>
    /// <remarks>
    /// Set the range of position values allowed for interaction.
    /// </remarks>
    private static readonly byte[] positionInteractionRangeObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x64, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Position Interaction Range Value
    /// </summary>
    /// <remarks>
    /// Value defnining the range of position.
    /// </remarks>
    private static readonly byte[] positionInteractionRangeValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x66, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Position Table
    /// </summary>
    /// <remarks>
    /// List of 'n' fractional temporal offsets of indexed elements relative to the indexed position
    /// </remarks>
    private static readonly byte[] PositionTable = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x04, 0x04, 0x01, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Position Table Count
    /// </summary>
    /// <remarks>
    /// Number of temporal position offsets indexed, per edit unit, minus one
    /// </remarks>
    private static readonly byte[] PositionTableCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x04, 0x04, 0x01, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Position Table Indexing
    /// </summary>
    /// <remarks>
    /// Value identifying that the element indexed is subject to temporal reordering or offsetting of edit units A "Reorder" flag when negative and an Index into a table when positive
    /// </remarks>
    private static readonly byte[] PositionTableIndex = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x04, 0x04, 0x04, 0x01, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Position Within Viewport Image X Coordinate (Pixels)
    /// </summary>
    /// <remarks>
    /// The position of a point (or object) within the viewed image expressed as x/y coordinates of the viewed image.
    /// </remarks>
    private static readonly byte[] PositionWithinViewportImageXCoordinatePixels = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x03, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Position Within Viewport Image Y Coordinate (Pixels)
    /// </summary>
    /// <remarks>
    /// The position of a point (or object) within the viewed image expressed as x/y coordinates of the viewed image.
    /// </remarks>
    private static readonly byte[] PositionWithinViewportImageYCoordinatePixels = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x03, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// POSIX Microseconds
    /// </summary>
    /// <remarks>
    /// Time stamp application defined by user
    /// </remarks>
    private static readonly byte[] POSIXMicroseconds = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x02, 0x01, 0x01, 0x01, 0x05, 0x00, 0x00];
    /// <summary>
    /// Postal Addresses
    /// </summary>
    /// <remarks>
    /// Information about Postal Addresses
    /// </remarks>
    private static readonly byte[] PostalAddresses = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x00, 0x00];
    /// <summary>
    /// Postal Code
    /// </summary>
    /// <remarks>
    /// The ZIP or other postal code of the address.
    /// </remarks>
    private static readonly byte[] PostalCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x07, 0x01];
    /// <summary>
    /// Postal Code
    /// </summary>
    /// <remarks>
    /// The ZIP or other postal code of the address.
    /// </remarks>
    private static readonly byte[] PostalCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x07, 0x00];
    /// <summary>
    /// Postal Town
    /// </summary>
    /// <remarks>
    /// The postal town name
    /// </remarks>
    private static readonly byte[] PostalTown = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x04, 0x01];
    /// <summary>
    /// Postal Town
    /// </summary>
    /// <remarks>
    /// The postal town name
    /// </remarks>
    private static readonly byte[] PostalTown_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x04, 0x00];
    /// <summary>
    /// Postbox Number
    /// </summary>
    /// <remarks>
    /// Indicates the number of the postbox
    /// </remarks>
    private static readonly byte[] PostboxNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x0B, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Post Code for Postbox
    /// </summary>
    /// <remarks>
    /// Indicates the postal code of the postbox
    /// </remarks>
    private static readonly byte[] PostCodeForPostbox = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x0B, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Post-Matrix Tone Mapping 1
    /// </summary>
    /// <remarks>
    /// Sampled function for first post matrix color component, in units of 1/16 383
    /// </remarks>
    private static readonly byte[] PostMatrixToneMapping1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x2D, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Post-Matrix Tone Mapping 2
    /// </summary>
    /// <remarks>
    /// Sampled function for second post matrix color component, in units of 1/16 383
    /// </remarks>
    private static readonly byte[] PostMatrixToneMapping2 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x2E, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Post-Matrix Tone Mapping 3
    /// </summary>
    /// <remarks>
    /// Sampled function for third post matrix color component, in units of 1/16 383
    /// </remarks>
    private static readonly byte[] PostMatrixToneMapping3 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x2F, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// PosX
    /// </summary>
    /// <remarks>
    /// The coordinates along an horizontal axis
    /// </remarks>
    private static readonly byte[] posX = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x16, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// PosY
    /// </summary>
    /// <remarks>
    /// The coordinates along an vertical axis
    /// </remarks>
    private static readonly byte[] posY = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x16, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Preceding Index Table
    /// </summary>
    /// <remarks>
    /// Specifies whether a Complete Index Table is in a partition preceding all Essence that it indexes.
    /// </remarks>
    private static readonly byte[] PrecedingIndexTable = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x04, 0x05, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Precision
    /// </summary>
    /// <remarks>
    /// Additional information on the accuracy of the date provided
    /// </remarks>
    private static readonly byte[] precision = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0C, 0x0F, 0x00, 0x00, 0x00];
    /// <summary>
    /// Preferred Prefix
    /// </summary>
    /// <remarks>
    /// Preferred namespace tag when SMPTE ST 2001-1 Reg-XML encoding is used
    /// </remarks>
    private static readonly byte[] PreferredPrefix = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x06, 0x01, 0x01, 0x07, 0x1D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Pre-Matrix Tone Mapping 1
    /// </summary>
    /// <remarks>
    /// Sampled function for first input color component, in units of 1/16 383
    /// </remarks>
    private static readonly byte[] PreMatrixToneMapping1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x29, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Pre-Matrix Tone Mapping 2
    /// </summary>
    /// <remarks>
    /// Sampled function for second input color component, in units of 1/16 383
    /// </remarks>
    private static readonly byte[] PreMatrixToneMapping2 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x2A, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Pre-Matrix Tone Mapping 3
    /// </summary>
    /// <remarks>
    /// Sampled function for third input color component, in units of 1/16 383
    /// </remarks>
    private static readonly byte[] PreMatrixToneMapping3 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x2B, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Presentation Gamma Equation
    /// </summary>
    /// <remarks>
    /// Specifies the non-linear relationship between the input video signal levels and the resulting displayed light levels on the display.
    /// </remarks>
    private static readonly byte[] PresentationGammaEquation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x01, 0x02, 0x01, 0x01, 0x10, 0x01, 0x00];
    /// <summary>
    /// Presentation Gamma Equation
    /// </summary>
    /// <remarks>
    /// Specifies the non-linear relationship between the input video signal levels and the resulting displayed light levels on the display.
    /// </remarks>
    private static readonly byte[] PresentationGammaEquation_GammaCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x01, 0x02, 0x01, 0x01, 0x10, 0x00, 0x00];
    /// <summary>
    /// Presenter Name
    /// </summary>
    /// <remarks>
    /// Contains the name of the presenter of the program
    /// </remarks>
    private static readonly byte[] PresenterName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x0A, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Previous Number in Sequence
    /// </summary>
    /// <remarks>
    /// The previous number in a sequence
    /// </remarks>
    private static readonly byte[] PreviousNumberInSequence = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x10, 0x10, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Previous Partition
    /// </summary>
    /// <remarks>
    /// The number of the previous Partition in the sequence of Partitions (as a byte offset relative to the start of the Header Partition)
    /// </remarks>
    private static readonly byte[] PreviousPartition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x10, 0x10, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Previous Repeat Number
    /// </summary>
    /// <remarks>
    /// The number of the previous repeat
    /// </remarks>
    private static readonly byte[] PreviousRepeatNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x20, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Primary Extended Spoken Language Code
    /// </summary>
    /// <remarks>
    /// ISO 639 Language Code for the original secondary spoken language
    /// </remarks>
    private static readonly byte[] PrimaryExtendedSpokenLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x01, 0x02, 0x03, 0x11, 0x00, 0x00];
    /// <summary>
    /// Primary Original Language Code
    /// </summary>
    /// <remarks>
    /// ISO 639 Language Code for the original primary spoken language
    /// </remarks>
    private static readonly byte[] PrimaryOriginalLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x03, 0x01, 0x01, 0x02, 0x03, 0x03, 0x00, 0x00];
    /// <summary>
    /// Primary Package
    /// </summary>
    /// <remarks>
    /// Specifies a reference to the primary package in this file
    /// </remarks>
    private static readonly byte[] PrimaryPackage = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x01, 0x01, 0x04, 0x01, 0x08, 0x00, 0x00];
    /// <summary>
    /// Primary Spoken Language Code
    /// </summary>
    /// <remarks>
    /// ISO 639 Language Code for the current primary spoken language
    /// </remarks>
    private static readonly byte[] PrimarySpokenLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x03, 0x01, 0x01, 0x02, 0x03, 0x01, 0x00, 0x00];
    /// <summary>
    /// Pro-MPEG Forum
    /// </summary>
    /// <remarks>
    /// Metadata registered by the Pro-MPEG Forum for public use
    /// </remarks>
    private static readonly byte[] Pro_MPEGForum = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x0D, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// PROCESS
    /// </summary>
    /// <remarks>
    /// Class 5 is reserved for information about the essence or metadata processing
    /// </remarks>
    private static readonly byte[] PROCESS = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Process Date-Time
    /// </summary>
    /// <remarks>
    /// Date and Time information relating to Process
    /// </remarks>
    private static readonly byte[] ProcessDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x10, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Process Fundamentals
    /// </summary>
    /// <remarks>
    /// Information about process fundementals
    /// </remarks>
    private static readonly byte[] ProcessFundamentals = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Processing History
    /// </summary>
    /// <remarks>
    /// Audit history of compression for payload.
    /// </remarks>
    private static readonly byte[] ProcessingHistory = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Processing Set
    /// </summary>
    /// <remarks>
    /// A strong reference to the Processing set
    /// </remarks>
    private static readonly byte[] ProcessingObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x02, 0x40, 0x20, 0x00];
    /// <summary>
    /// Processing Restriction Flag
    /// </summary>
    /// <remarks>
    /// A flag to indicate resrictions on rights processing
    /// </remarks>
    private static readonly byte[] processingRestrictionFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x19, 0x0E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Producer Name
    /// </summary>
    /// <remarks>
    /// Contains the name of the producer of the program
    /// </remarks>
    private static readonly byte[] ProducerName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x0A, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Product
    /// </summary>
    /// <remarks>
    /// Abstract information about the media product
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] Product_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Product
    /// </summary>
    /// <remarks>
    /// The product that is the extension of the brand
    /// Namespace: http://www.smpte-ra.org/reg/335/2012/13/13
    /// </remarks>
    private static readonly byte[] Product_13 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x0D, 0x0D, 0x01, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Product Format
    /// </summary>
    /// <remarks>
    /// Identifies the name of the image file format
    /// </remarks>
    private static readonly byte[] ProductFormat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x04, 0x06, 0x02, 0x03, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Product Format
    /// </summary>
    /// <remarks>
    /// Identifies the name of the image file format
    /// </remarks>
    private static readonly byte[] ProductFormat_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x04, 0x06, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Production
    /// </summary>
    /// <remarks>
    /// Details of Performing talent, Non performing talent, Production Staff, Technical staff, Specialist etc
    /// </remarks>
    private static readonly byte[] Production = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Production Framework
    /// </summary>
    /// <remarks>
    /// Information about the production framework
    /// </remarks>
    private static readonly byte[] ProductionFramework = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Production Key People
    /// </summary>
    /// <remarks>
    /// Information about the people involved in the production
    /// </remarks>
    private static readonly byte[] ProductionKeyPeople = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Production Organization or Public Body
    /// </summary>
    /// <remarks>
    /// Details of performing contribution, non-performing contribution, production contribution, technical contribution, specialism etc
    /// </remarks>
    private static readonly byte[] ProductionOrganizationOrPublicBody = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Production Organization Role
    /// </summary>
    /// <remarks>
    /// Role of contributing organization (e.g., film library)
    /// </remarks>
    private static readonly byte[] ProductionOrganizationRole = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x30, 0x02, 0x02, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Production Organization Role
    /// </summary>
    /// <remarks>
    /// Role of contributing organization (e.g., film library)
    /// </remarks>
    private static readonly byte[] ProductionOrganizationRole_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Production Script Reference
    /// </summary>
    /// <remarks>
    /// A descriptive reference to the production script used in making the production
    /// </remarks>
    private static readonly byte[] ProductionScriptReference = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x06, 0x03, 0x05, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Production Script Reference
    /// </summary>
    /// <remarks>
    /// A descriptive reference to the production script used in making the production
    /// </remarks>
    private static readonly byte[] ProductionScriptReference_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x06, 0x03, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Production Setting Period Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Setting Period sets
    /// </remarks>
    private static readonly byte[] ProductionSettingPeriodObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x0E, 0x01];
    /// <summary>
    /// Profile And Level
    /// </summary>
    /// <remarks>
    /// Specifies the MPEG-2 video profile and level. The value is taken directly from the profile_and_level_indication in the MPEG-2 sequence header extension. For main profile @ main level, the value is 0x48. For 4:2:2 profile @ main level, the value is 0x85
    /// </remarks>
    private static readonly byte[] ProfileAndLevel = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x01, 0x06, 0x02, 0x01, 0x0A, 0x00, 0x00];
    /// <summary>
    /// Program Award Name
    /// </summary>
    /// <remarks>
    /// Awards granted to program
    /// </remarks>
    private static readonly byte[] ProgramAwardName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x02, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Program Commercial Material Reference
    /// </summary>
    /// <remarks>
    /// eg. Mugs, T-shirts, recordings
    /// </remarks>
    private static readonly byte[] ProgramCommercialMaterialReference_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x06, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Program Identifiers
    /// </summary>
    /// <remarks>
    /// Globally unique program identifiers
    /// </remarks>
    private static readonly byte[] ProgramIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x10, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Program Kind
    /// </summary>
    /// <remarks>
    /// Type of program (e.g., cartoon, film, ...)
    /// </remarks>
    private static readonly byte[] ProgramKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x01, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Program Material Classification Code
    /// </summary>
    /// <remarks>
    /// The resulting delineated classification code from the classification system
    /// </remarks>
    private static readonly byte[] ProgramMaterialClassificationCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x01, 0x01, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// Programming Group Kind
    /// </summary>
    /// <remarks>
    /// The kind of program group of which the program forms a part - e.g. Anthology, Serial, Series, Themed Cluster, Repeating Series etc.
    /// </remarks>
    private static readonly byte[] ProgrammingGroupKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x02, 0x02, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Programming Group Kind
    /// </summary>
    /// <remarks>
    /// The kind of program group of which the program forms a part - e.g. Anthology, Serial, Series, Themed Cluster, Repeating Series etc.
    /// </remarks>
    private static readonly byte[] ProgrammingGroupKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Programming Group Title
    /// </summary>
    /// <remarks>
    /// The title of a programming group
    /// </remarks>
    private static readonly byte[] ProgrammingGroupTitle = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x02, 0x02, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Programming Group Title
    /// </summary>
    /// <remarks>
    /// The title of a programming group
    /// </remarks>
    private static readonly byte[] ProgrammingGroupTitle_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x02, 0x02, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Program Number
    /// </summary>
    /// <remarks>
    /// Identifier for a program project
    /// </remarks>
    private static readonly byte[] ProgramNumber_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x10, 0x03, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Program Support Material Reference
    /// </summary>
    /// <remarks>
    /// eg printed educational material
    /// </remarks>
    private static readonly byte[] ProgramSupportMaterialReference_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x06, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Project Name
    /// </summary>
    /// <remarks>
    /// Name for a particular project or mission
    /// </remarks>
    private static readonly byte[] ProjectName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x03, 0x01, 0x08, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Project Name
    /// </summary>
    /// <remarks>
    /// Name for a particular project or mission
    /// </remarks>
    private static readonly byte[] ProjectName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x03, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Project Number
    /// </summary>
    /// <remarks>
    /// Identifier for a particular project or mission
    /// </remarks>
    private static readonly byte[] ProjectNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x03, 0x01, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Project Set
    /// </summary>
    /// <remarks>
    /// A strong reference to the Project set
    /// </remarks>
    private static readonly byte[] ProjectObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x02, 0x40, 0x21, 0x00];
    /// <summary>
    /// Properties
    /// </summary>
    /// <remarks>
    /// Specifies an unordered set of references to properties that are defined by the class
    /// </remarks>
    private static readonly byte[] Properties = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x07, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Property Defaults
    /// </summary>
    /// <remarks>
    /// Information about property defaults
    /// </remarks>
    private static readonly byte[] PropertyDefaults = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x02, 0x02, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Property Definitions
    /// </summary>
    /// <remarks>
    /// Information for the definition of data properties.
    /// </remarks>
    private static readonly byte[] PropertyDefinitions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Property Type
    /// </summary>
    /// <remarks>
    /// Specifies the data type defined for the key
    /// </remarks>
    private static readonly byte[] PropertyType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x07, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Protocols
    /// </summary>
    /// <remarks>
    /// Elements defined as part of a protocol
    /// </remarks>
    private static readonly byte[] Protocols = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Protocol Version
    /// </summary>
    /// <remarks>
    /// Protocol version used by the client/server
    /// </remarks>
    private static readonly byte[] ProtocolVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x1F, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Proxy Locators
    /// </summary>
    /// <remarks>
    /// Local archival location information for key frames, keys sounds, key text etc
    /// </remarks>
    private static readonly byte[] ProxyLocators = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// PTP Timestamp Time
    /// </summary>
    /// <remarks>
    /// The current time expressed as a PTP Timestamp.
    /// </remarks>
    private static readonly byte[] PTPTimestampTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x07, 0x02, 0x01, 0x01, 0x01, 0x09, 0x00, 0x00];
    /// <summary>
    /// Publication
    /// </summary>
    /// <remarks>
    /// Publishing details
    /// </remarks>
    private static readonly byte[] Publication = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x10, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Channel
    /// </summary>
    /// <remarks>
    /// A set of attributes to define a channel on which a resource is published
    /// </remarks>
    private static readonly byte[] publicationChannel = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1E, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Channel Identifier
    /// </summary>
    /// <remarks>
    /// An identifier attributed to the publication channel
    /// </remarks>
    private static readonly byte[] publicationChannelId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1E, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Channel Link To Logo
    /// </summary>
    /// <remarks>
    /// A pointer to the location of a visual identifier of the publication channel
    /// </remarks>
    private static readonly byte[] publicationChannelLinkToLogo = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1E, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Channel Name
    /// </summary>
    /// <remarks>
    /// The name of the publication channel
    /// </remarks>
    private static readonly byte[] publicationChannelName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1E, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Channel Set
    /// </summary>
    /// <remarks>
    /// A strong reference to the definition of a channel of publication
    /// </remarks>
    private static readonly byte[] publicationChannelObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1C, 0x0F, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Channel Type Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group to define the type of channel being used
    /// </remarks>
    private static readonly byte[] publicationChannelTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1E, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Date
    /// </summary>
    /// <remarks>
    /// The date of publication
    /// </remarks>
    private static readonly byte[] publicationDate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1C, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Event
    /// </summary>
    /// <remarks>
    /// A description of a publication event
    /// </remarks>
    private static readonly byte[] publicationEvent = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1C, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Event Identifier
    /// </summary>
    /// <remarks>
    /// An identifier attributed to the publication event
    /// </remarks>
    private static readonly byte[] publicationEventId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1C, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Event Name
    /// </summary>
    /// <remarks>
    /// The name of the publication event
    /// </remarks>
    private static readonly byte[] publicationEventName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1C, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Event Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to publication events
    /// </remarks>
    private static readonly byte[] publicationEventObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1D, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Format  Reference Set
    /// </summary>
    /// <remarks>
    /// A reference to the format in which content was published
    /// </remarks>
    private static readonly byte[] publicationFormatReferenceObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1C, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication History
    /// </summary>
    /// <remarks>
    /// A summary of where and when the resource was published
    /// </remarks>
    private static readonly byte[] publicationHistory = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1D, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication History Id
    /// </summary>
    /// <remarks>
    /// An identifier associated with a set of publication history information
    /// </remarks>
    private static readonly byte[] publicationHistoryId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1D, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication History Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a set of publication history information (published where, when, how)
    /// </remarks>
    private static readonly byte[] publicationHistoryObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x02, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Medium
    /// </summary>
    /// <remarks>
    /// A set of attributes to define the medium on which a resource is published
    /// </remarks>
    private static readonly byte[] publicationMedium = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1F, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Medium Identifier
    /// </summary>
    /// <remarks>
    /// An identifier attributed to the publication medium
    /// </remarks>
    private static readonly byte[] publicationMediumId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1F, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Channel Name
    /// </summary>
    /// <remarks>
    /// The name of the publication medium
    /// </remarks>
    private static readonly byte[] publicationMediumName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1F, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Medium Set
    /// </summary>
    /// <remarks>
    /// A strong reference to the definition of a medium of publication
    /// </remarks>
    private static readonly byte[] publicationMediumObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1C, 0x0E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Medium Type Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group to define the type of medium
    /// </remarks>
    private static readonly byte[] publicationMediumTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1F, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Note
    /// </summary>
    /// <remarks>
    /// A note to provide additional contextual information
    /// </remarks>
    private static readonly byte[] publicationNote = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1C, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Publication sets
    /// </remarks>
    private static readonly byte[] PublicationObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x0A, 0x00];
    /// <summary>
    /// Publication Outlet
    /// </summary>
    /// <remarks>
    /// The content publication outlet - eg Broadcast, internet etc
    /// </remarks>
    private static readonly byte[] PublicationOutlet = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Region Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to regions where the publication event has taken place
    /// </remarks>
    private static readonly byte[] publicationRegionObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1C, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Rights Reference Sets
    /// </summary>
    /// <remarks>
    /// A batch of references to the rights associated with the publication event
    /// </remarks>
    private static readonly byte[] publicationRightsReferenceObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1C, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Service
    /// </summary>
    /// <remarks>
    /// A set of attributes to define the service on which a resource is published
    /// </remarks>
    private static readonly byte[] publicationService = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x20, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Service Id
    /// </summary>
    /// <remarks>
    /// An identifier attributed to the publication service
    /// </remarks>
    private static readonly byte[] publicationServiceId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x20, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Service Link To Logo
    /// </summary>
    /// <remarks>
    /// A pointer to the location of a visual identifier of the publication service
    /// </remarks>
    private static readonly byte[] publicationServiceLinkToLogo = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x20, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Service Name
    /// </summary>
    /// <remarks>
    /// The name of the publication service
    /// </remarks>
    private static readonly byte[] publicationServiceName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x20, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Service Set
    /// </summary>
    /// <remarks>
    /// A strong reference to the definition of a service of publication
    /// </remarks>
    private static readonly byte[] publicationServiceObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1C, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Service Source Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an organization managing the service
    /// </remarks>
    private static readonly byte[] publicationServiceSourceObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x20, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Service Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group to define the type of service
    /// </remarks>
    private static readonly byte[] publicationServiceTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x20, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publication Time
    /// </summary>
    /// <remarks>
    /// The time of publication
    /// </remarks>
    private static readonly byte[] publicationTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1C, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publisher
    /// </summary>
    /// <remarks>
    /// A publisher of the resource
    /// </remarks>
    private static readonly byte[] publisher = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0A, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publisher Entity Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to one or more publishers
    /// </remarks>
    private static readonly byte[] publisherEntityObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x02, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publishing Medium Name
    /// </summary>
    /// <remarks>
    /// Publishing medium (e.g., magazine, newspaper, Web)
    /// </remarks>
    private static readonly byte[] PublishingMediumName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x10, 0x02, 0x01, 0x03, 0x01, 0x00, 0x00];
    /// <summary>
    /// Publishing Medium Name
    /// </summary>
    /// <remarks>
    /// Publishing medium (e.g., magazine, newspaper, Web)
    /// </remarks>
    private static readonly byte[] PublishingMediumName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x10, 0x02, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publishing Organization Name
    /// </summary>
    /// <remarks>
    /// Name of the publishing organization
    /// </remarks>
    private static readonly byte[] PublishingOrganizationName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x10, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Publishing Organization Name
    /// </summary>
    /// <remarks>
    /// Name of the publishing organization
    /// </remarks>
    private static readonly byte[] PublishingOrganizationName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x10, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publishing Region Name
    /// </summary>
    /// <remarks>
    /// Target region of publication
    /// </remarks>
    private static readonly byte[] PublishingRegionName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x10, 0x02, 0x01, 0x04, 0x01, 0x00, 0x00];
    /// <summary>
    /// Publishing Region Name
    /// </summary>
    /// <remarks>
    /// Target region of publication
    /// </remarks>
    private static readonly byte[] PublishingRegionName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x10, 0x02, 0x01, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Publishing Service Name
    /// </summary>
    /// <remarks>
    /// The publication Service
    /// </remarks>
    private static readonly byte[] PublishingServiceName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x10, 0x02, 0x01, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Publishing Service Name
    /// </summary>
    /// <remarks>
    /// The publication Service
    /// </remarks>
    private static readonly byte[] PublishingServiceName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x10, 0x02, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Film-to-Video Transfer Direction
    /// </summary>
    /// <remarks>
    /// Specifies the history of the direction of transfer
    /// </remarks>
    private static readonly byte[] PulldownDirection = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x40, 0x10, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Pulldown Field Dominance
    /// </summary>
    /// <remarks>
    /// Field one dominant (True)
    /// </remarks>
    private static readonly byte[] PulldownFieldDominance = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x08, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Film-to-Video Transfer Kind
    /// </summary>
    /// <remarks>
    /// Specifies the history of the kind of pulldown (3 2 525-line, 625-line, etc.)
    /// </remarks>
    private static readonly byte[] PulldownKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x40, 0x10, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Pulldown Sequence
    /// </summary>
    /// <remarks>
    /// eg. 3:2,  1:1 at 25Hz, 1:1 at 59.94Hz, 24Hz/25Hz, Videotap, etc
    /// </remarks>
    private static readonly byte[] PulldownSequence = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x08, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Purchaser
    /// </summary>
    /// <remarks>
    /// Details of the content purchasing organization
    /// </remarks>
    private static readonly byte[] Purchaser = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Purchaser Account Name
    /// </summary>
    /// <remarks>
    /// The name of the purchaser account
    /// </remarks>
    private static readonly byte[] PurchaserAccountName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x03, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Purchaser Account Name
    /// </summary>
    /// <remarks>
    /// The name of the purchaser account
    /// </remarks>
    private static readonly byte[] PurchaserAccountName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x03, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Purchaser Account Number
    /// </summary>
    /// <remarks>
    /// The number of the purchaser account
    /// </remarks>
    private static readonly byte[] PurchaserAccountNumber_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x03, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Purchaser Identification Kind
    /// </summary>
    /// <remarks>
    /// The purchaser identification type (e.g. bank Sort code)
    /// </remarks>
    private static readonly byte[] PurchaserIdentificationKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x03, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Purchaser Identification Value
    /// </summary>
    /// <remarks>
    /// The value of purchaser identification
    /// </remarks>
    private static readonly byte[] PurchaserIdentificationValue_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x03, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Purchasing Department
    /// </summary>
    /// <remarks>
    /// The name of the purchasing department
    /// </remarks>
    private static readonly byte[] PurchasingDepartment_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Purchasing Organization Name
    /// </summary>
    /// <remarks>
    /// The name of the content purchasing organization
    /// </remarks>
    private static readonly byte[] PurchasingOrganizationName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// PURL
    /// </summary>
    /// <remarks>
    /// Persistent Universal Resource Locator
    /// </remarks>
    private static readonly byte[] PURL_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Purpose
    /// </summary>
    /// <remarks>
    /// A summary of the intentions with which the data set was developed.
    /// </remarks>
    private static readonly byte[] Purpose = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x01, 0x06, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Purpose
    /// </summary>
    /// <remarks>
    /// A summary of the intentions with which the data set was developed.
    /// </remarks>
    private static readonly byte[] Purpose_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x01, 0x06, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Qlty Basic Data
    /// </summary>
    /// <remarks>
    /// Basic Capture Data from the BWF &lt;qlty&gt; chunk
    /// </remarks>
    private static readonly byte[] QltyBasicData = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x05, 0x02, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Qlty Cue Sheet
    /// </summary>
    /// <remarks>
    /// String of cue points, timestamps and descriptions from the BWF &lt;qlty&gt; chunk
    /// </remarks>
    private static readonly byte[] QltyCueSheet = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x05, 0x02, 0x08, 0x01, 0x00, 0x00];
    /// <summary>
    /// Qlty End Of Modulation
    /// </summary>
    /// <remarks>
    /// End of modulation time of the original recording, in hours, minutes, seconds and tenths of a second
    /// </remarks>
    private static readonly byte[] QltyEndOfModulation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x05, 0x02, 0x05, 0x01, 0x00, 0x00];
    /// <summary>
    /// File Security Report
    /// </summary>
    /// <remarks>
    /// File Security Code (checksum) of the BWF quality report
    /// </remarks>
    private static readonly byte[] QltyFileSecurityReport = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x03, 0x02, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// File Security Wave
    /// </summary>
    /// <remarks>
    /// File Security Code (checksum) of the BWF wave data
    /// </remarks>
    private static readonly byte[] QltyFileSecurityWave = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x03, 0x02, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Qlty Operator Comment
    /// </summary>
    /// <remarks>
    /// String of Operator comments concerning the capturing of the sound signal, from the BWF &lt;qlty&gt; chunk
    /// </remarks>
    private static readonly byte[] QltyOperatorComment = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x05, 0x02, 0x07, 0x01, 0x00, 0x00];
    /// <summary>
    /// Qlty Quality Event
    /// </summary>
    /// <remarks>
    /// Information from the BWF &lt;qlty&gt; chunk describing each Quality event in the sound signal.  One string is used for each event.
    /// </remarks>
    private static readonly byte[] QltyQualityEvent = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x05, 0x02, 0x04, 0x01, 0x00, 0x00];
    /// <summary>
    /// Qlty Quality Parameter
    /// </summary>
    /// <remarks>
    /// String of Quality Parameters affecting the sound signal, from the BWF &lt;qlty&gt; chunk
    /// </remarks>
    private static readonly byte[] QltyQualityParameter = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x05, 0x02, 0x06, 0x01, 0x00, 0x00];
    /// <summary>
    /// Qlty Start Of Modulation
    /// </summary>
    /// <remarks>
    /// Start of modulation of the original recording, in hours, minutes, seconds and tenths of a second
    /// </remarks>
    private static readonly byte[] QltyStartOfModulation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x05, 0x02, 0x03, 0x01, 0x00, 0x00];
    /// <summary>
    /// Qualitative Values
    /// </summary>
    /// <remarks>
    /// Assessed values relating to editorial, technical etc aspects of the content and contributors to it
    /// </remarks>
    private static readonly byte[] QualitativeValues = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Qlty Quality Event
    /// </summary>
    /// <remarks>
    /// Information from the BWF &lt;qlty&gt; chunk describing each Quality event in the sound signal.  One string is used for each event.
    /// </remarks>
    private static readonly byte[] QualityEvent = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x05, 0x02, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Quality Flag
    /// </summary>
    /// <remarks>
    /// Quality of a specific recording/physical copy (good/no good)
    /// </remarks>
    private static readonly byte[] QualityFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Qlty Quality Parameter
    /// </summary>
    /// <remarks>
    /// String of Quality Parameters affecting the sound signal, from the BWF &lt;qlty&gt; chunk
    /// </remarks>
    private static readonly byte[] QualityParameter = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x05, 0x02, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Quantel Ltd
    /// </summary>
    /// <remarks>
    /// Metadata registered by Quantel Ltd for private use
    /// </remarks>
    private static readonly byte[] QuantelLtd = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x0E, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Bits Per Audio Sample
    /// </summary>
    /// <remarks>
    /// The maximum number of significant bits for the value without compression.
    /// </remarks>
    private static readonly byte[] QuantizationBits = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x04, 0x02, 0x03, 0x03, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Quantization Default
    /// </summary>
    /// <remarks>
    /// Default quantization style for all components. Use this value only if static for all pictures in the Essence Container.The data format is as defined in ISO/IEC 15444-1, Annex A.6.4 and comprises the sequence of Sqcd (1 byte per table A.27) followed by one or more Sqcdi bytes (for the ith sub-band in the defined order per table A.27).
    /// </remarks>
    private static readonly byte[] QuantizationDefault = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x06, 0x03, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rate and Direction of Positional Change
    /// </summary>
    /// <remarks>
    /// Information about rate and direction of positional change
    /// </remarks>
    private static readonly byte[] RateAndDirectionOfPositionalChange = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rating
    /// </summary>
    /// <remarks>
    /// A set of attributes to define the rating attributed to the resource
    /// </remarks>
    private static readonly byte[] rating = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1B, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rating Adult Content Flag
    /// </summary>
    /// <remarks>
    /// A flag to signal if this is adult content ("1" for true) or not
    /// </remarks>
    private static readonly byte[] ratingAdultContentFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1B, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rating Environment
    /// </summary>
    /// <remarks>
    /// To provide information on the rating environment, as free text
    /// </remarks>
    private static readonly byte[] ratingEnvironment = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1B, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rating Exclusion Region Sets
    /// </summary>
    /// <remarks>
    /// To specify regions where rating doesn't apply.
    /// </remarks>
    private static readonly byte[] ratingExclusionRegionObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1B, 0x0F, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rating Format  Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute format group to define the format in which rating is provided
    /// </remarks>
    private static readonly byte[] ratingFormatGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1B, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rating Link
    /// </summary>
    /// <remarks>
    /// A link to point e.g. to a web resource providing information on the rating
    /// </remarks>
    private static readonly byte[] ratingLink = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1B, 0x0E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rating Link To Logo
    /// </summary>
    /// <remarks>
    /// A locator to a visual representation of the rating
    /// </remarks>
    private static readonly byte[] ratingLinkToLogo = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1B, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rating Not Rated Flag
    /// </summary>
    /// <remarks>
    /// A flag to signal if the content has not been rated ("1" for true)
    /// </remarks>
    private static readonly byte[] ratingNotRatedFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1B, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rating Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to one or more ratings (user or audience rating)
    /// </remarks>
    private static readonly byte[] ratingObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x02, 0x0E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rating Provider Entity Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an entity object to identify the authority providing the rating
    /// </remarks>
    private static readonly byte[] ratingProviderEntityObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1B, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rating Reason
    /// </summary>
    /// <remarks>
    /// Free text to explain the reason for attributing the rating
    /// </remarks>
    private static readonly byte[] ratingReason = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1B, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rating Region Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a region object
    /// </remarks>
    private static readonly byte[] ratingRegionObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1B, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rating Region Sets
    /// </summary>
    /// <remarks>
    /// To specify regions where rating applies.
    /// </remarks>
    private static readonly byte[] ratingRegionObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1B, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// Ratings
    /// </summary>
    /// <remarks>
    /// Information about audience ratings and indices
    /// </remarks>
    private static readonly byte[] Ratings = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x20, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rating Scale Max Value Sets
    /// </summary>
    /// <remarks>
    /// A numerical or textual value defining the maximum range of a scale optionally in different languages
    /// </remarks>
    private static readonly byte[] ratingScaleMaxValueObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1B, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rating Scale Min Value Sets
    /// </summary>
    /// <remarks>
    /// A numerical or textual value defining the minimum range of a scale optionally in different languages
    /// </remarks>
    private static readonly byte[] ratingScaleMinValueObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1B, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rating System
    /// </summary>
    /// <remarks>
    /// To provide information on the rating system in use, as free text
    /// </remarks>
    private static readonly byte[] ratingSystem = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1B, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rating Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group to define the type of rating being provided
    /// </remarks>
    private static readonly byte[] ratingTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1B, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rating Value Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to a textual or numerical value given for rating optionally in different languages
    /// </remarks>
    private static readonly byte[] ratingValueObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1B, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rational
    /// </summary>
    /// <remarks>
    /// A set of attributes used to define a rational
    /// </remarks>
    private static readonly byte[] rational = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3F, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Recorded Format
    /// </summary>
    /// <remarks>
    /// Specifies the recording format as laid down on the media;  e.g.  D5, Betacam etc
    /// </remarks>
    private static readonly byte[] RecordedFormat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x09, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Recorded Format
    /// </summary>
    /// <remarks>
    /// Specifies the recording format as laid down on the media;  e.g.  D5, Betacam etc
    /// </remarks>
    private static readonly byte[] RecordedFormat_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x09, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Recorded Track Number
    /// </summary>
    /// <remarks>
    /// The track or band number of a recording.
    /// </remarks>
    private static readonly byte[] RecordedTrackNumber_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x10, 0x03, 0x07, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Recording Label Name
    /// </summary>
    /// <remarks>
    /// Name of a publication label - e.g. United Artists, Topic
    /// </remarks>
    private static readonly byte[] RecordingLabelName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x10, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Recording Label Name
    /// </summary>
    /// <remarks>
    /// Name of a publication label - e.g. United Artists, Topic
    /// </remarks>
    private static readonly byte[] RecordingLabelName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x10, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// RED
    /// </summary>
    /// <remarks>
    /// Metadata registered by RED Digital Cinema, LLC. for private use
    /// </remarks>
    private static readonly byte[] RED = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x0E, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Reel or Roll Number
    /// </summary>
    /// <remarks>
    /// An organizationally given number for a film reel or roll.
    /// </remarks>
    private static readonly byte[] ReelOrRollNumber_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Reference Audio Alignment Level
    /// </summary>
    /// <remarks>
    /// Reference alignment level of the audio expressed in dBFS. For example, -20dBFS.
    /// </remarks>
    private static readonly byte[] ReferenceAudioAlignmentLevel = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x02, 0x01, 0x01, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Target Class of Strong Reference
    /// </summary>
    /// <remarks>
    /// Specifies a reference to the target class of a Strong Reference type
    /// </remarks>
    private static readonly byte[] ReferencedType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x07, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Reference Image Edit Rate
    /// </summary>
    /// <remarks>
    /// Edit rate of the image essence with which the audio is intended to sync. For example, 24/1.001 fps, 24 fps, 25 fps
    /// </remarks>
    private static readonly byte[] ReferenceImageEditRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x02, 0x01, 0x01, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// References
    /// </summary>
    /// <remarks>
    /// A resource referenced by the current resource
    /// </remarks>
    private static readonly byte[] references = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x02, 0x0A, 0x00, 0x00];
    /// <summary>
    /// Reference Screen
    /// </summary>
    /// <remarks>
    /// Specification of a reference/production/monitoring screen size for the audioProgramme. If the reference screen-size is not given, a default screen-size is implicitly defined.
    /// </remarks>
    private static readonly byte[] referenceScreen = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x60, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Reference Screen Aspect Ratio
    /// </summary>
    /// <remarks>
    /// To specify the aspect ration of the reference screen.
    /// </remarks>
    private static readonly byte[] referenceScreenAspectRatio = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x60, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Reference Screen Azimuth
    /// </summary>
    /// <remarks>
    /// To provide the azimuth.
    /// </remarks>
    private static readonly byte[] referenceScreenAzimuth = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x61, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Reference Screen Centre Position
    /// </summary>
    /// <remarks>
    /// To define the centre position of a reference screen.
    /// </remarks>
    private static readonly byte[] referenceScreenCentrePosition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x61, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Reference Screen Reference Centre Set
    /// </summary>
    /// <remarks>
    /// To define the position of the centre reference screen.
    /// </remarks>
    private static readonly byte[] referenceScreenCentrePositionObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x60, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Reference Screen Centre Position Value
    /// </summary>
    /// <remarks>
    /// To provide the centre coordinates as a single value.
    /// </remarks>
    private static readonly byte[] referenceScreenCentrePositionValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x61, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Reference Screen Distance
    /// </summary>
    /// <remarks>
    /// To provide the distance.
    /// </remarks>
    private static readonly byte[] referenceScreenDistance = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x61, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Reference Screen Elevation
    /// </summary>
    /// <remarks>
    /// To provide the elevation.
    /// </remarks>
    private static readonly byte[] referenceScreenElevation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x61, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Reference Screen Width
    /// </summary>
    /// <remarks>
    /// To define the width of a screen.
    /// </remarks>
    private static readonly byte[] referenceScreenWidth = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x62, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Reference Screen Width Azimuth
    /// </summary>
    /// <remarks>
    /// To provide the width as an azimuth.
    /// </remarks>
    private static readonly byte[] referenceScreenWidthAzimuth = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x62, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Reference Screen Wiidth Set
    /// </summary>
    /// <remarks>
    /// To define the width of the reference screen.
    /// </remarks>
    private static readonly byte[] referenceScreenWidthObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x60, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Reference Screen Width Value
    /// </summary>
    /// <remarks>
    /// To provide the width as a single value.
    /// </remarks>
    private static readonly byte[] referenceScreenWidthValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x62, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Reference Screen Width X
    /// </summary>
    /// <remarks>
    /// To define the width as an X axis coordinate.
    /// </remarks>
    private static readonly byte[] referenceScreenWidthX = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x62, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Reference Screen X
    /// </summary>
    /// <remarks>
    /// To provide the X axis coordinate.
    /// </remarks>
    private static readonly byte[] referenceScreenX = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x61, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Reference Screen Y
    /// </summary>
    /// <remarks>
    /// To provide the Y axis coordinate.
    /// </remarks>
    private static readonly byte[] referenceScreenY = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x61, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Reference Screen Z
    /// </summary>
    /// <remarks>
    /// To provide the Z axis coordinate.
    /// </remarks>
    private static readonly byte[] referenceScreenZ = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x61, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Region
    /// </summary>
    /// <remarks>
    /// A set of attributes to define a region as a country or a region / state or other geographical/administrative subdivision of a country
    /// </remarks>
    private static readonly byte[] region = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x27, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Intellectual Property License Region Name
    /// </summary>
    /// <remarks>
    /// The region of a country where IP rights are licensed
    /// </remarks>
    private static readonly byte[] RegionAreaOfIPLicense = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x03, 0x05, 0x01, 0x00];
    /// <summary>
    /// Region Code
    /// </summary>
    /// <remarks>
    /// The ISO code that represents a Region or Territory
    /// </remarks>
    private static readonly byte[] RegionCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x01, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Region Name
    /// </summary>
    /// <remarks>
    /// The ISO name for a Region or Territory
    /// </remarks>
    private static readonly byte[] RegionName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x01, 0x01, 0x10, 0x02, 0x01, 0x00];
    /// <summary>
    /// Region Name
    /// </summary>
    /// <remarks>
    /// The ISO name for a Region or Territory
    /// </remarks>
    private static readonly byte[] RegionName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x01, 0x01, 0x10, 0x02, 0x00, 0x00];
    /// <summary>
    /// Regions
    /// </summary>
    /// <remarks>
    /// Information about Regions within a country
    /// </remarks>
    private static readonly byte[] Regions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Register Action
    /// </summary>
    /// <remarks>
    /// The enumerated action which is underway for an entry.
    /// </remarks>
    private static readonly byte[] RegisterAction_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x02, 0x10, 0x02, 0x04, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Register Administration
    /// </summary>
    /// <remarks>
    /// Metadata relating to the administration of registers and register items.
    /// </remarks>
    private static readonly byte[] RegisterAdministration = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x02, 0x10, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Register Administration Array
    /// </summary>
    /// <remarks>
    /// Strong reference to one concrete class of Register Administration object base class.
    /// </remarks>
    private static readonly byte[] RegisterAdministrationArray = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x06, 0x01, 0x01, 0x04, 0x06, 0x12, 0x00, 0x00];
    /// <summary>
    /// Register Administration Notes
    /// </summary>
    /// <remarks>
    /// Provides additional information that may assist in the administration of an entry.
    /// </remarks>
    private static readonly byte[] RegisterAdministrationNotes_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x02, 0x10, 0x02, 0x04, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Register Administration Object
    /// </summary>
    /// <remarks>
    /// A strong reference to one concrete class of the Register Administration object base class.
    /// </remarks>
    private static readonly byte[] RegisterAdministrationObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x06, 0x01, 0x01, 0x04, 0x02, 0x11, 0x00, 0x00];
    /// <summary>
    /// Register Approver Name
    /// </summary>
    /// <remarks>
    /// Name of the person who authorizes an entry.
    /// </remarks>
    private static readonly byte[] RegisterApproverName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x02, 0x10, 0x02, 0x04, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Register Child Entry Array
    /// </summary>
    /// <remarks>
    /// Array of strong references to Entry objects. The sequence of entries shall be according to ascending order of their UL Item Designator values. For the ordering, the most significant byte shall be byte 9 of the Universal Label, the least significant byte shall be byte 16 of the Universal Label.
    /// </remarks>
    private static readonly byte[] RegisterChildEntryArray = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x06, 0x01, 0x01, 0x04, 0x06, 0x14, 0x00, 0x00];
    /// <summary>
    /// Register Creation Time
    /// </summary>
    /// <remarks>
    /// Date and time when the entry was created.
    /// </remarks>
    private static readonly byte[] RegisterCreationTime_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x02, 0x10, 0x02, 0x04, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Register Editor Name
    /// </summary>
    /// <remarks>
    /// The name of the person who administrates a register or entry.
    /// </remarks>
    private static readonly byte[] RegisterEditorName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x02, 0x10, 0x02, 0x02, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Register Entry Administration Object
    /// </summary>
    /// <remarks>
    /// A strong reference to one concrete subclass of the EntryAdministration base class object.
    /// </remarks>
    private static readonly byte[] RegisterEntryAdministrationObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x06, 0x01, 0x01, 0x04, 0x02, 0x12, 0x00, 0x00];
    /// <summary>
    /// Register Entry Array
    /// </summary>
    /// <remarks>
    /// Array of strong references to Entry objects. The sequence of entries shall be according to ascending order of their UL Item Designator values. For the ordering, the most significant byte shall be byte 9 of the Universal Label, the least significant byte shall be byte 16 of the Universal Label.
    /// </remarks>
    private static readonly byte[] RegisterEntryArray = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x06, 0x01, 0x01, 0x04, 0x06, 0x11, 0x00, 0x00];
    /// <summary>
    /// Register Entry Status
    /// </summary>
    /// <remarks>
    /// Indicates the status of the entry.
    /// </remarks>
    private static readonly byte[] RegisterEntryStatus_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x02, 0x10, 0x02, 0x03, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Register Item
    /// </summary>
    /// <remarks>
    /// Data elements that relate to specific items in the published SMPTE registers.
    /// </remarks>
    private static readonly byte[] RegisterItem = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x02, 0x10, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Register Item Defining Document Name
    /// </summary>
    /// <remarks>
    /// Indicates the SMPTE document which defines this entry .
    /// </remarks>
    private static readonly byte[] RegisterItemDefiningDocumentName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x02, 0x10, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Register Item Definition
    /// </summary>
    /// <remarks>
    /// The detailed and unambiguous definition of the data element (leaf) or class/subclass (node).
    /// </remarks>
    private static readonly byte[] RegisterItemDefinition_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x02, 0x10, 0x02, 0x03, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Register Item Hierarchy Level
    /// </summary>
    /// <remarks>
    /// This indicates the level of an entry in the class hierarchy of the SMPTE UL-based register. It is calculated from the position of the last active byte of the item designator.
    /// </remarks>
    private static readonly byte[] RegisterItemHierarchyLevel_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x02, 0x10, 0x02, 0x03, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Register Item Introduction Version
    /// </summary>
    /// <remarks>
    /// This field records the version number of the register which first recorded the allocation of a data element or class/subclass description against its UL.
    /// </remarks>
    private static readonly byte[] RegisterItemIntroductionVersion_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x02, 0x10, 0x02, 0x03, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Register Item Name
    /// </summary>
    /// <remarks>
    /// The name of the leaf or node in plain language.
    /// </remarks>
    private static readonly byte[] RegisterItemName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x02, 0x10, 0x02, 0x03, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Register Item Notes
    /// </summary>
    /// <remarks>
    /// Provides additional information that may assist in the interpretation and correct application of the data element (leaf) or class/subclass (node).
    /// </remarks>
    private static readonly byte[] RegisterItemNotes_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x02, 0x10, 0x02, 0x03, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Register Item Originator Name
    /// </summary>
    /// <remarks>
    /// Name of the party that originated the request for a new register item or a change to an existing item.
    /// </remarks>
    private static readonly byte[] RegisterItemOriginatorName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x02, 0x10, 0x02, 0x04, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Register Item Status Change Date-Time
    /// </summary>
    /// <remarks>
    /// The timestamp that indicates the last change of status of a register or entry.
    /// </remarks>
    private static readonly byte[] RegisterItemStatusChangeDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x07, 0x02, 0x01, 0x01, 0x01, 0x07, 0x00, 0x00];
    /// <summary>
    /// Register Item Symbol
    /// </summary>
    /// <remarks>
    /// The symbol is a name that conforms to computer language syntax restrictions, and it is intended for use in computer languages such as Extensible Markup Language (XML).
    /// </remarks>
    private static readonly byte[] RegisterItemSymbol_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x02, 0x10, 0x02, 0x03, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Register Item UL
    /// </summary>
    /// <remarks>
    /// The unique ID of this register entry assigned by SMPTE.
    /// </remarks>
    private static readonly byte[] RegisterItemUL_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x02, 0x10, 0x02, 0x03, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Register Kind
    /// </summary>
    /// <remarks>
    /// The type of the register. Example: Types, Data Elements, Labels, Groups, etc.
    /// </remarks>
    private static readonly byte[] RegisterKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x02, 0x10, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Register Node Wildcard Flag
    /// </summary>
    /// <remarks>
    /// Provides information that entries exist under this node which are using wildcards. These wildcard entries shall be expanded always when exchanging SMPTE registers. This wildcard flag in an annotation that the entries under this node were created according to a pattern. An omitted wildcard flag shall have the meaning of "0" (false).
    /// </remarks>
    private static readonly byte[] RegisterNodeWildcardFlag_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x02, 0x10, 0x02, 0x03, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Register Publication Information
    /// </summary>
    /// <remarks>
    /// Contains metadata relating to the published SMPTE registers.
    /// </remarks>
    private static readonly byte[] RegisterPublicationInformation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x02, 0x10, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Register Release Date-Time
    /// </summary>
    /// <remarks>
    /// The publication date of the register.
    /// </remarks>
    private static readonly byte[] RegisterReleaseDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x07, 0x02, 0x01, 0x01, 0x01, 0x06, 0x00, 0x00];
    /// <summary>
    /// Register Status Kind
    /// </summary>
    /// <remarks>
    /// Indicates the status of an entry.
    /// </remarks>
    private static readonly byte[] RegisterStatusKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x02, 0x10, 0x02, 0x02, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Register User Name
    /// </summary>
    /// <remarks>
    /// Name of the person who modified the entry.
    /// </remarks>
    private static readonly byte[] RegisterUserName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x02, 0x10, 0x02, 0x04, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Register User Time
    /// </summary>
    /// <remarks>
    /// Date and time when the entry has been modified.
    /// </remarks>
    private static readonly byte[] RegisterUserTime_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x02, 0x10, 0x02, 0x04, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Register Version
    /// </summary>
    /// <remarks>
    /// An incremental number that indicates the version of the register.
    /// </remarks>
    private static readonly byte[] RegisterVersion_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x02, 0x10, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Registrant Name
    /// </summary>
    /// <remarks>
    /// Name of the person who registered the metadata item.
    /// </remarks>
    private static readonly byte[] RegistrantName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x02, 0x10, 0x02, 0x04, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Registry Locator Groups
    /// </summary>
    /// <remarks>
    /// Groups of Unique Registry Locators
    /// </remarks>
    private static readonly byte[] RegistryLocatorGroups = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x01, 0x02, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Registry Locator Ordered Group (Arrays)
    /// </summary>
    /// <remarks>
    /// Ordered Group (Array) of Unique Registry Locators
    /// </remarks>
    private static readonly byte[] RegistryLocatorOrderedGroupArrays = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x01, 0x02, 0x02, 0x10, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Registry Locators
    /// </summary>
    /// <remarks>
    /// Unique Registry Locators
    /// </remarks>
    private static readonly byte[] RegistryLocators = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x01, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Registry Locator Unordered Groups
    /// </summary>
    /// <remarks>
    /// Unordered Groups of Unique Registry Locators
    /// </remarks>
    private static readonly byte[] RegistryLocatorUnorderedGroups = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x02, 0x02, 0x10, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Related Material Description
    /// </summary>
    /// <remarks>
    /// A freeform textual description of related material of any kind
    /// </remarks>
    private static readonly byte[] RelatedMaterialDescription = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x02, 0x01, 0x06, 0x0F, 0x01, 0x00, 0x00];
    /// <summary>
    /// Related Material Description
    /// </summary>
    /// <remarks>
    /// A freeform textual description of related material of any kind
    /// </remarks>
    private static readonly byte[] RelatedMaterialDescription_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x02, 0x01, 0x06, 0x0F, 0x00, 0x00, 0x00];
    /// <summary>
    /// Related Material Locators
    /// </summary>
    /// <remarks>
    /// Specifies a vector of an ordered set of references to Locators for related material of any kind
    /// </remarks>
    private static readonly byte[] RelatedMaterialLocators = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x06, 0x0D, 0x00, 0x00];
    /// <summary>
    /// Related Production Content
    /// </summary>
    /// <remarks>
    /// Related content from the Production
    /// </remarks>
    private static readonly byte[] RelatedProductionContent = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Related Production Material
    /// </summary>
    /// <remarks>
    /// Related production material
    /// </remarks>
    private static readonly byte[] RelatedProductionMaterial = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Related Textual Content
    /// </summary>
    /// <remarks>
    /// Related contetn of a textual nature - e.g. scripts and transcripts.
    /// </remarks>
    private static readonly byte[] RelatedTextualContent = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x06, 0x03, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// RELATIONAL
    /// </summary>
    /// <remarks>
    /// Class 6 is reserved for information about the relationships between data
    /// </remarks>
    private static readonly byte[] Relational = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Relations
    /// </summary>
    /// <remarks>
    /// A set of definitions for custom or basic predefined relations
    /// </remarks>
    private static readonly byte[] relations = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Relative Numerical Sequences
    /// </summary>
    /// <remarks>
    /// Sequence numbers of related items
    /// </remarks>
    private static readonly byte[] RelativeNumericalSequences = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Relative Position
    /// </summary>
    /// <remarks>
    /// Relative positional information
    /// </remarks>
    private static readonly byte[] RelativePosition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Relative Position in Sequence Name
    /// </summary>
    /// <remarks>
    /// Specifies relative Position in Sequence (previous, next etc)
    /// </remarks>
    private static readonly byte[] RelativePositionInSequenceName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x06, 0x10, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Relative Position in Sequence Offset
    /// </summary>
    /// <remarks>
    /// Numerical offset
    /// </remarks>
    private static readonly byte[] RelativePositionInSequenceOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x06, 0x10, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Relative Rate and Direction of Positional Change
    /// </summary>
    /// <remarks>
    /// Information about the relative rate and direction of positional change
    /// </remarks>
    private static readonly byte[] RelativeRateAndDirectionOfPositionalChange = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Relative Scaling Durations
    /// </summary>
    /// <remarks>
    /// Relative time duration information (twice as long, slow speed etc.)
    /// </remarks>
    private static readonly byte[] RelativeScalingDurations = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Relative Scope
    /// </summary>
    /// <remarks>
    /// Specifies the the number of nested scopes that must be passed through to find the reference metadata
    /// </remarks>
    private static readonly byte[] RelativeScope = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Relative Times
    /// </summary>
    /// <remarks>
    /// Relative time information
    /// </remarks>
    private static readonly byte[] RelativeTimes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Relative Track
    /// </summary>
    /// <remarks>
    /// Specifies the number of preceeding slots that must be passed through to find the reference slot within the specified reletive scope.
    /// </remarks>
    private static readonly byte[] RelativeTrack = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x03, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Releasable Country Code
    /// </summary>
    /// <remarks>
    /// ISO 3166 codes of countries to which classified information is releasable
    /// </remarks>
    private static readonly byte[] ReleasableCountryCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x07, 0x01, 0x20, 0x01, 0x02, 0x09, 0x01, 0x00];
    /// <summary>
    /// Releasable Country Code
    /// </summary>
    /// <remarks>
    /// ISO 3166 codes of countries to which classified information is releasable
    /// </remarks>
    private static readonly byte[] ReleaseInstructions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x02, 0x09, 0x00, 0x00];
    /// <summary>
    /// Renamed Type
    /// </summary>
    /// <remarks>
    /// Specifies a reference to the underlying type of a renamed type
    /// </remarks>
    private static readonly byte[] RenamedType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x07, 0x12, 0x00, 0x00, 0x00];
    /// <summary>
    /// Effect Rendering
    /// </summary>
    /// <remarks>
    /// Specifies a reference to pre-rendered results of an operation
    /// </remarks>
    private static readonly byte[] Rendering = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x02, 0x06, 0x00, 0x00];
    /// <summary>
    /// Repeat Numbers
    /// </summary>
    /// <remarks>
    /// Information about the repeat status when not a first broadcast
    /// </remarks>
    private static readonly byte[] RepeatNumbers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x20, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Replaces
    /// </summary>
    /// <remarks>
    /// A resource that the current resource replaces
    /// </remarks>
    private static readonly byte[] replaces = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x02, 0x04, 0x00, 0x00];
    /// <summary>
    /// Request ID
    /// </summary>
    /// <remarks>
    /// ID of this Request
    /// </remarks>
    private static readonly byte[] RequestID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Requires
    /// </summary>
    /// <remarks>
    /// A resource that the current resourece requires
    /// </remarks>
    private static readonly byte[] requires = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x02, 0x06, 0x00, 0x00];
    /// <summary>
    /// Resource ID
    /// </summary>
    /// <remarks>
    /// A UUID that identifies a resource.
    /// </remarks>
    private static readonly byte[] ResourceID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x01, 0x01, 0x15, 0x12, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Restrictions on Use
    /// </summary>
    /// <remarks>
    /// Identifies the type or level of restriction applied to the media product.
    /// </remarks>
    private static readonly byte[] RestrictionsOnUse_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Reversed Byte Order
    /// </summary>
    /// <remarks>
    /// Specifies whether the luma and croma sampling order conforms to ITU-R BT.601.  Value will be zero if the byte order conforms, non-zero if the luminance sample preceeds the chroma.
    /// </remarks>
    private static readonly byte[] ReversedByteOrder = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x01, 0x02, 0x01, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Reverse Play
    /// </summary>
    /// <remarks>
    /// The value as defined in SMPTE 389M. This value shall only be used in the First Content Package Element and, where present, should be the first item.
    /// </remarks>
    private static readonly byte[] ReversePlay = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x09, 0x02, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// RFC 5646 Additional Spoken Languages
    /// </summary>
    /// <remarks>
    /// List of RFC 5646 Spoken Language tags depicting spoken languages in addition to the primary spoken language
    /// </remarks>
    private static readonly byte[] RFC5646AdditionalSpokenLanguages = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x03, 0x02, 0x01, 0x02, 0x27, 0x00, 0x00, 0x00];
    /// <summary>
    /// RFC 5646 Language Tag List
    /// </summary>
    /// <remarks>
    /// An RFC 5646 Language Tag List that identifies one or more languages as a comma-separated list of RFC 5646 language tags.
    /// </remarks>
    private static readonly byte[] RFC5646LanguageTagList = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x03, 0x01, 0x01, 0x02, 0x02, 0x16, 0x00, 0x00];
    /// <summary>
    /// RFC 5646 Spoken Language
    /// </summary>
    /// <remarks>
    /// RFC 5646 language tag for this channel or Soundfield Group, e.g. "en-US".
    /// </remarks>
    private static readonly byte[] RFC5646SpokenLanguage = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x03, 0x01, 0x01, 0x02, 0x03, 0x15, 0x00, 0x00];
    /// <summary>
    /// RFC 5646 Text Language Code
    /// </summary>
    /// <remarks>
    /// Identifies the language of the written content as an RFC 5646 code.
    /// </remarks>
    private static readonly byte[] RFC5646TextLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x03, 0x01, 0x01, 0x02, 0x02, 0x14, 0x00, 0x00];
    /// <summary>
    /// Rights
    /// </summary>
    /// <remarks>
    /// Rights metadata
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] Rights_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rights
    /// </summary>
    /// <remarks>
    /// General information on rights of different nature associated with the resource
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] Rights_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x19, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rights
    /// </summary>
    /// <remarks>
    /// Contains information about the rights contained in the contract
    /// Namespace: http://www.smpte-ra.org/reg/335/2012/13/11
    /// </remarks>
    private static readonly byte[] Rights_11 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rights Attributed ID Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to identifiers, e.g. attributed by authorities
    /// </remarks>
    private static readonly byte[] rightsAttributedIDObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x19, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rights Clearance Flag
    /// </summary>
    /// <remarks>
    /// A flag indicating if rights have been cleared when set
    /// </remarks>
    private static readonly byte[] rightsClearanceFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x19, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rights Comment
    /// </summary>
    /// <remarks>
    /// General remarks concerning a Right
    /// </remarks>
    private static readonly byte[] RightsComment = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x02, 0x05, 0x04, 0x04, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rights Comment
    /// </summary>
    /// <remarks>
    /// General remarks concerning a Right
    /// </remarks>
    private static readonly byte[] RightsComment_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x02, 0x05, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rights Condition Description
    /// </summary>
    /// <remarks>
    /// Optional condition which restrict a Right - e.g. embargo periods
    /// </remarks>
    private static readonly byte[] RightsCondition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x05, 0x04, 0x03, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rights Condition Description
    /// </summary>
    /// <remarks>
    /// Optional condition which restrict a Right - e.g. embargo periods
    /// </remarks>
    private static readonly byte[] RightsConditionDescription_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x05, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rights Contact Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to contact objects to identify contacts
    /// </remarks>
    private static readonly byte[] rightsContactObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x19, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rights Coverage Set
    /// </summary>
    /// <remarks>
    /// A strong reference to  a coverage object to define temporal and spatial scope within which rights apply
    /// </remarks>
    private static readonly byte[] rightsCoverageObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x19, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rights Coverage Sets
    /// </summary>
    /// <remarks>
    /// To specify the temporal and spatial coverage of rights.
    /// </remarks>
    private static readonly byte[] rightsCoverageObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x19, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rights Format  Reference Sets
    /// </summary>
    /// <remarks>
    /// A batch of references to formats to which the rights apply
    /// </remarks>
    private static readonly byte[] rightsFormatReferenceObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x19, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rightsholder
    /// </summary>
    /// <remarks>
    /// A definition of who or what entity can exercise an intellectual property right
    /// </remarks>
    private static readonly byte[] Rightsholder = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x05, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rightsholder
    /// </summary>
    /// <remarks>
    /// A definition of who or what entity can exercise an IP right
    /// </remarks>
    private static readonly byte[] Rightsholder_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x05, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rights Holder Entity Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to entity objects to identify one or more rights holders
    /// </remarks>
    private static readonly byte[] rightsHolderEntityObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x19, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rights ID
    /// </summary>
    /// <remarks>
    /// An ID for reference (similar to IDREf in XML)
    /// </remarks>
    private static readonly byte[] rightsID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x19, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rights Link
    /// </summary>
    /// <remarks>
    /// A link to e.g. a webpage where the rights information can be found
    /// </remarks>
    private static readonly byte[] rightsLink = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x19, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rights Management Authority
    /// </summary>
    /// <remarks>
    /// Entity that manages the rights for access to the material.
    /// </remarks>
    private static readonly byte[] RightsManagementAuthority = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x05, 0x03, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rights Management Authority
    /// </summary>
    /// <remarks>
    /// Entity that manages the rights for access to the material.
    /// </remarks>
    private static readonly byte[] RightsManagementAuthority_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x05, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rights Note
    /// </summary>
    /// <remarks>
    /// A note with additional contextual information
    /// </remarks>
    private static readonly byte[] rightsNote = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x19, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rights Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Rights sets
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] RightsObjects_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x1A, 0x00];
    /// <summary>
    /// Rights Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to one or more expressions of rights
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] RightsObjects_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x02, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rights Start Date-Time
    /// </summary>
    /// <remarks>
    /// Date and time of the start of a rights contract
    /// </remarks>
    private static readonly byte[] RightsStartDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x07, 0x02, 0x01, 0x20, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rights Stop Date-Time
    /// </summary>
    /// <remarks>
    /// Date and time of the completion of a rights contract
    /// </remarks>
    private static readonly byte[] RightsStopDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x07, 0x02, 0x01, 0x20, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rights Type Group Set
    /// </summary>
    /// <remarks>
    /// A reference to a type group set to define the type of rights being described
    /// </remarks>
    private static readonly byte[] rightsTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x19, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rights Value Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to rights concerning the resource: usage rights, exploitation issues... possibly in different languages
    /// </remarks>
    private static readonly byte[] rightsValueObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x19, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Role
    /// </summary>
    /// <remarks>
    /// A strong reference to a role/job and associated cost centre
    /// </remarks>
    private static readonly byte[] role = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x29, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Role Name
    /// </summary>
    /// <remarks>
    /// eg. Name of character played
    /// </remarks>
    private static readonly byte[] RoleName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x30, 0x05, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Role Name
    /// </summary>
    /// <remarks>
    /// eg. Name of character played
    /// </remarks>
    private static readonly byte[] RoleName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x05, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Role Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a role / job
    /// </remarks>
    private static readonly byte[] roleTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x29, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Room Number
    /// </summary>
    /// <remarks>
    /// The aphanumeric room, suite or apartment number of an address
    /// </remarks>
    private static readonly byte[] RoomNumber_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x01, 0x00];
    /// <summary>
    /// Room or Suite Name
    /// </summary>
    /// <remarks>
    /// The room, suite or apartment name of an address
    /// </remarks>
    private static readonly byte[] RoomSuiteName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x11, 0x01];
    /// <summary>
    /// Room or Suite Name
    /// </summary>
    /// <remarks>
    /// The room, suite or apartment name of an address
    /// </remarks>
    private static readonly byte[] RoomSuiteName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x11, 0x00];
    /// <summary>
    /// Room Number
    /// </summary>
    /// <remarks>
    /// The aphanumeric room, suite or apartment number of an address
    /// </remarks>
    private static readonly byte[] RoomSuiteNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x01, 0x01];
    /// <summary>
    /// Root Extensions
    /// </summary>
    /// <remarks>
    /// References the Extension Schemes that are used in the file
    /// </remarks>
    private static readonly byte[] RootExtensions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x06, 0x01, 0x01, 0x07, 0x1A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Root Format Version
    /// </summary>
    /// <remarks>
    /// Specifies the underlying reference structure of the Root Object
    /// </remarks>
    private static readonly byte[] RootFormatVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x06, 0x01, 0x01, 0x07, 0x19, 0x00, 0x00, 0x00];
    /// <summary>
    /// Root Meta Dictionary
    /// </summary>
    /// <remarks>
    /// Specifies a reference to a collection of class, type and property definitions
    /// </remarks>
    private static readonly byte[] RootMetaDictionary = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x06, 0x01, 0x01, 0x07, 0x16, 0x00, 0x00, 0x00];
    /// <summary>
    /// Root Object Directory
    /// </summary>
    /// <remarks>
    /// Specifies a reference to a directory of Object locations
    /// </remarks>
    private static readonly byte[] RootObjectDirectory = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x06, 0x01, 0x01, 0x07, 0x18, 0x00, 0x00, 0x00];
    /// <summary>
    /// Root Preface
    /// </summary>
    /// <remarks>
    /// Specifies a reference to the Preface object
    /// </remarks>
    private static readonly byte[] RootPreface = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x06, 0x01, 0x01, 0x07, 0x17, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rotary Shutter
    /// </summary>
    /// <remarks>
    /// Use of the mechanical shutter function
    /// </remarks>
    private static readonly byte[] RotaryShutter = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x01, 0x03, 0x01, 0x0E, 0x00, 0x00];
    /// <summary>
    /// Rotation Angle
    /// </summary>
    /// <remarks>
    /// Clockwise rotation angle with respect to the positive direction of the x-axis of the ellipses
    /// </remarks>
    private static readonly byte[] RotationAngle = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x31, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rounding Law
    /// </summary>
    /// <remarks>
    /// The rounding law applied
    /// </remarks>
    private static readonly byte[] RoundingLaw_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x03, 0x03, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rounding Method Code
    /// </summary>
    /// <remarks>
    /// Specifies the rounding method that has been applied to the digital samples of the video signal.
    /// </remarks>
    private static readonly byte[] RoundingMethodCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x03, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rows In Mastering Display Actual Peak Luminance
    /// </summary>
    /// <remarks>
    /// Number of rows (M) in the Mastering Display Actual Peak Luminance array
    /// </remarks>
    private static readonly byte[] RowsInMasteringDisplayActualPeakLuminance = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x39, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rows In Targeted System Display Actual Peak Luminance
    /// </summary>
    /// <remarks>
    /// Number of rows (M) in the Targeted System Display Actual Peak Luminance array
    /// </remarks>
    private static readonly byte[] RowsInTargetedSystemDisplayActualPeakLuminance = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x37, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Royalty Income Information
    /// </summary>
    /// <remarks>
    /// Royalty income and other financial information
    /// </remarks>
    private static readonly byte[] RoyaltyIncomeInformation_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x06, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Royalty Payment Information
    /// </summary>
    /// <remarks>
    /// Royalty payment and other financial information
    /// </remarks>
    private static readonly byte[] RoyaltyPaymentInformation_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x06, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// RP217 Data Stream PID
    /// </summary>
    /// <remarks>
    /// Identifier that is the transport_stream_id in ISO/IEC 13818-1 (MPEG-2 Systems) for the Data stream per RP217
    /// </remarks>
    private static readonly byte[] RP217DataStreamPID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x01, 0x03, 0x04, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// RP217 Video Stream PID
    /// </summary>
    /// <remarks>
    /// Identifier that is the transport_stream_id in ISO/IEC 13818-1 (MPEG-2 Systems) for the Video stream per RP217
    /// </remarks>
    private static readonly byte[] RP217VideoStreamPID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x01, 0x03, 0x04, 0x07, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rsiz
    /// </summary>
    /// <remarks>
    /// An enumerated value that defines the decoder capabilities. Values are defined in ISO/IEC 15444-1 Annex A.5 Table A-10. Other values may be defined in amendments to ISO/IEC 15444-1 or in related international standards documents.
    /// </remarks>
    private static readonly byte[] Rsiz = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x06, 0x03, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Rules Based Specifications Version 1
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] RulesBasedSpecificationsVersion1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Running Order Number
    /// </summary>
    /// <remarks>
    /// The ranking number if member of an ordered group, when applicable
    /// </remarks>
    private static readonly byte[] runningOrderNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x01, 0x03, 0x00, 0x00];
    /// <summary>
    /// S-ADM Audio Metadata Coding Parameters
    /// </summary>
    /// <remarks>
    /// Parameters about S-ADM Audio Metadata Coding
    /// </remarks>
    private static readonly byte[] SADMAudioMetadataCodingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x02, 0x03, 0x07, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// S-ADM Metadata Section Link ID
    /// </summary>
    /// <remarks>
    /// Specifies the S-ADM Metadata Section Link ID
    /// </remarks>
    private static readonly byte[] SADMMetadataSectionLinkID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x02, 0x03, 0x07, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// S-ADM Profile Level UL Batch
    /// </summary>
    /// <remarks>
    /// Batch of S-ADM Profile and Level UL entries
    /// </remarks>
    private static readonly byte[] SADMProfileLevelULBatch = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x02, 0x03, 0x07, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Sales Contract Number
    /// </summary>
    /// <remarks>
    /// The alphanumeric number for the contract for the sale of content
    /// </remarks>
    private static readonly byte[] SalesContractNumber_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Salutation
    /// </summary>
    /// <remarks>
    /// An individual's salutation or title.  Eg.  Mr., Mrs., Sir
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] Salutation_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x30, 0x06, 0x03, 0x01, 0x05, 0x01, 0x00];
    /// <summary>
    /// Salutation
    /// </summary>
    /// <remarks>
    /// Mr., Mrs, Ms , Pr., Dr.
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] Salutation_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x22, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Salutation
    /// </summary>
    /// <remarks>
    /// An individual's salutation or title.  Eg.  Mr., Mrs., Sir
    /// </remarks>
    private static readonly byte[] Salutation_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x02, 0x30, 0x06, 0x03, 0x01, 0x05, 0x00, 0x00];
    /// <summary>
    /// Same As
    /// </summary>
    /// <remarks>
    /// A resource that is the same as the current resource
    /// </remarks>
    private static readonly byte[] sameAs = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x02, 0x16, 0x00, 0x00];
    /// <summary>
    /// Sampled Height
    /// </summary>
    /// <remarks>
    /// Specifies the integer height of the sampled image in pixels
    /// </remarks>
    private static readonly byte[] SampledHeight = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x01, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Sampled Width
    /// </summary>
    /// <remarks>
    /// Specifies the integer width of the sampled image in pixels
    /// </remarks>
    private static readonly byte[] SampledWidth = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x01, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Sampled X-Offset
    /// </summary>
    /// <remarks>
    /// Specifies the X offset of the sampled image relative to the stored image in pixels
    /// </remarks>
    private static readonly byte[] SampledXOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x01, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Sampled Y-Offset
    /// </summary>
    /// <remarks>
    /// Specifies the Y offset of the sampled image relative to the stored image in pixels
    /// </remarks>
    private static readonly byte[] SampledYOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x01, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Sample Index
    /// </summary>
    /// <remarks>
    /// Stream of byte offsets to individual samples in the essence data
    /// </remarks>
    private static readonly byte[] SampleIndex = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Sample Rate
    /// </summary>
    /// <remarks>
    /// Specifies the number of addressable elements of essence data per second
    /// </remarks>
    private static readonly byte[] SampleRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x06, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Sampling Hierarchy Code
    /// </summary>
    /// <remarks>
    /// A code that specifies the component sampling hierarchy for the video pixel matrix.
    /// </remarks>
    private static readonly byte[] SamplingHierarchyCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x01, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Sampling Structure Code
    /// </summary>
    /// <remarks>
    /// A code that specifies the analogue or digital sampling structure for the video scanning system.  Eg Progressive
    /// </remarks>
    private static readonly byte[] SamplingStructureCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x03, 0x01, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Saturation Gain
    /// </summary>
    /// <remarks>
    /// Amount of saturation adjustment
    /// </remarks>
    private static readonly byte[] SaturationGain = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x17, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Saturation Gain Function
    /// </summary>
    /// <remarks>
    /// Sampled function, mapping a luminance based input value to a saturation scaling factor
    /// </remarks>
    private static readonly byte[] SaturationGainFunction = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x1F, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Scanning Direction
    /// </summary>
    /// <remarks>
    /// Enumerated Scanning Direction
    /// </remarks>
    private static readonly byte[] ScanningDirection = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x01, 0x04, 0x04, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Scene Number
    /// </summary>
    /// <remarks>
    /// The alphanumeric scene number
    /// </remarks>
    private static readonly byte[] SceneNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Scene Number
    /// </summary>
    /// <remarks>
    /// The alphanumeric scene number
    /// </remarks>
    private static readonly byte[] SceneNumber_UTF16String = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x05, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Scene Setting Period Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Setting Period sets
    /// </remarks>
    private static readonly byte[] SceneSettingPeriodObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x0E, 0x02];
    /// <summary>
    /// Scene Shot Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Shot  sets
    /// </remarks>
    private static readonly byte[] SceneShotObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x11, 0x01];
    /// <summary>
    /// Schedule date
    /// </summary>
    /// <remarks>
    /// The calendar date to which the publication time is associated with
    /// </remarks>
    private static readonly byte[] scheduleDate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1C, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Scrambling Key Kind
    /// </summary>
    /// <remarks>
    /// The program decryption key type for Film
    /// </remarks>
    private static readonly byte[] ScramblingKeyKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x09, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Scrambling Keys
    /// </summary>
    /// <remarks>
    /// Information about decryption keys for Film
    /// </remarks>
    private static readonly byte[] ScramblingKeys = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x09, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Scrambling Key Value
    /// </summary>
    /// <remarks>
    /// The program decryption key value for Film
    /// </remarks>
    private static readonly byte[] ScramblingKeyValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x09, 0x01, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Scripting Kind
    /// </summary>
    /// <remarks>
    /// Description of the scripting kind as a text string (e.g. lighting, transcript etc)
    /// </remarks>
    private static readonly byte[] ScriptingKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x02, 0x01, 0x06, 0x0B, 0x01, 0x00, 0x00];
    /// <summary>
    /// Scripting Kind
    /// </summary>
    /// <remarks>
    /// Description of the scripting kind as a text string (e.g. lighting, transcript etc)
    /// </remarks>
    private static readonly byte[] ScriptingKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x02, 0x01, 0x06, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Scripting Locators
    /// </summary>
    /// <remarks>
    /// Specifies a vector of an ordered set of references to Locators for scripting material of any kind
    /// </remarks>
    private static readonly byte[] ScriptingLocators = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x06, 0x01, 0x01, 0x04, 0x06, 0x0E, 0x00, 0x00];
    /// <summary>
    /// Scripting Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Scripting Metadata sets
    /// </remarks>
    private static readonly byte[] ScriptingObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x0F, 0x00];
    /// <summary>
    /// Scripting Text
    /// </summary>
    /// <remarks>
    /// The scripting text string
    /// </remarks>
    private static readonly byte[] ScriptingText = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x02, 0x01, 0x06, 0x0C, 0x01, 0x00, 0x00];
    /// <summary>
    /// Scripting Text
    /// </summary>
    /// <remarks>
    /// The scripting text string
    /// </remarks>
    private static readonly byte[] ScriptingText_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x02, 0x01, 0x06, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// sd_flag
    /// </summary>
    /// <remarks>
    /// SD Flag - CDC Flag for SD Code (video only)
    /// </remarks>
    private static readonly byte[] sd_flag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x0D, 0x0D, 0x01, 0x0A, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// SDID
    /// </summary>
    /// <remarks>
    /// Secondary Data Identifer
    /// </remarks>
    private static readonly byte[] SDID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x38, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Season Episode Number
    /// </summary>
    /// <remarks>
    /// Indicates the episode number for a series season
    /// </remarks>
    private static readonly byte[] SeasonEpisodeNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Season Episode Title
    /// </summary>
    /// <remarks>
    /// Indicates the episode title for a series season
    /// </remarks>
    private static readonly byte[] SeasonEpisodeTitle = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Secondary Extended Spoken Language Code
    /// </summary>
    /// <remarks>
    /// The RFC-3066-compliant code that specifies the base ISO code for the language as well as regional variant information for the secondary spoken language
    /// </remarks>
    private static readonly byte[] SecondaryExtendedSpokenLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x01, 0x02, 0x03, 0x12, 0x00, 0x00];
    /// <summary>
    /// Secondary Original Extended Spoken Language Code
    /// </summary>
    /// <remarks>
    /// The RFC-3066-compliant code that specifies the base ISO code for the language as well as regional variant information for the original seconday spoken language
    /// </remarks>
    private static readonly byte[] SecondaryOriginalExtendedSpokenLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x01, 0x02, 0x03, 0x14, 0x00, 0x00];
    /// <summary>
    /// Secondary Original Language Code
    /// </summary>
    /// <remarks>
    /// ISO 639 Language Code for the original secondary spoken language
    /// </remarks>
    private static readonly byte[] SecondaryOriginalSpokenLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x03, 0x01, 0x01, 0x02, 0x03, 0x04, 0x00, 0x00];
    /// <summary>
    /// Secondary Spoken Language Code
    /// </summary>
    /// <remarks>
    /// ISO 639 Language Code for the current secondary spoken language
    /// </remarks>
    private static readonly byte[] SecondarySpokenLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x03, 0x01, 0x01, 0x02, 0x03, 0x02, 0x00, 0x00];
    /// <summary>
    /// Secondary Title
    /// </summary>
    /// <remarks>
    /// The secondary title
    /// </remarks>
    private static readonly byte[] SecondaryTitle = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x05, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Secondary Title
    /// </summary>
    /// <remarks>
    /// The secondary title
    /// </remarks>
    private static readonly byte[] SecondaryTitle_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Second Given Name
    /// </summary>
    /// <remarks>
    /// The second given name for an individual
    /// </remarks>
    private static readonly byte[] SecondGivenName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x30, 0x06, 0x03, 0x01, 0x03, 0x01, 0x00];
    /// <summary>
    /// Second Given Name
    /// </summary>
    /// <remarks>
    /// The second given name for an individual
    /// </remarks>
    private static readonly byte[] SecondGivenName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x06, 0x03, 0x01, 0x03, 0x00, 0x00];
    /// <summary>
    /// Sector Size
    /// </summary>
    /// <remarks>
    /// The size of a unit of data, in bytes.  The unit size may be at any granulaity (packet, sector etc)
    /// </remarks>
    private static readonly byte[] SectorSize = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x03, 0x01, 0x02, 0x01, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Secure Clock Time
    /// </summary>
    /// <remarks>
    /// Timestamp representing the OMB secure clock time
    /// </remarks>
    private static readonly byte[] SecureClockTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x0B, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Security
    /// </summary>
    /// <remarks>
    /// Content encryption/decryption information
    /// </remarks>
    private static readonly byte[] Security = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Security Classification
    /// </summary>
    /// <remarks>
    /// Marking of the security level or other description of the classification of information
    /// </remarks>
    private static readonly byte[] SecurityClassification = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x02, 0x08, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Security Classification
    /// </summary>
    /// <remarks>
    /// Marking of the security level or other description of the classification of information
    /// </remarks>
    private static readonly byte[] SecurityClassification_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x08, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Security Classification Caveats
    /// </summary>
    /// <remarks>
    /// Marking of security exceptions or restrictions on the security classification
    /// </remarks>
    private static readonly byte[] SecurityClassificationCaveats = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x02, 0x08, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Security Message Identifiers
    /// </summary>
    /// <remarks>
    /// Identifiers relating to the security message.
    /// </remarks>
    private static readonly byte[] SecurityMessageIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x03, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Selected
    /// </summary>
    /// <remarks>
    /// Specifies the segment selected by the editor
    /// </remarks>
    private static readonly byte[] SelectedSegment = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x02, 0x09, 0x00, 0x00];
    /// <summary>
    /// Semi-Major Axis External Ellipse
    /// </summary>
    /// <remarks>
    /// Semi-major axis value of the external ellipse
    /// </remarks>
    private static readonly byte[] SemiMajorAxisExternalEllipse = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x33, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Semi-Major Axis Internal Ellipse
    /// </summary>
    /// <remarks>
    /// Semi-major axis value of the internal ellipse
    /// </remarks>
    private static readonly byte[] SemiMajorAxisInternalEllipse = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x32, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Semi-Minor Axis External Ellipse
    /// </summary>
    /// <remarks>
    /// Semi-minor axis value of the external ellipse
    /// </remarks>
    private static readonly byte[] SemiMinorAxisExternalEllipse = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x34, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Sensor Mode
    /// </summary>
    /// <remarks>
    /// The mode setting of the sensor as a text string
    /// </remarks>
    private static readonly byte[] SensorMode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x04, 0x01, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Sensor Parameters
    /// </summary>
    /// <remarks>
    /// Settings and adjustments for image sensors
    /// </remarks>
    private static readonly byte[] SensorParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x04, 0x01, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Sensor Roll Angle
    /// </summary>
    /// <remarks>
    /// Specifies the roll angle of the sensor.  Expressed in degrees.
    /// </remarks>
    private static readonly byte[] SensorRollAngle = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x10, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Sensor Size
    /// </summary>
    /// <remarks>
    /// The size of the sensor, for example: 1/2 inch,  2/3 inch, etc.
    /// </remarks>
    private static readonly byte[] SensorSize_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x20, 0x02, 0x01, 0x01, 0x05, 0x00, 0x00];
    /// <summary>
    /// Sensor Type
    /// </summary>
    /// <remarks>
    /// transducer principle
    /// </remarks>
    private static readonly byte[] SensorType_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x20, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Sensor Type Code
    /// </summary>
    /// <remarks>
    /// Code indicating type of sensor that produced the original video content.
    /// </remarks>
    private static readonly byte[] SensorTypeCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x20, 0x02, 0x01, 0x01, 0x07, 0x00, 0x00];
    /// <summary>
    /// Sequence Offset
    /// </summary>
    /// <remarks>
    /// The zero-based ordinal frame number of  first essence data within five-frame sequence
    /// </remarks>
    private static readonly byte[] SequenceOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x03, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Series in a Series Group Count
    /// </summary>
    /// <remarks>
    /// The total number of series for a related group of series - for example, several series of the same program may be commissioned over many years.
    /// </remarks>
    private static readonly byte[] SeriesInASeriesGroupCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Series Number
    /// </summary>
    /// <remarks>
    /// The alphanumeric series number
    /// </remarks>
    private static readonly byte[] SeriesNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x05, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Series Number
    /// </summary>
    /// <remarks>
    /// The alphanumeric series number
    /// </remarks>
    private static readonly byte[] SeriesNumber_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Set Element Type
    /// </summary>
    /// <remarks>
    /// Specifies a reference to the underlying type used in an unordered set type
    /// </remarks>
    private static readonly byte[] SetElementType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x07, 0x0E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Setting Addresses
    /// </summary>
    /// <remarks>
    /// Information about address depicted in the setting of a production
    /// </remarks>
    private static readonly byte[] SettingAddresses = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x04, 0x02, 0x00, 0x00];
    /// <summary>
    /// Setting City Name
    /// </summary>
    /// <remarks>
    /// The city of the depicted address.
    /// </remarks>
    private static readonly byte[] SettingCityName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x04, 0x02, 0x05, 0x01];
    /// <summary>
    /// Setting City Name
    /// </summary>
    /// <remarks>
    /// The city of the depicted address.
    /// </remarks>
    private static readonly byte[] SettingCityName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x04, 0x02, 0x05, 0x00];
    /// <summary>
    /// Setting Country Code
    /// </summary>
    /// <remarks>
    /// The ISO code that represents the country where the depicted action is set in the production
    /// </remarks>
    private static readonly byte[] SettingCountryCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x02, 0x03, 0x00, 0x00];
    /// <summary>
    /// Setting Country Name
    /// </summary>
    /// <remarks>
    /// The country of the depicted address.
    /// </remarks>
    private static readonly byte[] SettingCountryName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x04, 0x02, 0x08, 0x01];
    /// <summary>
    /// Setting Country Name
    /// </summary>
    /// <remarks>
    /// The country of the depicted address.
    /// </remarks>
    private static readonly byte[] SettingCountryName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x04, 0x02, 0x08, 0x00];
    /// <summary>
    /// Setting Date and Time
    /// </summary>
    /// <remarks>
    /// Time period(s) characterized by the data set.
    /// </remarks>
    private static readonly byte[] SettingDateAndTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Setting Date-Time
    /// </summary>
    /// <remarks>
    /// The date (and time if appropriate) of the setting as a timestamp
    /// </remarks>
    private static readonly byte[] SettingDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x07, 0x02, 0x01, 0x08, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Setting Description
    /// </summary>
    /// <remarks>
    /// eg.  'A clearing in a wood' or 'Falstaffs living room'
    /// </remarks>
    private static readonly byte[] SettingDescription = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x02, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Setting Description
    /// </summary>
    /// <remarks>
    /// eg.  'A clearing in a wood' or 'Falstaffs living room'
    /// </remarks>
    private static readonly byte[] SettingDescription_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Setting Period Description
    /// </summary>
    /// <remarks>
    /// Free-form text description of the setting period
    /// </remarks>
    private static readonly byte[] SettingPeriodDescription = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x07, 0x02, 0x01, 0x08, 0x03, 0x01, 0x00, 0x00];
    /// <summary>
    /// Setting Period Description
    /// </summary>
    /// <remarks>
    /// Free-form text description of the setting period
    /// </remarks>
    private static readonly byte[] SettingPeriodDescription_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x07, 0x02, 0x01, 0x08, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Setting Period Sets
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] SettingPeriodSets = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x0E, 0x00];
    /// <summary>
    /// Setting Postal Code
    /// </summary>
    /// <remarks>
    /// The ZIP or other postal code of the depicted address.
    /// </remarks>
    private static readonly byte[] SettingPostalCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x04, 0x02, 0x07, 0x01];
    /// <summary>
    /// Setting Postal Code
    /// </summary>
    /// <remarks>
    /// The ZIP or other postal code of the depicted address.
    /// </remarks>
    private static readonly byte[] SettingPostalCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x04, 0x02, 0x07, 0x00];
    /// <summary>
    /// Setting Region Code
    /// </summary>
    /// <remarks>
    /// The ISO code that represents the region of the country where the depicted action is set in the production
    /// </remarks>
    private static readonly byte[] SettingRegionCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x03, 0x03, 0x00, 0x00];
    /// <summary>
    /// Setting Region Name
    /// </summary>
    /// <remarks>
    /// The region of the country where the depicted action is set in the production
    /// </remarks>
    private static readonly byte[] SettingRegionName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x03, 0x03, 0x01, 0x00];
    /// <summary>
    /// Setting Room Number
    /// </summary>
    /// <remarks>
    /// The room number of a depicted address
    /// </remarks>
    private static readonly byte[] SettingRoomNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x04, 0x02, 0x01, 0x01];
    /// <summary>
    /// Setting Room Number
    /// </summary>
    /// <remarks>
    /// The room number of a depicted address
    /// </remarks>
    private static readonly byte[] SettingRoomNumber_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x04, 0x02, 0x01, 0x00];
    /// <summary>
    /// Setting State or Province or County Name
    /// </summary>
    /// <remarks>
    /// The state, province or county of the depicted address.
    /// </remarks>
    private static readonly byte[] SettingStateOrProvinceOrCountyName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x04, 0x02, 0x06, 0x01];
    /// <summary>
    /// Setting State or Province or County Name
    /// </summary>
    /// <remarks>
    /// The state, province or county of the depicted address.
    /// </remarks>
    private static readonly byte[] SettingStateOrProvinceOrCountyName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x04, 0x02, 0x06, 0x00];
    /// <summary>
    /// Setting Street Name
    /// </summary>
    /// <remarks>
    /// An address line for the depicted address
    /// </remarks>
    private static readonly byte[] SettingStreetName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x04, 0x02, 0x03, 0x01];
    /// <summary>
    /// Setting Street Name
    /// </summary>
    /// <remarks>
    /// An address line for the depicted address
    /// </remarks>
    private static readonly byte[] SettingStreetName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x04, 0x02, 0x03, 0x00];
    /// <summary>
    /// Setting Street Number or Building Name
    /// </summary>
    /// <remarks>
    /// An address line for the depicted address
    /// </remarks>
    private static readonly byte[] SettingStreetNumberOrBuildingName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x04, 0x02, 0x02, 0x01];
    /// <summary>
    /// Setting Street Number or Building Name
    /// </summary>
    /// <remarks>
    /// An address line for the depicted address
    /// </remarks>
    private static readonly byte[] SettingStreetNumberOrBuildingName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x04, 0x02, 0x02, 0x00];
    /// <summary>
    /// Setting Town Name
    /// </summary>
    /// <remarks>
    /// An address line for the depicted address
    /// </remarks>
    private static readonly byte[] SettingTownName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x04, 0x02, 0x04, 0x01];
    /// <summary>
    /// Setting Town Name
    /// </summary>
    /// <remarks>
    /// An address line for the depicted address
    /// </remarks>
    private static readonly byte[] SettingTownName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x04, 0x02, 0x04, 0x00];
    /// <summary>
    /// Shadow Gain Control
    /// </summary>
    /// <remarks>
    /// Control for the steepness of the curve in its shadow (darker) region
    /// </remarks>
    private static readonly byte[] ShadowGainControl = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x23, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Shooting Country Code
    /// </summary>
    /// <remarks>
    /// The ISO code that represents the country where shooting took place
    /// </remarks>
    private static readonly byte[] ShootingCountryCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x02, 0x02, 0x00, 0x00];
    /// <summary>
    /// Shooting Region Code
    /// </summary>
    /// <remarks>
    /// The ISO code that represents the region within a country where shooting took place
    /// </remarks>
    private static readonly byte[] ShootingRegionCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x03, 0x02, 0x00, 0x00];
    /// <summary>
    /// Shooting Region Name
    /// </summary>
    /// <remarks>
    /// Region within a country where shooting took place
    /// </remarks>
    private static readonly byte[] ShootingRegionName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x03, 0x02, 0x01, 0x00];
    /// <summary>
    /// Shot Comment
    /// </summary>
    /// <remarks>
    /// The comment or note about a shot (e.g., 'general view of valley in autumn', 'badly recorded' or 'sombre mood')
    /// </remarks>
    private static readonly byte[] ShotComment = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x02, 0x05, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Shot Comment
    /// </summary>
    /// <remarks>
    /// The comment or note about a shot (e.g., 'general view of valley in autumn', 'badly recorded' or 'sombre mood')
    /// </remarks>
    private static readonly byte[] ShotComment_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x05, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Shot Comment Kind
    /// </summary>
    /// <remarks>
    /// The type of descriptive comment or note (e.g., 'Shot' or 'Lighting Mood')
    /// </remarks>
    private static readonly byte[] ShotCommentKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x02, 0x05, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Shot Comment Kind
    /// </summary>
    /// <remarks>
    /// The type of descriptive comment or note (e.g., 'Shot' or 'Lighting Mood')
    /// </remarks>
    private static readonly byte[] ShotCommentKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Shot Cue Words Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a Cue Words set
    /// </remarks>
    private static readonly byte[] ShotCueWordsObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x02, 0x40, 0x23, 0x02];
    /// <summary>
    /// Shot Description
    /// </summary>
    /// <remarks>
    /// A freeform textual description of the shot defined by this set
    /// </remarks>
    private static readonly byte[] ShotDescription = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x02, 0x01, 0x06, 0x0D, 0x01, 0x00, 0x00];
    /// <summary>
    /// Shot Description
    /// </summary>
    /// <remarks>
    /// A freeform textual description of the shot defined by this set
    /// </remarks>
    private static readonly byte[] ShotDescription_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x02, 0x01, 0x06, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Shot Duration
    /// </summary>
    /// <remarks>
    /// Defines the duration of this shot in edit units. A value of 1 defines a single edit unit length
    /// </remarks>
    private static readonly byte[] ShotDuration = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x07, 0x02, 0x02, 0x01, 0x02, 0x04, 0x00, 0x00];
    /// <summary>
    /// Shot List
    /// </summary>
    /// <remarks>
    /// Freeform textual listing of shots, for example indexed against time or frame count
    /// </remarks>
    private static readonly byte[] ShotList_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x01, 0x02, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Shot Sets
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] ShotSets = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x11, 0x00];
    /// <summary>
    /// Shot Start Position
    /// </summary>
    /// <remarks>
    /// Defines the first edit unit to which this shot applies
    /// </remarks>
    private static readonly byte[] ShotStartPosition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x07, 0x02, 0x01, 0x03, 0x01, 0x09, 0x00, 0x00];
    /// <summary>
    /// Shot Track IDs
    /// </summary>
    /// <remarks>
    /// Specifies an unordered list of 'n' track ID values that identify the tracks in the Package to which this set refers
    /// </remarks>
    private static readonly byte[] ShotTrackIDs = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x07, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Shutter Characteristics
    /// </summary>
    /// <remarks>
    /// Shutter characteristics.
    /// </remarks>
    private static readonly byte[] ShutterCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Shutter Gating
    /// </summary>
    /// <remarks>
    /// Shutter Gating characteristics
    /// </remarks>
    private static readonly byte[] ShutterGating = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x06, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Shutter Speed
    /// </summary>
    /// <remarks>
    /// Shutter speed
    /// </remarks>
    private static readonly byte[] ShutterSpeed = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x06, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Shutter Speed (Angle)
    /// </summary>
    /// <remarks>
    /// Shutter speed as an angle defining the shutter speed (angle) in minutes relative to a completely open shutter angle of 360 degrees.
    /// </remarks>
    private static readonly byte[] ShutterSpeedAngle = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x01, 0x03, 0x01, 0x08, 0x00, 0x00];
    /// <summary>
    /// Shutter Speed (Time)
    /// </summary>
    /// <remarks>
    /// Shutter speed as a time defining the shutter speed (time) in seconds
    /// </remarks>
    private static readonly byte[] ShutterSpeedTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x01, 0x03, 0x01, 0x08, 0x01, 0x00];
    /// <summary>
    /// SICI
    /// </summary>
    /// <remarks>
    /// ANSI/NISO Serial Item and Contribution Identifier
    /// </remarks>
    private static readonly byte[] SICI = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x13, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Side Number
    /// </summary>
    /// <remarks>
    /// Where appropriate, the side number on which the track is recorded.
    /// </remarks>
    private static readonly byte[] SideNumber_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x10, 0x03, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Signal Form Code
    /// </summary>
    /// <remarks>
    /// Code specifies the component sequence for the video pixel matrix (eg RGB, YUV etc).
    /// </remarks>
    private static readonly byte[] SignalFormCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x02, 0x01, 0x01, 0x04, 0x00, 0x00];
    /// <summary>
    /// Signal Standard
    /// </summary>
    /// <remarks>
    /// Underlying Signal Standard
    /// </remarks>
    private static readonly byte[] SignalStandard = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x05, 0x01, 0x13, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Signal-to-Noise Ratio
    /// </summary>
    /// <remarks>
    /// The measured signal to noise ratio of the original recording
    /// </remarks>
    private static readonly byte[] SignalToNoiseRatio = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Signature Tune Flag
    /// </summary>
    /// <remarks>
    /// Indicates that the usage of the piece of music is for a signature tune
    /// </remarks>
    private static readonly byte[] SignatureTuneFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x05, 0x01, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Signing  Format
    /// </summary>
    /// <remarks>
    /// A set of attributes to describe signing  in the material
    /// </remarks>
    private static readonly byte[] signingFormat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x39, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Signing Format Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute format group to define the format of signing being used
    /// </remarks>
    private static readonly byte[] signingFormatGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x39, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Signing Format ID
    /// </summary>
    /// <remarks>
    /// An Identifier attributed to the signing format
    /// </remarks>
    private static readonly byte[] signingFormatID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x39, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Signing Format Name
    /// </summary>
    /// <remarks>
    /// A name attributed to the signing format
    /// </remarks>
    private static readonly byte[] signingFormatName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x39, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Signing Format Version ID
    /// </summary>
    /// <remarks>
    /// An Identifier attributed to the version of signing format
    /// </remarks>
    private static readonly byte[] signingFormatVersionID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x39, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Signing Presence Flag
    /// </summary>
    /// <remarks>
    /// A flag to indicate the presence of signing
    /// </remarks>
    private static readonly byte[] signingPresenceFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x39, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Signing Source Uri
    /// </summary>
    /// <remarks>
    /// A URI from where a signing source file can be accessed
    /// </remarks>
    private static readonly byte[] signingSourceUri = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x39, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Signing Track ID
    /// </summary>
    /// <remarks>
    /// An identifier associated with a signing track
    /// </remarks>
    private static readonly byte[] signingTrackID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x39, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Signing Track Language Code
    /// </summary>
    /// <remarks>
    /// Codes assigned by RFC 5646 / BCP 47 for the identification of languages
    /// </remarks>
    private static readonly byte[] signingTrackLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x39, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Signing Track Name
    /// </summary>
    /// <remarks>
    /// An name associated with a signing track
    /// </remarks>
    private static readonly byte[] signingTrackName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x39, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Signing Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group to define the type of signing being used
    /// </remarks>
    private static readonly byte[] signingTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x39, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Simple Flagging Count
    /// </summary>
    /// <remarks>
    /// The number of alterations to the original file.
    /// </remarks>
    private static readonly byte[] SimpleFlagging = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Simple Payload SID
    /// </summary>
    /// <remarks>
    /// Identifies the Source Track ID of the ST 410 GSP as static data
    /// </remarks>
    private static readonly byte[] SimplePayloadSID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x0E, 0x09, 0x06, 0x07, 0x01, 0x01, 0x01, 0x06];
    /// <summary>
    /// Single Essence Location
    /// </summary>
    /// <remarks>
    /// Specifies whether the Essence Containers are in one partition or multiple partitions.
    /// </remarks>
    private static readonly byte[] SingleEssenceLocation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x06, 0x02, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Single Index Location
    /// </summary>
    /// <remarks>
    /// Specifies whether the Index Table Segments are in one partition or multiple partitions.
    /// </remarks>
    private static readonly byte[] SingleIndexLocation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x04, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Single Sequence Flag
    /// </summary>
    /// <remarks>
    /// TRUE if the essence consists of a single MPEG sequence. False if there are a number of sequences. This flag implies that the sequence header information is not varying in the essence stream.
    /// </remarks>
    private static readonly byte[] SingleSequence = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x01, 0x06, 0x02, 0x01, 0x02, 0x00, 0x00];
    /// <summary>
    /// Singular Partition Usage
    /// </summary>
    /// <remarks>
    /// Specifies whether the Partition is Singular.
    /// </remarks>
    private static readonly byte[] SingularPartitionUsage = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x06, 0x02, 0x07, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Size
    /// </summary>
    /// <remarks>
    /// Specifies the number of bytes in the integer
    /// </remarks>
    private static readonly byte[] Size = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x02, 0x03, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Skill
    /// </summary>
    /// <remarks>
    /// The skill of a contact/person
    /// </remarks>
    private static readonly byte[] skill = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x22, 0x16, 0x00, 0x00, 0x00];
    /// <summary>
    /// Slant Range
    /// </summary>
    /// <remarks>
    /// Distance from the sensor to the center point on ground of the framed subject (image) depicted in the captured essence, (default metres)
    /// </remarks>
    private static readonly byte[] SlantRange = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x08, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Slate Information
    /// </summary>
    /// <remarks>
    /// Slate information as a text string
    /// </remarks>
    private static readonly byte[] SlateInformation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x03, 0x02, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Slice Number
    /// </summary>
    /// <remarks>
    /// The number of the indexed section in the edit unit
    /// </remarks>
    private static readonly byte[] Slice = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x04, 0x04, 0x04, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Slice Count
    /// </summary>
    /// <remarks>
    /// Number of sections indexed, per edit unit, minus one
    /// </remarks>
    private static readonly byte[] SliceCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x04, 0x04, 0x04, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Slice Offset List
    /// </summary>
    /// <remarks>
    /// List of 'n' offsets within the edit unit of each indexed section (except the first)
    /// </remarks>
    private static readonly byte[] SliceOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x04, 0x04, 0x04, 0x01, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// SMPTE 12-3 Time Code
    /// </summary>
    /// <remarks>
    /// Time stamp application defined by user application
    /// </remarks>
    private static readonly byte[] SMPTE12_3TimeCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x07, 0x02, 0x01, 0x01, 0x01, 0x0A, 0x00, 0x00];
    /// <summary>
    /// SMPTE 12M User Date-Time
    /// </summary>
    /// <remarks>
    /// Time stamp application defined by user application
    /// </remarks>
    private static readonly byte[] SMPTE12MUserDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x01, 0x01, 0x04, 0x00, 0x00];
    /// <summary>
    /// SMPTE 309M User Date-Time
    /// </summary>
    /// <remarks>
    /// Time stamp application defined by user application
    /// </remarks>
    private static readonly byte[] SMPTE309MUserDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x01, 0x01, 0x03, 0x00, 0x00];
    /// <summary>
    /// SMPTE UL
    /// </summary>
    /// <remarks>
    /// SMPTE Universal Label Locators - the value is a UL in a public Registry
    /// </remarks>
    private static readonly byte[] SMPTEUniversalLabelLocator = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x01, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// SMS-OMB Communications Protocol
    /// </summary>
    /// <remarks>
    /// Elements defined as part of the SMS-OMB Communications protocol
    /// </remarks>
    private static readonly byte[] SMSOMBCommunicationsProtocol = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Snell &amp; Wilcox
    /// </summary>
    /// <remarks>
    /// Metadata registered by Snell &amp; Wilcox for private use
    /// </remarks>
    private static readonly byte[] Snell_and_Wilcox = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x0E, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Software-Only Support Flag
    /// </summary>
    /// <remarks>
    /// Plugin capable of running without hardware support
    /// </remarks>
    private static readonly byte[] SoftwareOnly = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x09, 0x0B, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Sony Corporation
    /// </summary>
    /// <remarks>
    /// Metadata registered by Sony Corporation for private use
    /// </remarks>
    private static readonly byte[] SonyCorporation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x06, 0x0E, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Audio Coding Scheme ID
    /// </summary>
    /// <remarks>
    /// Specifies the audio coding or compression scheme used as a UL
    /// </remarks>
    private static readonly byte[] SoundCompression = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x02, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Soundfield Group Link ID
    /// </summary>
    /// <remarks>
    /// MCA Link ID of the Soundfield Group to which this channel belongs
    /// </remarks>
    private static readonly byte[] SoundfieldGroupLinkID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x01, 0x03, 0x07, 0x01, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Source Container Format
    /// </summary>
    /// <remarks>
    /// Format of essence container prior to encryption as a UL
    /// </remarks>
    private static readonly byte[] SourceContainerFormat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x06, 0x01, 0x01, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Source Image Center X Coordinate (Pixels)
    /// </summary>
    /// <remarks>
    /// The x position of the centre of the captured (source) image expressed as x/y coordinates of the viewed image
    /// </remarks>
    private static readonly byte[] SourceImageCenterXCoordinatePixels = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x03, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Source Image Center Y Coordinate (Pixels)
    /// </summary>
    /// <remarks>
    /// The y position of the centre of the captured (source) image expressed as x/y coordinates of the viewed image
    /// </remarks>
    private static readonly byte[] SourceImageCenterYCoordinatePixels = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Source Index
    /// </summary>
    /// <remarks>
    /// Specifies a position or location within the referenced precursor
    /// </remarks>
    private static readonly byte[] SourceIndex = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x06, 0x01, 0x01, 0x03, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Source Key
    /// </summary>
    /// <remarks>
    /// Key of essence triplet prior to encryption
    /// </remarks>
    private static readonly byte[] SourceKey = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x06, 0x01, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Source Length
    /// </summary>
    /// <remarks>
    /// Length of the unencrypted value (V) in a KLV triplet
    /// </remarks>
    private static readonly byte[] SourceLength = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x04, 0x06, 0x10, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Source Organization
    /// </summary>
    /// <remarks>
    /// The name of the content supplying organization
    /// </remarks>
    private static readonly byte[] SourceOrganization = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Source Organization
    /// </summary>
    /// <remarks>
    /// The name of the content supplying organization
    /// </remarks>
    private static readonly byte[] SourceOrganization_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Source Package ID
    /// </summary>
    /// <remarks>
    /// Specifies the reference to a precursor
    /// </remarks>
    private static readonly byte[] SourcePackageID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Source Species
    /// </summary>
    /// <remarks>
    /// Specifies one or more metadata types to be extracted from the referenced precursor
    /// </remarks>
    private static readonly byte[] SourceSpecies = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x06, 0x01, 0x01, 0x03, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Source Track ID
    /// </summary>
    /// <remarks>
    /// Specifies the track within the referenced precursor
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] SourceTrackID_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x03, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Source Track ID
    /// </summary>
    /// <remarks>
    /// Identifies the Source Track ID of the PHDR Data Items
    /// Namespace: http://www.smpte-ra.org/reg/335/2012/14/9
    /// </remarks>
    private static readonly byte[] SourceTrackID_9 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x0E, 0x09, 0x06, 0x07, 0x01, 0x01, 0x01, 0x05];
    /// <summary>
    /// Source Value
    /// </summary>
    /// <remarks>
    /// Container for actual data of the referenced precursor
    /// </remarks>
    private static readonly byte[] SourceValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x06, 0x01, 0x01, 0x03, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Spatial
    /// </summary>
    /// <remarks>
    /// A set of attributes to provide spatial information
    /// </remarks>
    private static readonly byte[] spatial = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x14, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Spatial Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a spatial description object
    /// </remarks>
    private static readonly byte[] spatialObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x13, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// SPATIO-TEMPORAL
    /// </summary>
    /// <remarks>
    /// Class 7 is reserved for information about space and time
    /// </remarks>
    private static readonly byte[] SpatioTemporal = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Specification Identification
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] Specification_Identification = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x08, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Specification Identifiers
    /// </summary>
    /// <remarks>
    /// A set of AUIDs where each AUID identifies a "file format" "Block" to which the MXF file conforms. A "file format" "Block" is a "Block" (a Rules Framework Component) that is usually at (or close to) the root of a Rules-based Specification.
    /// </remarks>
    private static readonly byte[] Specification_Identifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x08, 0x01, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Specific Film Medium Parameters
    /// </summary>
    /// <remarks>
    /// Specific Information about the film medium
    /// </remarks>
    private static readonly byte[] SpecificFilmMediumParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x10, 0x01, 0x03, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Splicing Metadata
    /// </summary>
    /// <remarks>
    /// MPEG-2 splicing metadata as defined in SDTI-CP (E&amp;M) and SMPTE 312M
    /// </remarks>
    private static readonly byte[] SplicingMetadata = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x02, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Spoken Language Codes
    /// </summary>
    /// <remarks>
    /// Language Codes that represent the language used for speech
    /// </remarks>
    private static readonly byte[] SpokenLanguageCodes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x03, 0x01, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// ST 2109 Audio Metadata
    /// </summary>
    /// <remarks>
    /// ST 2109 Audio Metadata
    /// </remarks>
    private static readonly byte[] ST2109AudioMetadata = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x02, 0x09, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Stage Name Sets
    /// </summary>
    /// <remarks>
    /// The name given to the contact / person while on stage, e.g. a character name
    /// </remarks>
    private static readonly byte[] stageNameObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x22, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Qlty Start Of Modulation
    /// </summary>
    /// <remarks>
    /// Start of modulation of the original recording, in hours, minutes, seconds and tenths of a second
    /// </remarks>
    private static readonly byte[] StartModulation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x05, 0x02, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Start Time Relative to Reference
    /// </summary>
    /// <remarks>
    /// The relative start time from an origin within the track of a clip, expressed in edit units
    /// </remarks>
    private static readonly byte[] StartPosition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x07, 0x02, 0x01, 0x03, 0x01, 0x04, 0x00, 0x00];
    /// <summary>
    /// Start Time
    /// </summary>
    /// <remarks>
    /// Timestamp representing the beginning of the time window containing the requested security log events
    /// </remarks>
    private static readonly byte[] StartTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x21, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Start Timecode
    /// </summary>
    /// <remarks>
    /// The timecode within a track at the starting point of the essence
    /// </remarks>
    private static readonly byte[] StartTimecode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x07, 0x02, 0x01, 0x03, 0x01, 0x05, 0x00, 0x00];
    /// <summary>
    /// Start Timecode Relative to Reference
    /// </summary>
    /// <remarks>
    /// The relative start time of the segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] StartTimecodeRelativeToReference = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x03, 0x01, 0x02, 0x00, 0x00];
    /// <summary>
    /// Start Time Relative to Reference
    /// </summary>
    /// <remarks>
    /// The relative start time of the segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] StartTimeRelativeToReference_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x03, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// State or Province or County Name
    /// </summary>
    /// <remarks>
    /// The state, province or county of the address.
    /// </remarks>
    private static readonly byte[] StateProvinceCounty = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x06, 0x01];
    /// <summary>
    /// State or Province or County Name
    /// </summary>
    /// <remarks>
    /// The state, province or county of the address.
    /// </remarks>
    private static readonly byte[] StateProvinceCounty_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x06, 0x00];
    /// <summary>
    /// Status Group
    /// </summary>
    /// <remarks>
    /// A set of attributes used to define a status
    /// </remarks>
    private static readonly byte[] statusGroup = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Status Group Definition
    /// </summary>
    /// <remarks>
    /// A definition associated with the term
    /// </remarks>
    private static readonly byte[] statusGroupDefinition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x03, 0x05, 0x00, 0x00];
    /// <summary>
    /// Status Group Label
    /// </summary>
    /// <remarks>
    /// A universal label or free text to express the status
    /// </remarks>
    private static readonly byte[] statusGroupLabel = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x03, 0x02, 0x00, 0x00];
    /// <summary>
    /// Status Group Language Code
    /// </summary>
    /// <remarks>
    /// The BCP-47 code of the language used to express the term
    /// </remarks>
    private static readonly byte[] statusGroupLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x03, 0x06, 0x00, 0x00];
    /// <summary>
    /// Status Group Link
    /// </summary>
    /// <remarks>
    /// A link to a term in a classification scheme
    /// </remarks>
    private static readonly byte[] statusGroupLink = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x03, 0x03, 0x00, 0x00];
    /// <summary>
    /// Status Group Namespace
    /// </summary>
    /// <remarks>
    /// The namespace of the classification scheme
    /// </remarks>
    private static readonly byte[] statusGroupNamespace = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x03, 0x07, 0x00, 0x00];
    /// <summary>
    /// Status Group Source
    /// </summary>
    /// <remarks>
    /// The authority who has provided the classification scheme of free text term
    /// </remarks>
    private static readonly byte[] statusGroupSource = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x03, 0x08, 0x00, 0x00];
    /// <summary>
    /// Status Group Thesaurus
    /// </summary>
    /// <remarks>
    /// The thesaurus from which the status originates
    /// </remarks>
    private static readonly byte[] statusGroupThesaurus = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x03, 0x01, 0x00, 0x00];
    /// <summary>
    /// Status Group UL
    /// </summary>
    /// <remarks>
    /// A UL to a label in the label register
    /// </remarks>
    private static readonly byte[] statusGroupUL = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x03, 0x04, 0x00, 0x00];
    /// <summary>
    /// Status Response
    /// </summary>
    /// <remarks>
    /// General response info
    /// </remarks>
    private static readonly byte[] StatusResponse = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Stereoscopic Channel Identifiers
    /// </summary>
    /// <remarks>
    /// Identifiers relating to eye identification (left/right).
    /// </remarks>
    private static readonly byte[] StereoscopicChannelIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x01, 0x03, 0x07, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Stereoscopic Data Essence Coding
    /// </summary>
    /// <remarks>
    /// Specifies the data Essence coding type
    /// </remarks>
    private static readonly byte[] StereoscopicDataEssenceCoding = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x01, 0x03, 0x07, 0x03, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Stereoscopic Eye ID
    /// </summary>
    /// <remarks>
    /// Universal Label that identifies the eye
    /// </remarks>
    private static readonly byte[] StereoscopicEyeID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x01, 0x03, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Still Frame
    /// </summary>
    /// <remarks>
    /// Specifies a reference to a thumbnail representation of the essence
    /// </remarks>
    private static readonly byte[] StillFrame = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x02, 0x08, 0x00, 0x00];
    /// <summary>
    /// STL Line Number
    /// </summary>
    /// <remarks>
    /// The line number on which a specific language is being visible
    /// </remarks>
    private static readonly byte[] STLLineNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x03, 0x02, 0x01, 0x08, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// STL Reference Point Timecode
    /// </summary>
    /// <remarks>
    /// Specifies the Reference Point Timecode of the STL essence.
    /// </remarks>
    private static readonly byte[] STLReferencePointTimecode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x07, 0x02, 0x01, 0x02, 0x02, 0x02, 0x00, 0x00];
    /// <summary>
    /// Storage Characteristics
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] StorageCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Storage Device Kind
    /// </summary>
    /// <remarks>
    /// Describes the type of storage device
    /// </remarks>
    private static readonly byte[] StorageDeviceKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Storage Kind
    /// </summary>
    /// <remarks>
    /// The kind of storage expressed as a name - e.g. C.D.; D.V.D.; Betas SP
    /// </remarks>
    private static readonly byte[] StorageKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x0F, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Storage Kind
    /// </summary>
    /// <remarks>
    /// The kind of storage expressed as a name - e.g. C.D.; D.V.D.; Betas SP
    /// </remarks>
    private static readonly byte[] StorageKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x0F, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Storage Kind Code
    /// </summary>
    /// <remarks>
    /// The kind of storage expressed as a code
    /// </remarks>
    private static readonly byte[] StorageKindCode_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x0F, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Storage Media
    /// </summary>
    /// <remarks>
    /// Information about the storage media
    /// </remarks>
    private static readonly byte[] StorageMedia = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Storage Media ID
    /// </summary>
    /// <remarks>
    /// Uniquely identifies the storage media
    /// </remarks>
    private static readonly byte[] StorageMediaID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Storage Media Kind
    /// </summary>
    /// <remarks>
    /// Describes the type of storage media
    /// </remarks>
    private static readonly byte[] StorageMediaKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x05, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Storage Medium Parameters
    /// </summary>
    /// <remarks>
    /// Characteristics that describe the physical medium such as cartridge size
    /// </remarks>
    private static readonly byte[] StorageMediumParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Storage Offsets
    /// </summary>
    /// <remarks>
    /// Memory offset between current location and desired location
    /// </remarks>
    private static readonly byte[] StorageOffsets = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x08, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Storage Relationships
    /// </summary>
    /// <remarks>
    /// Relationships between data in persistent storage
    /// </remarks>
    private static readonly byte[] StorageRelationships = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x06, 0x08, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Stored ANC Line Number
    /// </summary>
    /// <remarks>
    /// The line number of this stored ANC packet according to SMPTE 377M-2004 E.1.5
    /// </remarks>
    private static readonly byte[] StoredANCLineNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x05, 0x02, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Stored F2 Offset
    /// </summary>
    /// <remarks>
    /// Topness Adjustment for stored picture
    /// </remarks>
    private static readonly byte[] StoredF2Offset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x01, 0x03, 0x02, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Stored Height
    /// </summary>
    /// <remarks>
    /// Specifies the integer height of the stored image in pixels
    /// </remarks>
    private static readonly byte[] StoredHeight = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Stored VBI Line Number
    /// </summary>
    /// <remarks>
    /// The line number of this stored VBI line according to SMPTE 377M-2004 E.1.5
    /// </remarks>
    private static readonly byte[] StoredVBILineNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x05, 0x02, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Stored Width
    /// </summary>
    /// <remarks>
    /// Specifies the integer width of the stored image in pixels
    /// </remarks>
    private static readonly byte[] StoredWidth = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Stratum
    /// </summary>
    /// <remarks>
    /// The descriptive stratum of the archival content analysis of the content
    /// </remarks>
    private static readonly byte[] Stratum = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Stratum Kind
    /// </summary>
    /// <remarks>
    /// eg.  Background, action, sound natures etc
    /// </remarks>
    private static readonly byte[] StratumKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x01, 0x07, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Stream and Storage Relationships
    /// </summary>
    /// <remarks>
    /// Relationships between data in streams and persistent storage
    /// </remarks>
    private static readonly byte[] StreamAndStorageRelationships = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x06, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Stream Element Type
    /// </summary>
    /// <remarks>
    /// Specifies a reference to the underlying character or integer type used in a stream type
    /// </remarks>
    private static readonly byte[] StreamElementType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x07, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// Stream ID
    /// </summary>
    /// <remarks>
    /// Organizationally given identifier that is the stream_id in ISO/IEC 13818-1 (MPEG-2 Systems)
    /// </remarks>
    private static readonly byte[] StreamID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x03, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Stream Offset
    /// </summary>
    /// <remarks>
    /// The offset of the edit unit within the container stream relative to the start of that container stream
    /// </remarks>
    private static readonly byte[] StreamOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x04, 0x04, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Stream Positional Relationships
    /// </summary>
    /// <remarks>
    /// Information to indicate the position of a packet in a stream of packets
    /// </remarks>
    private static readonly byte[] StreamPositionalRelationships = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x08, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Stream Position Indicator
    /// </summary>
    /// <remarks>
    /// Indicator for the position of a packet in a stream of packets
    /// </remarks>
    private static readonly byte[] StreamPositionIndicator_UInt16 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x08, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Stream Position Indicator
    /// </summary>
    /// <remarks>
    /// Indicator for the position of a packet in a stream of packets
    /// </remarks>
    private static readonly byte[] StreamPositionIndicator_UInt32 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x08, 0x01, 0x02, 0x01, 0x02, 0x00, 0x00];
    /// <summary>
    /// Stream Position Indicator
    /// </summary>
    /// <remarks>
    /// Indicator for the position of a packet in a stream of packets
    /// </remarks>
    private static readonly byte[] StreamPositionIndicator_UInt8 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x08, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Stream Relationships
    /// </summary>
    /// <remarks>
    /// Relationships between data in streams
    /// </remarks>
    private static readonly byte[] StreamRelationships = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x06, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Street Name
    /// </summary>
    /// <remarks>
    /// The street or thoroughfare name
    /// </remarks>
    private static readonly byte[] StreetName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x03, 0x01];
    /// <summary>
    /// Street Name
    /// </summary>
    /// <remarks>
    /// The street or thoroughfare name
    /// </remarks>
    private static readonly byte[] StreetName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x03, 0x00];
    /// <summary>
    /// Street Number
    /// </summary>
    /// <remarks>
    /// The alphanumeric street number of an address
    /// </remarks>
    private static readonly byte[] StreetNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x02, 0x01];
    /// <summary>
    /// Street Number
    /// </summary>
    /// <remarks>
    /// The alphanumeric street number of an address
    /// </remarks>
    private static readonly byte[] StreetNumber_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x04, 0x01, 0x02, 0x00];
    /// <summary>
    /// String Element Type
    /// </summary>
    /// <remarks>
    /// Specifies a reference to the underlying character or integer type used in a string type
    /// </remarks>
    private static readonly byte[] StringElementType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x07, 0x0F, 0x00, 0x00, 0x00];
    /// <summary>
    /// Strong References
    /// </summary>
    /// <remarks>
    /// References to a Contained Object
    /// </remarks>
    private static readonly byte[] StrongReferences = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Strong References Arrays
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] StrongReferencesArrays = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Strong References Batches
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] StrongReferencesBatches = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Strong References to Descriptive Metadata Batches
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] StrongReferencesToDescriptiveMetadataBatches = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x00, 0x00];
    /// <summary>
    /// Strong Referencing to Descriptive Metadata Sets
    /// </summary>
    /// <remarks>
    /// References to a Contained Object
    /// </remarks>
    private static readonly byte[] StrongReferencingToDescriptiveMetadataSets = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x01, 0x01, 0x04, 0x02, 0x40, 0x00, 0x00];
    /// <summary>
    /// Sub-descriptors
    /// </summary>
    /// <remarks>
    /// Specifies a vector of an ordered set of references to SubDescriptor sets
    /// </remarks>
    private static readonly byte[] SubDescriptors = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x06, 0x01, 0x01, 0x04, 0x06, 0x10, 0x00, 0x00];
    /// <summary>
    /// Subject
    /// </summary>
    /// <remarks>
    /// A subject associated with the resource
    /// </remarks>
    private static readonly byte[] subject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subject Absolute Heading
    /// </summary>
    /// <remarks>
    /// Defined by the absolute heading of the subject.  Expressed in degrees and tenths of degrees.
    /// </remarks>
    private static readonly byte[] SubjectAbsoluteHeading = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x03, 0x01, 0x02, 0x02, 0x00, 0x00];
    /// <summary>
    /// Subject Absolute Position
    /// </summary>
    /// <remarks>
    /// The absolute position of the subject depicted in the essence
    /// </remarks>
    private static readonly byte[] SubjectAbsolutePosition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subject Absolute Speed
    /// </summary>
    /// <remarks>
    /// Defined by the absolute speed of the subject along the heading, (default metres/second)
    /// </remarks>
    private static readonly byte[] SubjectAbsoluteSpeed = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x03, 0x01, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Subject Angles
    /// </summary>
    /// <remarks>
    /// Angles relating to the subject depicted in the captured essence
    /// </remarks>
    private static readonly byte[] SubjectAngles = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x10, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subject Attributor Entity Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an entity object to specify the authority attributing the subject
    /// </remarks>
    private static readonly byte[] subjectAttributorEntityObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x08, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subject Code
    /// </summary>
    /// <remarks>
    /// A code to express the subject associated with the resource
    /// </remarks>
    private static readonly byte[] subjectCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x08, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subject Definition Sets
    /// </summary>
    /// <remarks>
    /// A definition of the subject
    /// </remarks>
    private static readonly byte[] subjectDefinitionObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x08, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subject Dimensions
    /// </summary>
    /// <remarks>
    /// Physical measurements relating to the size of the subject depicted in the captured essence
    /// </remarks>
    private static readonly byte[] SubjectDimensions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x09, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subject Distance
    /// </summary>
    /// <remarks>
    /// Distance from the sensor to the center of interest on the framed subject depicted in the captured essence, (default metres)
    /// </remarks>
    private static readonly byte[] SubjectDistance = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x08, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subject Name
    /// </summary>
    /// <remarks>
    /// The Subject being indexed expressed as a Name.
    /// </remarks>
    private static readonly byte[] SubjectName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x01, 0x02, 0x04, 0x02, 0x00, 0x00];
    /// <summary>
    /// Subject Name
    /// </summary>
    /// <remarks>
    /// The Subject being indexed expressed as a Name.
    /// </remarks>
    private static readonly byte[] SubjectName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x01, 0x02, 0x04, 0x01, 0x00, 0x00];
    /// <summary>
    /// Subject Note
    /// </summary>
    /// <remarks>
    /// A note to provide additional contextual information
    /// </remarks>
    private static readonly byte[] subjectNote = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x08, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subject Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to one or more subjects
    /// </remarks>
    private static readonly byte[] subjectObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x02, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subject Rate and Direction of Positional Change
    /// </summary>
    /// <remarks>
    /// Information about the absolute rate and direction of positional change of the subject depicted in the captured essence
    /// </remarks>
    private static readonly byte[] SubjectRateAndDirectionOfPositionalChange = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x03, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subject Relative Heading
    /// </summary>
    /// <remarks>
    /// Defined by the relative heading of the subject.  Expressed in degrees and tenths of degrees.
    /// </remarks>
    private static readonly byte[] SubjectRelativeHeading = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x03, 0x02, 0x02, 0x02, 0x00, 0x00];
    /// <summary>
    /// Subject Relative Position
    /// </summary>
    /// <remarks>
    /// The position of the subject depicted in the essence relative to another specified datum
    /// </remarks>
    private static readonly byte[] SubjectRelativePosition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x02, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subject Relative Positional Accuracy
    /// </summary>
    /// <remarks>
    /// The accuracy with which the measurement of relative position of the subject is made,  (default metres)
    /// </remarks>
    private static readonly byte[] SubjectRelativePositionalAccuracy = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x02, 0x03, 0x01, 0x00, 0x00];
    /// <summary>
    /// Subject Relative Rate and Direction of Positional Change
    /// </summary>
    /// <remarks>
    /// Relative information about rate and direction of positional change of the subject depicted in the captured essence
    /// </remarks>
    private static readonly byte[] SubjectRelativeRateAndDirectionOfPositionalChange = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x03, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subject Relative Speed
    /// </summary>
    /// <remarks>
    /// Defined by the relative speed of the subject along the heading, (default metres/second)
    /// </remarks>
    private static readonly byte[] SubjectRelativeSpeed = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x03, 0x02, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Subject Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group to specify the type of subject being provided
    /// </remarks>
    private static readonly byte[] subjectTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x08, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subject Value Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to textual values of the subject associated to the media resource optionally in different languages
    /// </remarks>
    private static readonly byte[] subjectValueObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x08, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subtitle Datafile Flag
    /// </summary>
    /// <remarks>
    /// Flag indicating that a subtitle datfile exists.
    /// </remarks>
    private static readonly byte[] SubtitleDatafileFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subtitles Present
    /// </summary>
    /// <remarks>
    /// Indicates that program is subtitled
    /// </remarks>
    private static readonly byte[] SubtitlesPresent = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subtitling
    /// </summary>
    /// <remarks>
    /// Information about subtitles
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] Subtitling_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x03, 0x02, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subtitling
    /// </summary>
    /// <remarks>
    /// A set of attributes to describe subtitling in the material
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] Subtitling_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x37, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subtitling
    /// </summary>
    /// <remarks>
    /// Information about subtitling
    /// Namespace: http://www.smpte-ra.org/reg/335/2012/13/11
    /// </remarks>
    private static readonly byte[] Subtitling_11 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subtitling Format Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute format group to define the format of subtitling being used
    /// </remarks>
    private static readonly byte[] subtitlingFormatGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x37, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subtitling Format ID
    /// </summary>
    /// <remarks>
    /// An Identifier attributed to the subtitling format
    /// </remarks>
    private static readonly byte[] subtitlingFormatID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x37, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subtitling Format Name
    /// </summary>
    /// <remarks>
    /// A name attributed to the subtitling format
    /// </remarks>
    private static readonly byte[] subtitlingFormatName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x37, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subtitling Format Profile
    /// </summary>
    /// <remarks>
    /// To specify an encoding profile
    /// </remarks>
    private static readonly byte[] subtitlingFormatProfile = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x37, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subtitling Language Code
    /// </summary>
    /// <remarks>
    /// Codes assigned by RFC 5646 / BCP 47 for the identification of languages
    /// </remarks>
    private static readonly byte[] subtitlingLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x37, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subtitling  Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to subtitling objects
    /// </remarks>
    private static readonly byte[] subtitlingObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x35, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subtitling Presence Flag
    /// </summary>
    /// <remarks>
    /// A flag to indicate the presence of subtitling
    /// </remarks>
    private static readonly byte[] subtitlingPresenceFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x37, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subtitling Source Uri
    /// </summary>
    /// <remarks>
    /// A URI from where a subtitling  file (e.g. xml) can be accessed
    /// </remarks>
    private static readonly byte[] subtitlingSourceUri = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x37, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subtitling Track ID
    /// </summary>
    /// <remarks>
    /// An Identifier attributed to the subtitling track
    /// </remarks>
    private static readonly byte[] subtitlingTrackID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x37, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subtitling Track Name
    /// </summary>
    /// <remarks>
    /// A name attributed to the subtitling track
    /// </remarks>
    private static readonly byte[] subtitlingTrackName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x37, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Subtitling Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group to define the type of subtitling being used
    /// </remarks>
    private static readonly byte[] subtitlingTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x37, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Suffix
    /// </summary>
    /// <remarks>
    /// Jr, Sr.
    /// </remarks>
    private static readonly byte[] suffix = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x22, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// SUISA CISAC IPI
    /// </summary>
    /// <remarks>
    /// IP Identifiers allocated by CISAC
    /// </remarks>
    private static readonly byte[] SUISACISACIPI = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Supplementary Name
    /// </summary>
    /// <remarks>
    /// Supplementary naming information for a group
    /// </remarks>
    private static readonly byte[] SupplementaryName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x30, 0x06, 0x03, 0x02, 0x02, 0x01, 0x00];
    /// <summary>
    /// Supplementary Name
    /// </summary>
    /// <remarks>
    /// Supplementary naming information for a group
    /// </remarks>
    private static readonly byte[] SupplementaryName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x06, 0x03, 0x02, 0x02, 0x00, 0x00];
    /// <summary>
    /// Supplementary Organization Name
    /// </summary>
    /// <remarks>
    /// Supplementary naming information for an organization
    /// </remarks>
    private static readonly byte[] SupplementaryOrganizationName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x30, 0x06, 0x03, 0x03, 0x02, 0x01, 0x00];
    /// <summary>
    /// Supplementary Organization Name
    /// </summary>
    /// <remarks>
    /// Supplementary naming information for an organization
    /// </remarks>
    private static readonly byte[] SupplementaryOrganizationName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x06, 0x03, 0x03, 0x02, 0x00, 0x00];
    /// <summary>
    /// Supplier
    /// </summary>
    /// <remarks>
    /// Details of the content supplying organization
    /// </remarks>
    private static readonly byte[] Supplier = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Supplier Account Name
    /// </summary>
    /// <remarks>
    /// The name of the supplier account
    /// </remarks>
    private static readonly byte[] SupplierAccountName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x01, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Supplier Account Name
    /// </summary>
    /// <remarks>
    /// The name of the supplier account
    /// </remarks>
    private static readonly byte[] SupplierAccountName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Supplier Account Number
    /// </summary>
    /// <remarks>
    /// The number of the supplier account
    /// </remarks>
    private static readonly byte[] SupplierAccountNumber_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Supplier Identification Kind
    /// </summary>
    /// <remarks>
    /// The supplier identification type (e.g. bank Sort code)
    /// </remarks>
    private static readonly byte[] SupplierIdentificationKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Supplier Identification Value
    /// </summary>
    /// <remarks>
    /// The value of supplier identification
    /// </remarks>
    private static readonly byte[] SupplierIdentificationValue_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x01, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Supply Contract Number
    /// </summary>
    /// <remarks>
    /// The alphanumeric number for the contract for the supply of content
    /// </remarks>
    private static readonly byte[] SupplyContractNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Supplying Department Name
    /// </summary>
    /// <remarks>
    /// The name of the supplying department
    /// </remarks>
    private static readonly byte[] SupplyingDepartmentName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x02, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Support and Administration Details
    /// </summary>
    /// <remarks>
    /// Details of support and administative staff or contributors - business mangemenent, resource planning, archiving etc
    /// </remarks>
    private static readonly byte[] SupportAndAdministrationDetails = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Support and Administration Organization or Public Body
    /// </summary>
    /// <remarks>
    /// Details of support and administrative contribution (e.g., business management, resource planning, archiving etc)
    /// </remarks>
    private static readonly byte[] SupportAndAdministrationOrganizationOrPublicBody = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Supported DataEssenceCoding ULs
    /// </summary>
    /// <remarks>
    /// Batch of DataEssenceCoding ULs supported for playback by this device
    /// </remarks>
    private static readonly byte[] SupportedDataEssenceCodingULs = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x1E, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Support or Administration Status
    /// </summary>
    /// <remarks>
    /// Cataloguing staff, finance staff etc
    /// </remarks>
    private static readonly byte[] SupportOrAdministrationStatus = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x30, 0x01, 0x03, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Support or Administration Status
    /// </summary>
    /// <remarks>
    /// Cataloguing staff, finance staff etc
    /// </remarks>
    private static readonly byte[] SupportOrAdministrationStatus_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Support Organization Role
    /// </summary>
    /// <remarks>
    /// Role of support/administration organization (e.g., banker)
    /// </remarks>
    private static readonly byte[] SupportOrganizationRole = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x30, 0x02, 0x03, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Support Organization Role
    /// </summary>
    /// <remarks>
    /// Role of support/administration organization (e.g., banker)
    /// </remarks>
    private static readonly byte[] SupportOrganizationRole_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x02, 0x03, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Symbol Space URI
    /// </summary>
    /// <remarks>
    /// Namespace URI for the Extension Scheme
    /// </remarks>
    private static readonly byte[] SymbolSpaceURI = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x06, 0x01, 0x01, 0x07, 0x1C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Synchronization Locators
    /// </summary>
    /// <remarks>
    /// Media location information relating to synchronisation
    /// </remarks>
    private static readonly byte[] SynchronizationLocators = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x04, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// System Access
    /// </summary>
    /// <remarks>
    /// Details of permitted access to the technical system or platform
    /// </remarks>
    private static readonly byte[] SystemAccess = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// System Characteristics
    /// </summary>
    /// <remarks>
    /// Information about the integrated system used to acquire information
    /// </remarks>
    private static readonly byte[] SystemCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// System Interpretations
    /// </summary>
    /// <remarks>
    /// Interpretive information for common data systems
    /// </remarks>
    private static readonly byte[] SystemInterpretations = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// System Name or Number
    /// </summary>
    /// <remarks>
    /// A text string with the name or number of the integrated system of sensors or devices that acquired the data
    /// </remarks>
    private static readonly byte[] SystemNameOrNumber_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x30, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Assigned Category Name
    /// </summary>
    /// <remarks>
    /// Freeform textual name assigned by the user to a category - as in, for example, a column header
    /// </remarks>
    private static readonly byte[] Tag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x01, 0x02, 0x09, 0x01, 0x00, 0x00];
    /// <summary>
    /// Tagged Value Definitions
    /// </summary>
    /// <remarks>
    /// Specifies a unordered set of references to Tagged Value Definitions
    /// </remarks>
    private static readonly byte[] TaggedValueDefinitions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x06, 0x01, 0x01, 0x04, 0x05, 0x0B, 0x00, 0x00];
    /// <summary>
    /// Tagged Value Parent Properties
    /// </summary>
    /// <remarks>
    /// Specifies an unordered set of references to the definitions of properties which may contain this Tagged Value
    /// </remarks>
    private static readonly byte[] TaggedValueParentProperties = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x06, 0x01, 0x01, 0x04, 0x03, 0x05, 0x00, 0x00];
    /// <summary>
    /// Take Number
    /// </summary>
    /// <remarks>
    /// Take number of the instance of the shot
    /// </remarks>
    private static readonly byte[] TakeNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Tape Batch Number
    /// </summary>
    /// <remarks>
    /// Specifies the batch number of the tape
    /// </remarks>
    private static readonly byte[] TapeBatchNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x10, 0x01, 0x01, 0x06, 0x01, 0x00, 0x00];
    /// <summary>
    /// Tape Batch Number
    /// </summary>
    /// <remarks>
    /// Specifies the batch number of the tape
    /// </remarks>
    private static readonly byte[] TapeBatchNumber_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x10, 0x01, 0x01, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Tape Capacity
    /// </summary>
    /// <remarks>
    /// Specifies the tape capacity in minutes
    /// </remarks>
    private static readonly byte[] TapeCapacity = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x10, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Tape Format
    /// </summary>
    /// <remarks>
    /// Physical tape format from an enumerated list
    /// </remarks>
    private static readonly byte[] TapeFormat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x0D, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00];
    /// <summary>
    /// Tape Shell Kind
    /// </summary>
    /// <remarks>
    /// Specifies the cassette etc. shell - eg 1 inch B,  1 inch C,  90 minute Betacam,  DAT, 1/4 inch.
    /// </remarks>
    private static readonly byte[] TapeFormFactor = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x10, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Tape Formulation
    /// </summary>
    /// <remarks>
    /// Specifies the formulation of the tape - eg. Metal, oxide etc
    /// </remarks>
    private static readonly byte[] TapeFormulation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x10, 0x01, 0x01, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Tape Formulation
    /// </summary>
    /// <remarks>
    /// Specifies the formulation of the tape - eg. Metal, oxide etc
    /// </remarks>
    private static readonly byte[] TapeFormulation_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x10, 0x01, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Tape Identifiers
    /// </summary>
    /// <remarks>
    /// Tape identifiers
    /// </remarks>
    private static readonly byte[] TapeIdentifiers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x10, 0x04, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Tape Manufacturer
    /// </summary>
    /// <remarks>
    /// Specifies the tape manufacturer
    /// </remarks>
    private static readonly byte[] TapeManufacturer = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x10, 0x01, 0x01, 0x04, 0x01, 0x00, 0x00];
    /// <summary>
    /// Tape Manufacturer
    /// </summary>
    /// <remarks>
    /// Specifies the tape manufacturer
    /// </remarks>
    private static readonly byte[] TapeManufacturer_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x10, 0x01, 0x01, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Tape Medium Fundamental Parameters
    /// </summary>
    /// <remarks>
    /// Fundamental characteristics of Tape medium
    /// </remarks>
    private static readonly byte[] TapeMediumFundamentalParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x10, 0x01, 0x01, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// Tape Medium Parameters
    /// </summary>
    /// <remarks>
    /// Characteristics of Tape medium
    /// </remarks>
    private static readonly byte[] TapeMediumParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x10, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Tape Partition Capacity
    /// </summary>
    /// <remarks>
    /// The capacity of a tape partition in terms of the maximum number of megabytes which can be stored.
    /// </remarks>
    private static readonly byte[] TapePartitionCapacity = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x10, 0x01, 0x01, 0x10, 0x01, 0x00, 0x00];
    /// <summary>
    /// Tape Shell Kind
    /// </summary>
    /// <remarks>
    /// Specifies the cassette etc. shell - eg 1 inch B,  1 inch C,  90 minute Betacam,  DAT, 1/4 inch.
    /// </remarks>
    private static readonly byte[] TapeShellKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x10, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Tape Stock
    /// </summary>
    /// <remarks>
    /// Specifies the tape stock
    /// </remarks>
    private static readonly byte[] TapeStock = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x10, 0x01, 0x01, 0x05, 0x01, 0x00, 0x00];
    /// <summary>
    /// Tape Stock
    /// </summary>
    /// <remarks>
    /// Specifies the tape stock
    /// </remarks>
    private static readonly byte[] TapeStock_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x10, 0x01, 0x01, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Target Audience
    /// </summary>
    /// <remarks>
    /// Target audience (e.g., children, 17 to 32, elderly, ...)
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] TargetAudience_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x01, 0x01, 0x04, 0x01, 0x00, 0x00];
    /// <summary>
    /// Target Audience
    /// </summary>
    /// <remarks>
    /// The target audience or audience level for which a media resource has been commissioned
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] TargetAudience_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x11, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Target Audience
    /// </summary>
    /// <remarks>
    /// Target audience (e.g., children, 17 to 32, elderly, ...)
    /// </remarks>
    private static readonly byte[] TargetAudience_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x01, 0x01, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Target Audience Adult Content Flag
    /// </summary>
    /// <remarks>
    /// A flag to signal if this is adult content ("1" for true) or not
    /// </remarks>
    private static readonly byte[] targetAudienceAdultContentFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x11, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Target Audience Exclusion Region Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to regions defining the geographical scope within which the target classification does not apply
    /// </remarks>
    private static readonly byte[] targetAudienceExclusionRegionObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x11, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Target Audience Format Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute format group to further specify the format used to express target classification
    /// </remarks>
    private static readonly byte[] targetAudienceFormatGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x11, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Target Audience Link To Logo
    /// </summary>
    /// <remarks>
    /// A locator to a visual representation of the classification
    /// </remarks>
    private static readonly byte[] targetAudienceLinkToLogo = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x11, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Target Audience Not Rated Flag
    /// </summary>
    /// <remarks>
    /// A flag to signal if the content has not been rated ("1" for true)
    /// </remarks>
    private static readonly byte[] targetAudienceNotRatedFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x11, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Target Audience Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to one or more target audiences / levels associated with the resource
    /// </remarks>
    private static readonly byte[] targetAudienceObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0E, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Target Audience Reason
    /// </summary>
    /// <remarks>
    /// Free text to explain the reason for this classification
    /// </remarks>
    private static readonly byte[] targetAudienceReason = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x11, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Target Audience Region Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to regions defining the geographical scope within which the target classification applies
    /// </remarks>
    private static readonly byte[] targetAudienceRegionObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x11, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Target Audience Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group to further specify the type of target classification
    /// </remarks>
    private static readonly byte[] targetAudienceTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x11, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Targeted System Display Actual Peak Luminance
    /// </summary>
    /// <remarks>
    /// Two-input sampled function representing the normalized actual peak luminance of the targeted system display, in units of 1/15. The four most significant bits in each UInt8 are zero.
    /// </remarks>
    private static readonly byte[] TargetedSystemDisplayActualPeakLuminance = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x36, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Targeted System Display Maximum Luminance
    /// </summary>
    /// <remarks>
    /// Maximum luminance of the targeted system's display
    /// </remarks>
    private static readonly byte[] TargetedSystemDisplayMaximumLuminance = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x0B, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Targeted System Display Minimum Luminance
    /// </summary>
    /// <remarks>
    /// Minimum luminance of the targeted system's display
    /// </remarks>
    private static readonly byte[] TargetedSystemDisplayMinimumLuminance = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x0C, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Targeted System Display Primaries
    /// </summary>
    /// <remarks>
    /// xy chromaticity coordinates of the three primaries of the targeted system display
    /// </remarks>
    private static readonly byte[] TargetedSystemDisplayPrimaries = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x09, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Targeted System Display Signal Format
    /// </summary>
    /// <remarks>
    /// Enumerator of the signal format of the targeted system display
    /// </remarks>
    private static readonly byte[] TargetedSystemDisplaySignalFormat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x27, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Targeted System Display White Point Chromaticity
    /// </summary>
    /// <remarks>
    /// xy chromaticity coordinate of the targeted system display's white point
    /// </remarks>
    private static readonly byte[] TargetedSystemDisplayWhitePointChromaticity = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x0A, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Target Frame Ancillary ResourceID
    /// </summary>
    /// <remarks>
    /// UUID value that identifies the ancillary resource
    /// </remarks>
    private static readonly byte[] TargetFrameAncillaryResourceID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x09, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Target Frame Color Primaries
    /// </summary>
    /// <remarks>
    /// The set of color primaries used
    /// </remarks>
    private static readonly byte[] TargetFrameColorPrimaries = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x09, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Target Frame Component Max Ref
    /// </summary>
    /// <remarks>
    /// Maximum value for RGB components, e.g. 60160 or 65535 (16 bits)
    /// </remarks>
    private static readonly byte[] TargetFrameComponentMaxRef = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x09, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Target Frame Component Min Ref
    /// </summary>
    /// <remarks>
    /// Minimum value for RGB components, e.g. 0 or 4096 (16 bits)
    /// </remarks>
    private static readonly byte[] TargetFrameComponentMinRef = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x09, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Target Frame Essence StreamID
    /// </summary>
    /// <remarks>
    /// Essence (or its container) stream ID
    /// </remarks>
    private static readonly byte[] TargetFrameEssenceStreamID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x09, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Target Frame Index
    /// </summary>
    /// <remarks>
    /// Specifies the offset of the corresponding frame in the image essence
    /// </remarks>
    private static readonly byte[] TargetFrameIndex = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x09, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Target Frame Parameters
    /// </summary>
    /// <remarks>
    /// Information about Target Frames
    /// </remarks>
    private static readonly byte[] TargetFrameParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x09, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Target Frame Transfer Characteristic
    /// </summary>
    /// <remarks>
    /// Specifies the non-linear relationship between linear scene light levels and amplitude-compressed video signal levels
    /// </remarks>
    private static readonly byte[] TargetFrameTransferCharacteristic = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x09, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Target Frame Viewing Environment
    /// </summary>
    /// <remarks>
    /// Specifies a Viewing Environment for a Target Frame
    /// </remarks>
    private static readonly byte[] TargetFrameViewingEnvironment = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x09, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Target Set
    /// </summary>
    /// <remarks>
    /// The path to the object which contains the target
    /// </remarks>
    private static readonly byte[] TargetSet = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x02, 0x03, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Target Width
    /// </summary>
    /// <remarks>
    /// Horizontal half width of the target frame image; used to compute the four corner points of the frame, (default metres)
    /// </remarks>
    private static readonly byte[] TargetWidth = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x09, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute AnyURI
    /// </summary>
    /// <remarks>
    /// A technical attribute of type Unique Resource Identifier
    /// </remarks>
    private static readonly byte[] technicalAttributeAnyURI = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute AnyURI Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a type group to define the name of the technical attribute
    /// </remarks>
    private static readonly byte[] technicalAttributeAnyURITypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x0C, 0x02, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute AnyURIValue
    /// </summary>
    /// <remarks>
    /// The value expressed as a Unique Resource Identifier
    /// </remarks>
    private static readonly byte[] technicalAttributeAnyURIValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x0C, 0x01, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute Boolean
    /// </summary>
    /// <remarks>
    /// A technical attribute of type boolean
    /// </remarks>
    private static readonly byte[] technicalAttributeBoolean = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute Boolean Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a type group to define the name of the technical attribute
    /// </remarks>
    private static readonly byte[] technicalAttributeBooleanTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x0D, 0x02, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute BooleanValue
    /// </summary>
    /// <remarks>
    /// The value expressed as a boolean
    /// </remarks>
    private static readonly byte[] technicalAttributeBooleanValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x0D, 0x01, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute Float
    /// </summary>
    /// <remarks>
    /// A technical attribute of type float
    /// </remarks>
    private static readonly byte[] technicalAttributeFloat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute Float Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a type group to define the name of the technical attribute
    /// </remarks>
    private static readonly byte[] technicalAttributeFloatTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x0A, 0x02, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute Float Unit
    /// </summary>
    /// <remarks>
    /// The unit of the technical attribute
    /// </remarks>
    private static readonly byte[] technicalAttributeFloatUnit = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x0A, 0x03, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute FloatValue
    /// </summary>
    /// <remarks>
    /// The value expressed as a float
    /// </remarks>
    private static readonly byte[] technicalAttributeFloatValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x0A, 0x01, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute Int16
    /// </summary>
    /// <remarks>
    /// A technical attribute of type short
    /// </remarks>
    private static readonly byte[] technicalAttributeInt16 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute Int16 Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a type group to define the name of the technical attribute
    /// </remarks>
    private static readonly byte[] technicalAttributeInt16TypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x03, 0x02, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute Int16 Unit
    /// </summary>
    /// <remarks>
    /// The unit of the technical attribute
    /// </remarks>
    private static readonly byte[] technicalAttributeInt16Unit = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x03, 0x03, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute Int16Value
    /// </summary>
    /// <remarks>
    /// The value expressed as a short
    /// </remarks>
    private static readonly byte[] technicalAttributeInt16Value = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x03, 0x01, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute Int32
    /// </summary>
    /// <remarks>
    /// A technical attribute of type integer
    /// </remarks>
    private static readonly byte[] technicalAttributeInt32 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute Int32 Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a type group to define the name of the technical attribute
    /// </remarks>
    private static readonly byte[] technicalAttributeInt32TypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x04, 0x02, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute Int32 Unit
    /// </summary>
    /// <remarks>
    /// The unit of the technical attribute
    /// </remarks>
    private static readonly byte[] technicalAttributeInt32Unit = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x04, 0x03, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute Int32Value
    /// </summary>
    /// <remarks>
    /// The value expressed as an integer
    /// </remarks>
    private static readonly byte[] technicalAttributeInt32Value = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x04, 0x01, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute Int64
    /// </summary>
    /// <remarks>
    /// A technical attribute of type long
    /// </remarks>
    private static readonly byte[] technicalAttributeInt64 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute Int64 Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a type group to define the name of the technical attribute
    /// </remarks>
    private static readonly byte[] technicalAttributeInt64TypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x05, 0x02, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute Int64 Unit
    /// </summary>
    /// <remarks>
    /// The unit of the technical attribute
    /// </remarks>
    private static readonly byte[] technicalAttributeInt64Unit = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x05, 0x03, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute Int64Value
    /// </summary>
    /// <remarks>
    /// The value expressed as a long
    /// </remarks>
    private static readonly byte[] technicalAttributeInt64Value = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x05, 0x01, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute Int8
    /// </summary>
    /// <remarks>
    /// A technical attribute of type byte
    /// </remarks>
    private static readonly byte[] technicalAttributeInt8 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute Int8 Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a type group to define the name of the technical attribute
    /// </remarks>
    private static readonly byte[] technicalAttributeInt8TypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x02, 0x02, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute Int8 Unit
    /// </summary>
    /// <remarks>
    /// The unit of the technical attribute
    /// </remarks>
    private static readonly byte[] technicalAttributeInt8Unit = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x02, 0x03, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute Int8Value
    /// </summary>
    /// <remarks>
    /// The value expressed as a byte
    /// </remarks>
    private static readonly byte[] technicalAttributeInt8Value = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute Rational
    /// </summary>
    /// <remarks>
    /// A technical attribute of type rational
    /// </remarks>
    private static readonly byte[] technicalAttributeRational = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute Rational Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a type group to define the name of the technical attribute
    /// </remarks>
    private static readonly byte[] technicalAttributeRationalTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x0B, 0x01, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute Rational Value
    /// </summary>
    /// <remarks>
    /// A strong reference to a rational
    /// </remarks>
    private static readonly byte[] technicalAttributeRationalValueObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x0B, 0x02, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute String
    /// </summary>
    /// <remarks>
    /// A technical attribute of type string
    /// </remarks>
    private static readonly byte[] technicalAttributeString = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute String Format Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a type group to define the format  of the string technical attribute
    /// </remarks>
    private static readonly byte[] technicalAttributeStringFormatGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x01, 0x03, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute String Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a type group to define the name of the technical attribute
    /// </remarks>
    private static readonly byte[] technicalAttributeStringTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x01, 0x02, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute StringValue
    /// </summary>
    /// <remarks>
    /// The value expressed as a string
    /// </remarks>
    private static readonly byte[] technicalAttributeStringValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute UInt16
    /// </summary>
    /// <remarks>
    /// A technical attribute of type unsigned short
    /// </remarks>
    private static readonly byte[] technicalAttributeUInt16 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute UInt16 Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a type group to define the name of the technical attribute
    /// </remarks>
    private static readonly byte[] technicalAttributeUInt16TypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x07, 0x02, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute UInt16 Unit
    /// </summary>
    /// <remarks>
    /// The unit of the technical attribute
    /// </remarks>
    private static readonly byte[] technicalAttributeUInt16Unit = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x07, 0x03, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute UInt16Value
    /// </summary>
    /// <remarks>
    /// The value expressed as an unsigned short
    /// </remarks>
    private static readonly byte[] technicalAttributeUInt16Value = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x07, 0x01, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute UInt32
    /// </summary>
    /// <remarks>
    /// A technical attribute of type unsigned integer
    /// </remarks>
    private static readonly byte[] technicalAttributeUInt32 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute UInt32 Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a type group to define the name of the technical attribute
    /// </remarks>
    private static readonly byte[] technicalAttributeUInt32TypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x08, 0x02, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute UInt32 Unit
    /// </summary>
    /// <remarks>
    /// The unit of the technical attribute
    /// </remarks>
    private static readonly byte[] technicalAttributeUInt32Unit = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x08, 0x03, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute UInt32Value
    /// </summary>
    /// <remarks>
    /// The value expressed as an unsigned integer
    /// </remarks>
    private static readonly byte[] technicalAttributeUInt32Value = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x08, 0x01, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute UInt64
    /// </summary>
    /// <remarks>
    /// A technical attribute of type unsigned long
    /// </remarks>
    private static readonly byte[] technicalAttributeUInt64 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute UInt64 Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a type group to define the name of the technical attribute
    /// </remarks>
    private static readonly byte[] technicalAttributeUInt64TypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x09, 0x02, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute UInt64 Unit
    /// </summary>
    /// <remarks>
    /// The unit of the technical attribute
    /// </remarks>
    private static readonly byte[] technicalAttributeUInt64Unit = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x09, 0x03, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute UInt64Value
    /// </summary>
    /// <remarks>
    /// The value expressed as an unsigned long
    /// </remarks>
    private static readonly byte[] technicalAttributeUInt64Value = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x09, 0x01, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute UInt8
    /// </summary>
    /// <remarks>
    /// A technical attribute of type unsigned byte
    /// </remarks>
    private static readonly byte[] technicalAttributeUInt8 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute UInt8 Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a type group to define the name of the technical attribute
    /// </remarks>
    private static readonly byte[] technicalAttributeUInt8TypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x06, 0x02, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute UInt8 Unit
    /// </summary>
    /// <remarks>
    /// The unit of the technical attribute
    /// </remarks>
    private static readonly byte[] technicalAttributeUInt8Unit = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x06, 0x03, 0x00, 0x00];
    /// <summary>
    /// Technical Attribute UInt8Value
    /// </summary>
    /// <remarks>
    /// The value expressed as an unsigned byte
    /// </remarks>
    private static readonly byte[] technicalAttributeUInt8Value = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x06, 0x01, 0x00, 0x00];
    /// <summary>
    /// Technical Basic Attributes
    /// </summary>
    /// <remarks>
    /// A group of definitions of technical attributes of basic data types
    /// </remarks>
    private static readonly byte[] technicalBasicDatatypes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x3A, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Technical Comments and Descriptions
    /// </summary>
    /// <remarks>
    /// Technical comments or descriptions relating to system
    /// </remarks>
    private static readonly byte[] TechnicalCommentsAndDescriptions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Technical Value
    /// </summary>
    /// <remarks>
    /// Assessment of the technical value
    /// </remarks>
    private static readonly byte[] TechnicalValue_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x02, 0x02, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Telephone Number
    /// </summary>
    /// <remarks>
    /// Telephone number
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] TelephoneNumber_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x20, 0x01, 0x10, 0x03, 0x01, 0x00];
    /// <summary>
    /// Telephone Number
    /// </summary>
    /// <remarks>
    /// A telephone number
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] TelephoneNumber_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x25, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Telephone Number
    /// </summary>
    /// <remarks>
    /// Telephone number
    /// </remarks>
    private static readonly byte[] TelephoneNumber_UTF16String = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x20, 0x01, 0x10, 0x03, 0x01, 0x01];
    /// <summary>
    /// Teletext Subtitles Available
    /// </summary>
    /// <remarks>
    /// Indicates that teletext subtitles for the deaf or hearing impaired are available
    /// </remarks>
    private static readonly byte[] TeletextSubtitlesAvailable = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x06, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Teletext Subtitles Flag
    /// </summary>
    /// <remarks>
    /// Flag indicating that teletext subtitles exist.
    /// </remarks>
    private static readonly byte[] TeletextSubtitlesFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Temporal
    /// </summary>
    /// <remarks>
    /// Information about temporal information
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] Temporal_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Temporal
    /// </summary>
    /// <remarks>
    /// A set of attributes to provide temporal information (time, period of time, event)
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] Temporal_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x17, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Temporal Characteristics
    /// </summary>
    /// <remarks>
    /// Information about temporal characteristics of processes
    /// </remarks>
    private static readonly byte[] TemporalCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Temporal Definition Note
    /// </summary>
    /// <remarks>
    /// A note to provide additional contextual information
    /// </remarks>
    private static readonly byte[] temporalDefinitionNote = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x17, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Temporal Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a temporal description object
    /// </remarks>
    private static readonly byte[] temporalObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x13, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Temporal Offset
    /// </summary>
    /// <remarks>
    /// The number of edit units by which this edit unit has been moved in the bitstream for the purpose of temporal reordering (e.g. MPEG)
    /// </remarks>
    private static readonly byte[] TemporalOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x04, 0x04, 0x04, 0x02, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Temporal Parameters
    /// </summary>
    /// <remarks>
    /// Time dependant sequencing and scanning information
    /// </remarks>
    private static readonly byte[] TemporalParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Temporal Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group to define the type of temporal information being provided
    /// </remarks>
    private static readonly byte[] temporalTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x17, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Terminating Filler Data
    /// </summary>
    /// <remarks>
    /// Specifies an empty data element specifically intended to flag the end of a package of Metadata.  Value may be application dependant.
    /// </remarks>
    private static readonly byte[] TerminatingFillerData = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x02, 0x10, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Text
    /// </summary>
    /// <remarks>
    /// Free text in a textual annotation
    /// </remarks>
    private static readonly byte[] text = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2E, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Text-Based Descriptive Metadata Sets
    /// </summary>
    /// <remarks>
    /// Text-Based Descriptive Metadata Sets
    /// </remarks>
    private static readonly byte[] TextBasedDescriptiveMetadataSets = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x06, 0x01, 0x01, 0x04, 0x05, 0x41, 0x00, 0x00];
    /// <summary>
    /// Text-Based Metadata Payload Scheme Identifier
    /// </summary>
    /// <remarks>
    /// Unique identifier for text-based payload scheme.
    /// </remarks>
    private static readonly byte[] TextBasedMetadataPayloadSchemeID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x06, 0x08, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Text-Based Object
    /// </summary>
    /// <remarks>
    /// Instance UID of the instance of a Text-based Object. This may be a Generic Stream Text-based Set, a UTF-8 Text-based Set or a UTF-16 Text-based Set.
    /// </remarks>
    private static readonly byte[] TextBasedObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x06, 0x01, 0x01, 0x04, 0x05, 0x41, 0x01, 0x00];
    /// <summary>
    /// Text Data
    /// </summary>
    /// <remarks>
    /// Text Data
    /// </remarks>
    private static readonly byte[] TextData = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x03, 0x01, 0x02, 0x20, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Text Data Description
    /// </summary>
    /// <remarks>
    /// A freeform text description.
    /// </remarks>
    private static readonly byte[] TextDataDescription = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x03, 0x02, 0x01, 0x06, 0x03, 0x02, 0x00, 0x00];
    /// <summary>
    /// Text Language Code
    /// </summary>
    /// <remarks>
    /// Codes assigned by RFC 5646 /BCP 47  for the identification of languages. The language in which the annotation is expressed
    /// </remarks>
    private static readonly byte[] textLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2E, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Text Language Codes
    /// </summary>
    /// <remarks>
    /// Language Codes that represent the language used for text
    /// </remarks>
    private static readonly byte[] TextLanguageCodes = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x03, 0x01, 0x01, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Textless Black Duration
    /// </summary>
    /// <remarks>
    /// eg.  1 minutes after end of program
    /// </remarks>
    private static readonly byte[] TextlessBlackDuration = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x02, 0x01, 0x02, 0x03, 0x00, 0x00];
    /// <summary>
    /// Textless Material
    /// </summary>
    /// <remarks>
    /// Indicates that the program is textless
    /// </remarks>
    private static readonly byte[] TextlessMaterial = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Text MIME Media Type
    /// </summary>
    /// <remarks>
    /// Specifies the MIME media type as defined by IETF.
    /// </remarks>
    private static readonly byte[] TextMIMEMediaType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x09, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Text Time
    /// </summary>
    /// <remarks>
    /// Time expressed as free text
    /// </remarks>
    private static readonly byte[] textTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x58, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Textual Annotation
    /// </summary>
    /// <remarks>
    /// A set of attributes to provide a a textual annotation
    /// </remarks>
    private static readonly byte[] textualAnnotation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2E, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Textual Date Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to dates in free text e.g. "April 18th, 2014"
    /// </remarks>
    private static readonly byte[] textualDateObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0D, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Textual Description
    /// </summary>
    /// <remarks>
    /// A textual characterization of the data set.
    /// </remarks>
    private static readonly byte[] TextualDescription = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x01, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Textual Description Kind
    /// </summary>
    /// <remarks>
    /// A summary of the use for which the description was made - e.g. billings, the production companies original description, a full production description etc)
    /// </remarks>
    private static readonly byte[] TextualDescriptionKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x01, 0x06, 0x07, 0x01, 0x00, 0x00];
    /// <summary>
    /// Textual Description Kind
    /// </summary>
    /// <remarks>
    /// A summary of the use for which the description was made - e.g. billings, the production companies original description, a full production description etc)
    /// </remarks>
    private static readonly byte[] TextualDescriptionKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x01, 0x06, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Theme
    /// </summary>
    /// <remarks>
    /// The category of the Theme of the content
    /// </remarks>
    private static readonly byte[] Theme = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x02, 0x01, 0x02, 0x03, 0x01, 0x00, 0x00];
    /// <summary>
    /// Theme
    /// </summary>
    /// <remarks>
    /// The category of the Theme of the content
    /// </remarks>
    private static readonly byte[] Theme_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Theme Music Flag
    /// </summary>
    /// <remarks>
    /// Indicates that the associated music is theme music
    /// </remarks>
    private static readonly byte[] ThemeMusicFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x05, 0x01, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Thesaurus Name
    /// </summary>
    /// <remarks>
    /// The name of a specialized vocabulary of selected words or concepts for a particular field, e.g. a particular cataloguing, indexing or thesaurus system
    /// </remarks>
    private static readonly byte[] ThesaurusName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x03, 0x02, 0x01, 0x02, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Thesaurus Name
    /// </summary>
    /// <remarks>
    /// The name of a specialized vocabulary of selected words or concepts for a particular field, e.g. a particular cataloguing, indexing or thesaurus system
    /// </remarks>
    private static readonly byte[] ThesaurusName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x01, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Third Given Name
    /// </summary>
    /// <remarks>
    /// The third given name for an individual
    /// </remarks>
    private static readonly byte[] ThirdGivenName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x30, 0x06, 0x03, 0x01, 0x04, 0x01, 0x00];
    /// <summary>
    /// Third Given Name
    /// </summary>
    /// <remarks>
    /// The third given name for an individual
    /// </remarks>
    private static readonly byte[] ThirdGivenName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x30, 0x06, 0x03, 0x01, 0x04, 0x00, 0x00];
    /// <summary>
    /// This Partition
    /// </summary>
    /// <remarks>
    /// The number of this Partition in the sequence of Partitions (as a byte offset relative to the start of the Header Partition)
    /// </remarks>
    private static readonly byte[] ThisPartition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x06, 0x10, 0x10, 0x03, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// 3ality Technica
    /// </summary>
    /// <remarks>
    /// Metadata registered by 3ality Technica for private use
    /// </remarks>
    private static readonly byte[] ThreealityTechnica = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x0E, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// TIFF Bits Per Sample  Array
    /// </summary>
    /// <remarks>
    /// Array of the number of bits allocated for each component in an uncompressed pixel, where n = Number of components per pixel. Shall be encoded as defined for BitsPerSample in ISO 12234-2
    /// </remarks>
    private static readonly byte[] TIFFBitsPerSampleArray = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x06, 0x05, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// TIFF Byte Order
    /// </summary>
    /// <remarks>
    /// Byte order of the essence data. Shall be 'MM' = Big endian or 'II' = Little endian
    /// </remarks>
    private static readonly byte[] TIFFByteOrder = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x06, 0x05, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// TIFF Coding Parameters
    /// </summary>
    /// <remarks>
    /// Information about TIFF picture coding
    /// </remarks>
    private static readonly byte[] TIFFCodingParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x06, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// TIFF Compression Kind
    /// </summary>
    /// <remarks>
    /// Compression scheme used to store the image data. Shall be 1 = No compression or 7 = Lossless Huffman JPEG compression. Shall be encoded as defined for Compression in ISO 12234-2
    /// </remarks>
    private static readonly byte[] TIFFCompressionKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x06, 0x05, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// TIFF JPEG Processing
    /// </summary>
    /// <remarks>
    /// TIFF JPEG processing performed on the  essence
    /// </remarks>
    private static readonly byte[] TIFFJPEGProcessing = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x02, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// TIFF Light Source Kind
    /// </summary>
    /// <remarks>
    /// Predominant light source (scene illuminant) present when the image was captured, or its color temperature. Shall be encoded as defined for LightSource in ISO 12234-2
    /// </remarks>
    private static readonly byte[] TIFFLightSourceKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x06, 0x05, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// TIFF Orientation
    /// </summary>
    /// <remarks>
    /// Orientation of the camera relative to the scene, when the image was captured. Shall be encoded as defined for Orientation in ISO 12234-2.
    /// </remarks>
    private static readonly byte[] TIFFOrientation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x06, 0x05, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// TIFF Photometric Interpretation Kind
    /// </summary>
    /// <remarks>
    /// Color space and order of image data components. Shall be 32803 = Color Filter Array or 34892 = Linear Raw. Shall be encoded as defined for PhotometricInterpretation in ISO 12234-2
    /// </remarks>
    private static readonly byte[] TIFFPhotometricInterpretationKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x06, 0x05, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// TIFF Samples Per Pixel
    /// </summary>
    /// <remarks>
    /// Number of components (n) per pixel. Shall be 1 for Photometric Interpretation = 32083 or 3 for PhotometricInterpretation = 34892. Shall be encoded as defined for SamplesPerPixel in ISO 12234-2
    /// </remarks>
    private static readonly byte[] TIFFSamplesPerPixel = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x06, 0x05, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// TIFF Summary
    /// </summary>
    /// <remarks>
    /// Summary info according to TIFF format
    /// </remarks>
    private static readonly byte[] TIFFSummary = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x03, 0x02, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Time
    /// </summary>
    /// <remarks>
    /// Descriptive information about Time (Default is UTC system).
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] Time_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Time
    /// </summary>
    /// <remarks>
    /// A structure to define time
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] Time_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x58, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timebase Reference Track ID
    /// </summary>
    /// <remarks>
    /// Specifies the value of the Track ID of the target Track in the Material Package that provides the Edit Rate.
    /// </remarks>
    private static readonly byte[] TimebaseReferenceTrackID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x06, 0x01, 0x01, 0x03, 0x0E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timecode
    /// </summary>
    /// <remarks>
    /// Time expressed as timecode
    /// </remarks>
    private static readonly byte[] timecode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x58, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timecode Array
    /// </summary>
    /// <remarks>
    /// An ordered array of Timecodes with individual timecode packets as specified in SMPTE 331M, section 8.2.
    /// </remarks>
    private static readonly byte[] TimecodeArray = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x07, 0x02, 0x01, 0x02, 0x08, 0x02, 0x00, 0x00];
    /// <summary>
    /// Timecode Characteristics
    /// </summary>
    /// <remarks>
    /// Characteristics of timecode metadata
    /// </remarks>
    private static readonly byte[] TimecodeCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timecode Creation Date-Time
    /// </summary>
    /// <remarks>
    /// Identifies date and time at the point of creation.
    /// </remarks>
    private static readonly byte[] TimecodeCreationDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x10, 0x01, 0x02, 0x00, 0x00];
    /// <summary>
    /// Timecode End Date-Time
    /// </summary>
    /// <remarks>
    /// Media time at end of segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] TimecodeEndDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x02, 0x04, 0x01, 0x00, 0x00];
    /// <summary>
    /// Timecode Event End Date-Time
    /// </summary>
    /// <remarks>
    /// The absolute ending date and time of the project, mission, scene, editing event, license, publication etc
    /// </remarks>
    private static readonly byte[] TimecodeEventEndDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x02, 0x0A, 0x01, 0x00, 0x00];
    /// <summary>
    /// Timecode Event Start Date-Time
    /// </summary>
    /// <remarks>
    /// The absolute beginning date and time of the project, mission, scene, editing event, license, publication etc
    /// </remarks>
    private static readonly byte[] TimecodeEventStartDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x02, 0x08, 0x01, 0x00, 0x00];
    /// <summary>
    /// Timecode Format
    /// </summary>
    /// <remarks>
    /// A structure to define the characteristics of a timecode track
    /// </remarks>
    private static readonly byte[] timecodeFormat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5A, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timecode Format Definition
    /// </summary>
    /// <remarks>
    /// A definition of a timecode format
    /// </remarks>
    private static readonly byte[] timecodeFormatDefinition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5A, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timecode Format Id
    /// </summary>
    /// <remarks>
    /// The identifier of a timecode format
    /// </remarks>
    private static readonly byte[] timecodeFormatId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5A, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timecode Format Name
    /// </summary>
    /// <remarks>
    /// The name of a timecode format
    /// </remarks>
    private static readonly byte[] timecodeFormatName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5A, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timecode Format Version Id
    /// </summary>
    /// <remarks>
    /// The version identifier of a timecode format
    /// </remarks>
    private static readonly byte[] timecodeFormatVersionId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5A, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timecode Kind
    /// </summary>
    /// <remarks>
    /// eg. EBU, 309M,  12M etc
    /// </remarks>
    private static readonly byte[] TimecodeKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timecode Last Modification Date-Time
    /// </summary>
    /// <remarks>
    /// Media time of the last modification of the segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] TimecodeLastModificationDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x02, 0x06, 0x01, 0x00, 0x00];
    /// <summary>
    /// Timecode Modification Date-Time
    /// </summary>
    /// <remarks>
    /// Identifies date and time at the point of modification
    /// </remarks>
    private static readonly byte[] TimecodeModificationDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x10, 0x02, 0x02, 0x00, 0x00];
    /// <summary>
    /// Timecode Source Kind
    /// </summary>
    /// <remarks>
    /// Specifies whether timecode is LTC or VITC
    /// </remarks>
    private static readonly byte[] TimecodeSource = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timecode Start Date-Time
    /// </summary>
    /// <remarks>
    /// Media time at start of segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] TimecodeStartDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x02, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Timecode Start Time Set
    /// </summary>
    /// <remarks>
    /// The start timecode on a timecode track
    /// </remarks>
    private static readonly byte[] timecodeStartTimeObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5A, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timecode Stream Data
    /// </summary>
    /// <remarks>
    /// Specifies the Timecode stream contains essence
    /// </remarks>
    private static readonly byte[] TimecodeStreamData = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x07, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timecode Timebase
    /// </summary>
    /// <remarks>
    /// eg. 24, 25, 30000/1001, 30, 48, 60
    /// </remarks>
    private static readonly byte[] TimecodeStreamSampleRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x04, 0x01, 0x01, 0x02, 0x01, 0x00, 0x00];
    /// <summary>
    /// Timecode Technical Attribute AnyURI Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type AnyURI
    /// </remarks>
    private static readonly byte[] timecodeTechnicalAttributeAnyURIObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5A, 0x12, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timecode Technical Attribute Boolean Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Boolean
    /// </remarks>
    private static readonly byte[] timecodeTechnicalAttributeBooleanObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5A, 0x13, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timecode Technical Attribute Float Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Float
    /// </remarks>
    private static readonly byte[] timecodeTechnicalAttributeFloatObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5A, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timecode Technical Attribute Int16 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int16
    /// </remarks>
    private static readonly byte[] timecodeTechnicalAttributeInt16Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5A, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timecode Technical Attribute Int32 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int32
    /// </remarks>
    private static readonly byte[] timecodeTechnicalAttributeInt32Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5A, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timecode Technical Attribute Int64 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int64
    /// </remarks>
    private static readonly byte[] timecodeTechnicalAttributeInt64Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5A, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timecode Technical Attribute Int8 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int8
    /// </remarks>
    private static readonly byte[] timecodeTechnicalAttributeInt8Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5A, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timecode Technical Attribute Rational Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Rational
    /// </remarks>
    private static readonly byte[] timecodeTechnicalAttributeRationalObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5A, 0x11, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timecode Technical Attribute String Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type string
    /// </remarks>
    private static readonly byte[] timecodeTechnicalAttributeStringObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5A, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timecode Technical Attribute UInt16 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt16
    /// </remarks>
    private static readonly byte[] timecodeTechnicalAttributeUInt16Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5A, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timecode Technical Attribute UInt32 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt32
    /// </remarks>
    private static readonly byte[] timecodeTechnicalAttributeUInt32Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5A, 0x0E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timecode Technical Attribute UInt64 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt64
    /// </remarks>
    private static readonly byte[] timecodeTechnicalAttributeUInt64Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5A, 0x0F, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timecode Technical Attribute UInt8 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt8
    /// </remarks>
    private static readonly byte[] timecodeTechnicalAttributeUInt8Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5A, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timecode Timebase
    /// </summary>
    /// <remarks>
    /// eg. 24, 25, 30, 60, 48
    /// </remarks>
    private static readonly byte[] TimecodeTimebase = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x01, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timecode Track Sets
    /// </summary>
    /// <remarks>
    /// The timecode tracks
    /// </remarks>
    private static readonly byte[] timecodeTrackObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5A, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timecode User Bits Flag
    /// </summary>
    /// <remarks>
    /// User bits active = True
    /// </remarks>
    private static readonly byte[] TimecodeUserBitsFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Time Interval Duration
    /// </summary>
    /// <remarks>
    /// Duration of the portion of image essence for which the metadata set is specified, as a count of index positions
    /// </remarks>
    private static readonly byte[] TimeIntervalDuration = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Time Interval Start
    /// </summary>
    /// <remarks>
    /// Start point of the portion of image essence for which the metadata set is specified, as an index
    /// </remarks>
    private static readonly byte[] TimeIntervalStart = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Time Period Name
    /// </summary>
    /// <remarks>
    /// The name of a time period covered by a data set. Eg Cretaceous
    /// </remarks>
    private static readonly byte[] TimePeriodKeyword = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x07, 0x02, 0x01, 0x08, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Time Period Name
    /// </summary>
    /// <remarks>
    /// The name of a time period covered by a data set.  Eg Cretaceous
    /// </remarks>
    private static readonly byte[] TimePeriodKeyword_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x08, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Time System Offset
    /// </summary>
    /// <remarks>
    /// Time offset from UTC (Signed hours and minutes, colon delineated) (Default is undefined).   Positive is East of UMT; negative is West of UMT
    /// </remarks>
    private static readonly byte[] TimeSystemOffset_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Time Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group to define the type of time
    /// </remarks>
    private static readonly byte[] timeTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x58, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Time Unit Kind
    /// </summary>
    /// <remarks>
    /// Frames, seconds, minutes etc.  (Default is seconds).
    /// </remarks>
    private static readonly byte[] TimeUnitKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x03, 0x03, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timing Bias Correction
    /// </summary>
    /// <remarks>
    /// Correction in seconds to be applied to timing metadata or essence time
    /// </remarks>
    private static readonly byte[] TimingBiasCorrection = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Timing Bias Correction Description
    /// </summary>
    /// <remarks>
    /// Description of the timing bias computation, reason, etc.
    /// </remarks>
    private static readonly byte[] TimingBiasCorrectionDescription_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x03, 0x03, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Tint Correction
    /// </summary>
    /// <remarks>
    /// Color tone adjustment of green-ward or magenta-ward shift in 0.00001 of delta-uv unit
    /// </remarks>
    private static readonly byte[] TintCorrection = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x01, 0x03, 0x02, 0x09, 0x00, 0x00];
    /// <summary>
    /// Title
    /// </summary>
    /// <remarks>
    /// A set of attributes to qualify a title by which a resource is known
    /// </remarks>
    private static readonly byte[] title = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Title Attribution Date
    /// </summary>
    /// <remarks>
    /// The date when the title was attributed to the resource
    /// </remarks>
    private static readonly byte[] titleAttributionDate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x05, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Title Geographical Exclusion Scope
    /// </summary>
    /// <remarks>
    /// The geographical scope within which the title does not apply
    /// </remarks>
    private static readonly byte[] titleGeographicalExclusionScope = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x05, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Title Geographical Scope
    /// </summary>
    /// <remarks>
    /// The geographical scope within which the title applies
    /// </remarks>
    private static readonly byte[] titleGeographicalScope = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x05, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Title Kind
    /// </summary>
    /// <remarks>
    /// Kind of title, i.e., project, series, item, program, working, original, item, episode, element, scene, shot etc
    /// </remarks>
    private static readonly byte[] TitleKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x05, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Title Kind
    /// </summary>
    /// <remarks>
    /// Kind of title, i.e., project, group of programs, group of series, series, item, program, working, original, item, episode, element, scene, shot etc
    /// </remarks>
    private static readonly byte[] TitleKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Title Length
    /// </summary>
    /// <remarks>
    /// The length of the title
    /// </remarks>
    private static readonly byte[] titleLength = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x05, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Title Note
    /// </summary>
    /// <remarks>
    /// A note to provide additional contextual information
    /// </remarks>
    private static readonly byte[] titleNote = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x05, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Title Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to one or more titles
    /// </remarks>
    private static readonly byte[] titleObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Titles
    /// </summary>
    /// <remarks>
    /// Titling metadata relating to productions
    /// </remarks>
    private static readonly byte[] Titles = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Titles Sets
    /// </summary>
    /// <remarks>
    /// An unordered list of strong references to Titles sets
    /// </remarks>
    private static readonly byte[] TitlesObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x05, 0x40, 0x04, 0x00];
    /// <summary>
    /// Title Type Group Set
    /// </summary>
    /// <remarks>
    /// To specify a custom kind of title
    /// </remarks>
    private static readonly byte[] titleTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x05, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Title Value Sets
    /// </summary>
    /// <remarks>
    /// A set of main titles of a resource e.g. in different languages
    /// </remarks>
    private static readonly byte[] titleValueObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x05, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Tolerance Interpolation Method
    /// </summary>
    /// <remarks>
    /// The reference to a interpolation method used to interpolate values to the reference time
    /// </remarks>
    private static readonly byte[] ToleranceInterpolationMethod = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x07, 0x02, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Tolerance Mode
    /// </summary>
    /// <remarks>
    /// Enumerated mode of sampling or interpolation affecting the precision of an observation
    /// </remarks>
    private static readonly byte[] ToleranceMode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x07, 0x02, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Tolerance Window
    /// </summary>
    /// <remarks>
    /// The duration of an observation or interpolation window.
    /// </remarks>
    private static readonly byte[] ToleranceWindow = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x07, 0x02, 0x05, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Tone Detail Factor
    /// </summary>
    /// <remarks>
    /// Contribution of the detail management function
    /// </remarks>
    private static readonly byte[] ToneDetailFactor = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x18, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Tone Mapping Gain
    /// </summary>
    /// <remarks>
    /// Tone Mapping Gain
    /// </remarks>
    private static readonly byte[] ToneMappingGain = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x14, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Tone Mapping Gamma
    /// </summary>
    /// <remarks>
    /// Tone Mapping Gamma
    /// </remarks>
    private static readonly byte[] ToneMappingGamma = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x15, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Tone Mapping Input Signal Black Level Offset
    /// </summary>
    /// <remarks>
    /// Used to calculate the gain of the signal as a first step in the Tone Mapping process
    /// </remarks>
    private static readonly byte[] ToneMappingInputSignalBlackLevelOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x21, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Tone Mapping Input Signal Weights
    /// </summary>
    /// <remarks>
    /// Weights of R, G, B, and Y components
    /// </remarks>
    private static readonly byte[] ToneMappingInputSignalWeights = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x20, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Tone Mapping Input Signal White Level Offset
    /// </summary>
    /// <remarks>
    /// Used to calculate the gain of the signal as a second step in the Tone Mapping process
    /// </remarks>
    private static readonly byte[] ToneMappingInputSignalWhiteLevelOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x22, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Tone Mapping Offset
    /// </summary>
    /// <remarks>
    /// Tone Mapping Offset
    /// </remarks>
    private static readonly byte[] ToneMappingOffset = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x13, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Tone Mapping Output Fine Tuning Function
    /// </summary>
    /// <remarks>
    /// Sampled function, for tone mapping
    /// </remarks>
    private static readonly byte[] ToneMappingOutputFineTuningFunction = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x26, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Toolkit Version
    /// </summary>
    /// <remarks>
    /// Specifies the SDK version number for a modification
    /// </remarks>
    private static readonly byte[] ToolkitVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x20, 0x07, 0x01, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Total Currency Amount
    /// </summary>
    /// <remarks>
    /// The total currency amount
    /// </remarks>
    private static readonly byte[] TotalCurrencyAmount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x02, 0x06, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Total Episode Count
    /// </summary>
    /// <remarks>
    /// Total number of episodic items in a series
    /// </remarks>
    private static readonly byte[] TotalEpisodeCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Total Income
    /// </summary>
    /// <remarks>
    /// The total numerical amount of currency involved in a sales transaction.
    /// </remarks>
    private static readonly byte[] TotalIncome_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x06, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Total Lines per Frame
    /// </summary>
    /// <remarks>
    /// Specifies the number of lines in a total frame in the video scanning system.
    /// </remarks>
    private static readonly byte[] TotalLinesPerFrame = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x03, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Total Number in Sequence
    /// </summary>
    /// <remarks>
    /// Total number of groups, items, series etc in a sequence
    /// </remarks>
    private static readonly byte[] TotalNumberInSequence = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Total Number Of Group Members
    /// </summary>
    /// <remarks>
    /// The total number of members of the related group, when applicable
    /// </remarks>
    private static readonly byte[] totalNumberOfGroupMembers = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2B, 0x01, 0x04, 0x00, 0x00];
    /// <summary>
    /// Total Payment
    /// </summary>
    /// <remarks>
    /// The total numerical amount of currency involved in a payment transaction.
    /// </remarks>
    private static readonly byte[] TotalPayment_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x02, 0x06, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Total Samples per Line
    /// </summary>
    /// <remarks>
    /// Specifies the number of samples in a total line in the video pixel matrix.
    /// </remarks>
    private static readonly byte[] TotalSamplesPerLine = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Town City Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to provide the names of the city optionally in different languages
    /// </remarks>
    private static readonly byte[] townCityObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x26, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Track
    /// </summary>
    /// <remarks>
    /// A set of attributes describing tracks (audio and video) in the material
    /// </remarks>
    private static readonly byte[] track = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x34, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Track ID
    /// </summary>
    /// <remarks>
    /// Specifies the particular track within a package
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] TrackID_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x07, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Track ID
    /// </summary>
    /// <remarks>
    /// An identifier attributed to the track
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] TrackID_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x34, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Track Language Code
    /// </summary>
    /// <remarks>
    /// Codes assigned by RFC 5646/BCP 47 for the identification of languages
    /// </remarks>
    private static readonly byte[] trackLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x34, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Track Name
    /// </summary>
    /// <remarks>
    /// Specifies the particular track within a package by a name
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] TrackName_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x07, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Track Name
    /// </summary>
    /// <remarks>
    /// A name attributed to the track
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] TrackName_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x34, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Track Name
    /// </summary>
    /// <remarks>
    /// Specifies the particular track within a package by a name
    /// </remarks>
    private static readonly byte[] TrackName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x07, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Track Number Batch
    /// </summary>
    /// <remarks>
    /// An unordered list of Track Numbers used to link the System item element to the essence tracks used in the Content Package
    /// </remarks>
    private static readonly byte[] TrackNumberBatch = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x01, 0x04, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Segment
    /// </summary>
    /// <remarks>
    /// Specifies a reference to a segment of a track
    /// </remarks>
    private static readonly byte[] TrackSegment = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x02, 0x04, 0x00, 0x00];
    /// <summary>
    /// Track Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group to define the type of the track being described
    /// </remarks>
    private static readonly byte[] trackTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x34, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Traffic ID
    /// </summary>
    /// <remarks>
    /// Identifier for emmission management and/or billing
    /// </remarks>
    private static readonly byte[] TrafficID_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Trailing Lines
    /// </summary>
    /// <remarks>
    /// Specifies the number of trailing lines in the processed image to be blanked before display
    /// </remarks>
    private static readonly byte[] TrailingLines = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x03, 0x02, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Transcript Reference
    /// </summary>
    /// <remarks>
    /// A descriptive reference to a transcript of speech in the production
    /// </remarks>
    private static readonly byte[] TranscriptReference = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x06, 0x03, 0x05, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Transcript Reference
    /// </summary>
    /// <remarks>
    /// A descriptive reference to a transcript of speech in the production
    /// </remarks>
    private static readonly byte[] TranscriptReference_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x06, 0x03, 0x05, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Transfer Characteristic
    /// </summary>
    /// <remarks>
    /// Specifies the non-linear relationship between linear scene light levels and amplitude-compressed video signal levels at signal origination.
    /// </remarks>
    private static readonly byte[] TransferCharacteristic = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x01, 0x02, 0x01, 0x01, 0x01, 0x02, 0x00];
    /// <summary>
    /// Transfer Characteristics
    /// </summary>
    /// <remarks>
    /// Specifies the non-linear relationship between linear scene light levels and amplitude-compressed video signal levels.
    /// </remarks>
    private static readonly byte[] TransferCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Transfer Film Frame Rate
    /// </summary>
    /// <remarks>
    /// eg 23.976 fps
    /// </remarks>
    private static readonly byte[] TransferFilmFrameRate_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x08, 0x02, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Transfer History
    /// </summary>
    /// <remarks>
    /// History of transfers occuring in the process
    /// </remarks>
    private static readonly byte[] TransferHistory = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Transition Effect
    /// </summary>
    /// <remarks>
    /// Specifies a reference to the effect used in a transition
    /// </remarks>
    private static readonly byte[] TransitionOperation = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x02, 0x05, 0x00, 0x00];
    /// <summary>
    /// Transmission ID
    /// </summary>
    /// <remarks>
    /// Identifier for transmission control
    /// </remarks>
    private static readonly byte[] TransmissionID_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Transport Stream ID
    /// </summary>
    /// <remarks>
    /// Identifier that is the transport_stream_id in ISO/IEC 13818-1 (MPEG-2 Systems)
    /// </remarks>
    private static readonly byte[] TransportStreamID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x03, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Triplet Sequence Number
    /// </summary>
    /// <remarks>
    /// Ordinal number of an encrypted triplet in a sequence
    /// </remarks>
    private static readonly byte[] TripletSequenceNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x06, 0x10, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Turner Broadcasting System, Inc.
    /// </summary>
    /// <remarks>
    /// Metadata registered by Turner Broadcasting System, Inc. for private use
    /// </remarks>
    private static readonly byte[] TurnerBroadcastingSystemInc = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x0E, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Type
    /// </summary>
    /// <remarks>
    /// A type associated with a media resource
    /// </remarks>
    private static readonly byte[] type = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0E, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Type Definition
    /// </summary>
    /// <remarks>
    /// Information for the definition of data types
    /// </remarks>
    private static readonly byte[] TypeDefinition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Type Definitions
    /// </summary>
    /// <remarks>
    /// Specifies a set of unordered references to the Type Definition objects that define the data types that are used in the container
    /// </remarks>
    private static readonly byte[] TypeDefinitions = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x07, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Type Group
    /// </summary>
    /// <remarks>
    /// A set of attributes used to define a type
    /// </remarks>
    private static readonly byte[] typeGroup = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Type Group Definition
    /// </summary>
    /// <remarks>
    /// A definition associated with the term
    /// </remarks>
    private static readonly byte[] typeGroupDefinition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x01, 0x05, 0x00, 0x00];
    /// <summary>
    /// Type Group Label
    /// </summary>
    /// <remarks>
    /// A universal label or free text to express the type
    /// </remarks>
    private static readonly byte[] typeGroupLabel = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x01, 0x02, 0x00, 0x00];
    /// <summary>
    /// Type Group Language Code
    /// </summary>
    /// <remarks>
    /// The BCP-47 code of the language used to express the term
    /// </remarks>
    private static readonly byte[] typeGroupLanguageCode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x01, 0x06, 0x00, 0x00];
    /// <summary>
    /// Type Group Link
    /// </summary>
    /// <remarks>
    /// A link to a term in a classification scheme
    /// </remarks>
    private static readonly byte[] typeGroupLink = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x01, 0x03, 0x00, 0x00];
    /// <summary>
    /// Type Group Namespace
    /// </summary>
    /// <remarks>
    /// The namespace of the classification scheme
    /// </remarks>
    private static readonly byte[] typeGroupNamespace = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x01, 0x07, 0x00, 0x00];
    /// <summary>
    /// Type Group Source
    /// </summary>
    /// <remarks>
    /// The authority who has provided the classification scheme of free text term
    /// </remarks>
    private static readonly byte[] typeGroupSource = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x01, 0x08, 0x00, 0x00];
    /// <summary>
    /// Type Group Thesaurus
    /// </summary>
    /// <remarks>
    /// The thesaurus from which the type originates
    /// </remarks>
    private static readonly byte[] typeGroupThesaurus = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// Type Group UL
    /// </summary>
    /// <remarks>
    /// A UL to a label in the label register
    /// </remarks>
    private static readonly byte[] typeGroupUL = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x2D, 0x01, 0x04, 0x00, 0x00];
    /// <summary>
    /// Type Note
    /// </summary>
    /// <remarks>
    /// A note to provide additional contextual information
    /// </remarks>
    private static readonly byte[] typeNote = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0E, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Type Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to one or more types (object type, genre, target audience or audience level...)
    /// </remarks>
    private static readonly byte[] typeObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x02, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Type Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to the type of type if neither "object type" nor "genre" nor "target audience"
    /// </remarks>
    private static readonly byte[] typeTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0E, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Type Value Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to one or more type values optionally in different languages
    /// </remarks>
    private static readonly byte[] typeValueObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0E, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// UCS Encoding
    /// </summary>
    /// <remarks>
    /// A text string giving the ISO/IEC 10646-1 encoding of the essence data.
    /// </remarks>
    private static readonly byte[] UCSEncoding = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x04, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UDAM Set Identifier
    /// </summary>
    /// <remarks>
    /// The immutable ID of the instance of this user-defined acquisition metadata set
    /// </remarks>
    private static readonly byte[] UDAMSetIdentifier = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x06, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UDAM Set Version
    /// </summary>
    /// <remarks>
    /// The version number of the instance of this user-defined acquisition metadata set
    /// </remarks>
    private static readonly byte[] UDAMSetVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x06, 0x08, 0x07, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// 3D
    /// </summary>
    /// <remarks>
    /// A flag to indicate whether the file contains video intended for stereoscopic rendition.
    /// </remarks>
    private static readonly byte[] UKDPP_3D = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x0A, 0x00];
    /// <summary>
    /// 3D Type
    /// </summary>
    /// <remarks>
    /// A code to identify the kind of stereoscopic video contained in the file.
    /// </remarks>
    private static readonly byte[] UKDPP_3D_Type = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x0B, 0x00];
    /// <summary>
    /// Audio Comments
    /// </summary>
    /// <remarks>
    /// A description of the subjective quality of the audio in the programme including notes on any global characteristics or audio treatments.
    /// </remarks>
    private static readonly byte[] UKDPP_Audio_Comments = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x14, 0x00];
    /// <summary>
    /// Audio Description Present
    /// </summary>
    /// <remarks>
    /// A flag to indicate whether the programme contains audio description for the visually impaired.
    /// </remarks>
    private static readonly byte[] UKDPP_Audio_Description_Present = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x19, 0x00];
    /// <summary>
    /// Audio Description Type
    /// </summary>
    /// <remarks>
    /// A code to identify the format of the audio description.
    /// </remarks>
    private static readonly byte[] UKDPP_Audio_Description_Type = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x1A, 0x00];
    /// <summary>
    /// Audio Loudness Standard
    /// </summary>
    /// <remarks>
    /// A code to identify a relevant audio loudness recommendation or standard.
    /// </remarks>
    private static readonly byte[] UKDPP_Audio_Loudness_Standard = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x13, 0x00];
    /// <summary>
    /// Completion Date
    /// </summary>
    /// <remarks>
    /// The date on which the programme file was completed ready for delivery to the Broadcaster.
    /// </remarks>
    private static readonly byte[] UKDPP_Completion_Date = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x20, 0x00];
    /// <summary>
    /// Contact Email
    /// </summary>
    /// <remarks>
    /// The email address for the person or organisation responsible for supplying the programme file to the Broadcaster.
    /// </remarks>
    private static readonly byte[] UKDPP_Contact_Email = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x24, 0x00];
    /// <summary>
    /// Contact Telephone No.
    /// </summary>
    /// <remarks>
    /// The telephone number for the person or organisation responsible for supplying the programme file to the Broadcaster.
    /// </remarks>
    private static readonly byte[] UKDPP_Contact_Telephone_Number = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x25, 0x00];
    /// <summary>
    /// Copyright Year
    /// </summary>
    /// <remarks>
    /// The full year in which one of the following occurred or will occur: completion of the production of the programme; delivery of the completed file to the Broadcaster; transmission of the delivered programme.
    /// </remarks>
    private static readonly byte[] UKDPP_Copyright_Year = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x04, 0x00];
    /// <summary>
    /// Distributor
    /// </summary>
    /// <remarks>
    /// The name of the person or organisation responsible for supplying the programme to the Broadcaster.
    /// </remarks>
    private static readonly byte[] UKDPP_Distributor = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x08, 0x00];
    /// <summary>
    /// Genre
    /// </summary>
    /// <remarks>
    /// A single style or category describing the whole programme.
    /// </remarks>
    private static readonly byte[] UKDPP_Genre = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x07, 0x00];
    /// <summary>
    /// Ident Clock Start
    /// </summary>
    /// <remarks>
    /// The value of the Position in the MXF Material Package at which the initial "ident" or countdown clock begins.
    /// </remarks>
    private static readonly byte[] UKDPP_Ident_Clock_Start = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x16, 0x00];
    /// <summary>
    /// Line Up Start
    /// </summary>
    /// <remarks>
    /// The value of the Position in the MXF Material Package at which the line-up test signals begin.
    /// </remarks>
    private static readonly byte[] UKDPP_Line_Up_Start = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x15, 0x00];
    /// <summary>
    /// Open Captions Language
    /// </summary>
    /// <remarks>
    /// A code to identify the main language used in the open captions.
    /// </remarks>
    private static readonly byte[] UKDPP_Open_Captions_Language = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x1D, 0x00];
    /// <summary>
    /// Open Captions Present
    /// </summary>
    /// <remarks>
    /// A flag to indicate whether the programme contains visible (in-vision) subtitling information.
    /// </remarks>
    private static readonly byte[] UKDPP_Open_Captions_Present = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x1B, 0x00];
    /// <summary>
    /// Open Captions Type
    /// </summary>
    /// <remarks>
    /// A code to identify the editorial description of the open captions.
    /// </remarks>
    private static readonly byte[] UKDPP_Open_Captions_Type = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x1C, 0x00];
    /// <summary>
    /// Originator
    /// </summary>
    /// <remarks>
    /// The name of the person or organisation responsible for creating the programme.
    /// </remarks>
    private static readonly byte[] UKDPP_Originator = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x03, 0x00];
    /// <summary>
    /// Other Identifier
    /// </summary>
    /// <remarks>
    /// Another unique identifier / code for the content.
    /// </remarks>
    private static readonly byte[] UKDPP_Other_Identifier = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x05, 0x00];
    /// <summary>
    /// Other Identifier type
    /// </summary>
    /// <remarks>
    /// The kind of identifier / code used for "Other Identifier".
    /// </remarks>
    private static readonly byte[] UKDPP_Other_Identifier_Type = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x06, 0x00];
    /// <summary>
    /// Picture Ratio
    /// </summary>
    /// <remarks>
    /// The ratio of the display width to the display height of the smallest rectangle that completely contains (throughout the duration of the entire programme) the region of the video frame used for "programme content" (where "programme content" includes all pictures, captions, etc but excludes any black bars).
    /// </remarks>
    private static readonly byte[] UKDPP_Picture_Ratio = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x09, 0x00];
    /// <summary>
    /// Product Placement
    /// </summary>
    /// <remarks>
    /// A flag to indicate whether the programme contains "product placement".
    /// </remarks>
    private static readonly byte[] UKDPP_Product_Placement = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x0C, 0x00];
    /// <summary>
    /// Production Number
    /// </summary>
    /// <remarks>
    /// A unique identifier / code for the programme (i.e. a unique identifier for this version of the episode).
    /// </remarks>
    private static readonly byte[] UKDPP_Production_Number = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00];
    /// <summary>
    /// Programme Has Text
    /// </summary>
    /// <remarks>
    /// A flag to indicate whether the main programme content contains text overlays (or similar) in the video.
    /// </remarks>
    private static readonly byte[] UKDPP_Programme_Has_Text = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x22, 0x00];
    /// <summary>
    /// Programme Text Language
    /// </summary>
    /// <remarks>
    /// A code to identify the main language used for text overlays (or similar) in the video of the main programme content.
    /// </remarks>
    private static readonly byte[] UKDPP_Programme_Text_Language = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x23, 0x00];
    /// <summary>
    /// PSE Manufacturer
    /// </summary>
    /// <remarks>
    /// The name of the product used to perform the test for compliance with PSE guidelines.
    /// </remarks>
    private static readonly byte[] UKDPP_PSE_Manufacturer = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x0E, 0x00];
    /// <summary>
    /// PSE Pass
    /// </summary>
    /// <remarks>
    /// A code to indicate: whether the entire programme passed a flash and pattern test for compliance with Photosensitive Epilepsy (PSE) guidelines; or that such a test has not been carried out.
    /// </remarks>
    private static readonly byte[] UKDPP_PSE_Pass = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x00];
    /// <summary>
    /// PSE Version
    /// </summary>
    /// <remarks>
    /// The version of the algorithm / product module used to perform the test for compliance with PSE guidelines.
    /// </remarks>
    private static readonly byte[] UKDPP_PSE_Version = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x0F, 0x00];
    /// <summary>
    /// Secondary Audio Language
    /// </summary>
    /// <remarks>
    /// A code to identify the main language used on secondary audio channels.
    /// </remarks>
    private static readonly byte[] UKDPP_Secondary_Audio_Language = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x11, 0x00];
    /// <summary>
    /// Sign Language
    /// </summary>
    /// <remarks>
    /// A code to identify the main language and / or format of the visible (in-vision) signing contained in the programme.
    /// </remarks>
    private static readonly byte[] UKDPP_Sign_Language = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x1F, 0x00];
    /// <summary>
    /// Signing Present
    /// </summary>
    /// <remarks>
    /// A code to indicate: whether the programme contains visible (in-vision) signing along with the rest of the programme content; or that the programme contains only visible (in-vision) signing.
    /// </remarks>
    private static readonly byte[] UKDPP_Signing_Present = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x1E, 0x00];
    /// <summary>
    /// Synopsis
    /// </summary>
    /// <remarks>
    /// A brief descriptive summary of the programme.
    /// </remarks>
    private static readonly byte[] UKDPP_Synopsis = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x02, 0x00];
    /// <summary>
    /// Tertiary Audio Language
    /// </summary>
    /// <remarks>
    /// A code to identify the main language used on tertiary audio channels.
    /// </remarks>
    private static readonly byte[] UKDPP_Tertiary_Audio_Language = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x12, 0x00];
    /// <summary>
    /// Textless Elements Exist
    /// </summary>
    /// <remarks>
    /// A flag to indicate whether the programme contains "textless elements" after the end of the main programme content.
    /// </remarks>
    private static readonly byte[] UKDPP_Textless_Elements_Exist = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x21, 0x00];
    /// <summary>
    /// Total Number Of Parts
    /// </summary>
    /// <remarks>
    /// The count of parts / segments in the file.
    /// </remarks>
    private static readonly byte[] UKDPP_Total_Number_Of_Parts = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x17, 0x00];
    /// <summary>
    /// Total Programme Duration
    /// </summary>
    /// <remarks>
    /// The sum of the durations of all the parts / segments in the entire programme.
    /// </remarks>
    private static readonly byte[] UKDPP_Total_Programme_Duration = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x18, 0x00];
    /// <summary>
    /// Video Comments
    /// </summary>
    /// <remarks>
    /// A description of the subjective quality of the video in the programme including notes on any global characteristics or video treatments.
    /// </remarks>
    private static readonly byte[] UKDPP_Video_Comments = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x10, 0x00];
    /// <summary>
    /// UMID Audio
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for audio essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMID_Audio_10 = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID Audio
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for audio essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMID_Audio_11 = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x11, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID Audio
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for audio essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMID_Audio_12 = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x12, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID Audio
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for audio essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMID_Audio_20 = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID Audio
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for audio essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMID_Audio_21 = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x21, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID Audio
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for audio essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMID_Audio_22 = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x22, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID Data
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for data essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMID_Data_10 = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x10, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID Data
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for data essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMID_Data_11 = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x11, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID Data
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for data essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMID_Data_12 = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x12, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID Data
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for data essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMID_Data_20 = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x20, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID Data
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for data essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMID_Data_21 = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x21, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID Data
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for data essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMID_Data_22 = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x22, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID System
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for other essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMID_System_10 = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x10, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID System
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for other essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMID_System_11 = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x11, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID System
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for other essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMID_System_12 = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x12, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID System
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for other essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMID_System_20 = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x20, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID System
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for other essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMID_System_21 = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x21, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID System
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for other essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMID_System_22 = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x22, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID Video
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for video essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMID_Video_10 = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x10, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID Video
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for video essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMID_Video_11 = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x11, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID Video
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for video essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMID_Video_12 = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x12, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID Video
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for video essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMID_Video_20 = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x20, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID Video
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for video essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMID_Video_21 = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x21, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID Video
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for video essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMID_Video_22 = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x22, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID Audio
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for audio essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMIDAudio = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID Data
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for data essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMIDData = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID General
    /// </summary>
    /// <remarks>
    /// SMPTE330M UMID for unspecified components
    /// </remarks>
    private static readonly byte[] UMIDGeneral = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x01, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID Mixed
    /// </summary>
    /// <remarks>
    /// SMPTE330M UMID for mixed group of components
    /// </remarks>
    private static readonly byte[] UMIDMixed = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x01, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID Multi Data
    /// </summary>
    /// <remarks>
    /// SMPTE330M UMID for multiple data component
    /// </remarks>
    private static readonly byte[] UMIDMultiData = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x01, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID Multi Picture
    /// </summary>
    /// <remarks>
    /// SMPTE330M UMID for multiple picture component
    /// </remarks>
    private static readonly byte[] UMIDMultiPicture = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x01, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID Multi Sound
    /// </summary>
    /// <remarks>
    /// SMPTE330M UMID for multiple sound component
    /// </remarks>
    private static readonly byte[] UMIDMultiSound = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x01, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID Picture
    /// </summary>
    /// <remarks>
    /// SMPTE330M UMID for single picture component
    /// </remarks>
    private static readonly byte[] UMIDPicture = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID Single Data
    /// </summary>
    /// <remarks>
    /// SMPTE330M UMID for single data component
    /// </remarks>
    private static readonly byte[] UMIDSingleData = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x01, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID Sound
    /// </summary>
    /// <remarks>
    /// SMPTE330M UMID for single sound component
    /// </remarks>
    private static readonly byte[] UMIDSound = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x01, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID System
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for other essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMIDSystem = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// UMID Video
    /// </summary>
    /// <remarks>
    /// Unique Material Identifier for video essence.  Note - this is a 12 byte SMPTE label.
    /// </remarks>
    private static readonly byte[] UMIDVideo = [0x06, 0x0A, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Uniform Resource Locators
    /// </summary>
    /// <remarks>
    /// Unique Resource Locators
    /// </remarks>
    private static readonly byte[] UniformResourceLocators = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Unknown BWF Chunks
    /// </summary>
    /// <remarks>
    /// Specifies an ordered vector of references to  RIFF chunks containing data extracted from a BWF file
    /// </remarks>
    private static readonly byte[] UnknownBWFChunks = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x08, 0x06, 0x01, 0x01, 0x04, 0x06, 0x0F, 0x00, 0x00];
    /// <summary>
    /// UPID
    /// </summary>
    /// <remarks>
    /// A Unique Program Identifier (ATSC A/57) for a program as a Work
    /// </remarks>
    private static readonly byte[] UPID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x10, 0x03, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// UPN
    /// </summary>
    /// <remarks>
    /// Unique Programme Number (ITVA)
    /// </remarks>
    private static readonly byte[] UPN = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x10, 0x03, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Upper Left Corner
    /// </summary>
    /// <remarks>
    /// Coordinate of the top-left pixel of the Processing Window
    /// </remarks>
    private static readonly byte[] UpperLeftCorner = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x06, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Upstream Audio Compression Algorithm
    /// </summary>
    /// <remarks>
    /// Algorithms used, bitrates used, modes used.
    /// </remarks>
    private static readonly byte[] UpstreamAudioCompressionAlgorithm_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x40, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// URL
    /// </summary>
    /// <remarks>
    /// Unique Resource Locator String
    /// </remarks>
    private static readonly byte[] URL = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// URL
    /// </summary>
    /// <remarks>
    /// Unique Resource Locator String
    /// </remarks>
    private static readonly byte[] URL_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// URN
    /// </summary>
    /// <remarks>
    /// Unique Resource Name
    /// </remarks>
    private static readonly byte[] URN_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Use Default Value
    /// </summary>
    /// <remarks>
    /// Specifies that a defined default value should be used for a property where the value is not supplied. (False=use supplied value)
    /// </remarks>
    private static readonly byte[] UseDefaultValue = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x02, 0x02, 0x03, 0x01, 0x00, 0x00];
    /// <summary>
    /// User Data Mode
    /// </summary>
    /// <remarks>
    /// AES3 Enumerated mode of carriage of user data..
    /// </remarks>
    private static readonly byte[] UserDataMode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x02, 0x05, 0x01, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// User Date-Time
    /// </summary>
    /// <remarks>
    /// Time stamp application defined by user application
    /// </remarks>
    private static readonly byte[] UserDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Username
    /// </summary>
    /// <remarks>
    /// A username in a domain
    /// Namespace: http://www.smpte-ra.org/reg/335/2012
    /// </remarks>
    private static readonly byte[] Username_1 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x08, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Username
    /// </summary>
    /// <remarks>
    /// To provide a username through which the contact is known
    /// Namespace: http://www.ebu.ch/metadata/schemas/ebucore/smpte/class13/element
    /// </remarks>
    private static readonly byte[] Username_element = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x22, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Username
    /// </summary>
    /// <remarks>
    /// A username in a domain
    /// </remarks>
    private static readonly byte[] Username_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x02, 0x08, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// User Position
    /// </summary>
    /// <remarks>
    /// Specifies a position relative to the origin, in edit units, where material was previously positioned for viewing
    /// </remarks>
    private static readonly byte[] UserPosition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x07, 0x02, 0x01, 0x03, 0x01, 0x0D, 0x00, 0x00];
    /// <summary>
    /// UTC End Date-Time
    /// </summary>
    /// <remarks>
    /// Absolute time at end of creating the segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] UTCEndDateTime_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x02, 0x03, 0x01, 0x00, 0x00];
    /// <summary>
    /// UTC Event End Date-Time
    /// </summary>
    /// <remarks>
    /// The absolute ending date and time of the project, mission, scene, editing event, license, publication etc
    /// </remarks>
    private static readonly byte[] UTCEventEndDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x07, 0x02, 0x01, 0x02, 0x09, 0x01, 0x01, 0x00];
    /// <summary>
    /// UTC Event End Date-Time
    /// </summary>
    /// <remarks>
    /// The absolute ending date and time of the project, mission, scene, editing event, license, publication etc
    /// </remarks>
    private static readonly byte[] UTCEventEndDateTime_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x02, 0x09, 0x01, 0x00, 0x00];
    /// <summary>
    /// UTC Event Start Date-Time
    /// </summary>
    /// <remarks>
    /// The absolute beginning date and time of the project, mission, scene, editing event, license, publication etc
    /// </remarks>
    private static readonly byte[] UTCEventStartDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x07, 0x02, 0x01, 0x02, 0x07, 0x01, 0x01, 0x00];
    /// <summary>
    /// UTC Event Start Date-Time
    /// </summary>
    /// <remarks>
    /// The absolute beginning date and time of the project, mission, scene, editing event, license, publication etc
    /// </remarks>
    private static readonly byte[] UTCEventStartDateTime_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x02, 0x07, 0x01, 0x00, 0x00];
    /// <summary>
    /// UTC Instant Date-Time
    /// </summary>
    /// <remarks>
    /// Absolute time at instant of creating the segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] UTCInstantDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x07, 0x02, 0x01, 0x02, 0x01, 0x03, 0x01, 0x00];
    /// <summary>
    /// UTC Instant Date-Time
    /// </summary>
    /// <remarks>
    /// Absolute time at instant of creating the segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] UTCInstantDateTime_UTCmilliseconds = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x07, 0x02, 0x01, 0x02, 0x01, 0x03, 0x00, 0x00];
    /// <summary>
    /// UTC Last Modification Date-Time
    /// </summary>
    /// <remarks>
    /// Absolute time of the last modification of the segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] UTCLastModificationDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x07, 0x02, 0x01, 0x02, 0x05, 0x01, 0x01, 0x00];
    /// <summary>
    /// UTC Last Modification Date-Time
    /// </summary>
    /// <remarks>
    /// Absolute time of the last modification of the segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] UTCLastModificationDateTime_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x02, 0x05, 0x01, 0x00, 0x00];
    /// <summary>
    /// UTC Start Date-Time
    /// </summary>
    /// <remarks>
    /// Absolute time at start of creating the segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] UTCStartDateTime = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x09, 0x07, 0x02, 0x01, 0x02, 0x01, 0x01, 0x01, 0x00];
    /// <summary>
    /// UTC Start Date-Time
    /// </summary>
    /// <remarks>
    /// Absolute time at start of creating the segment, shot, clip, item etc.
    /// </remarks>
    private static readonly byte[] UTCStartDateTime_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x02, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// UTC User Date-Time
    /// </summary>
    /// <remarks>
    /// Time stamp application defined by user application
    /// </remarks>
    private static readonly byte[] UTCUserDateTime_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// UTF-16 Text Data
    /// </summary>
    /// <remarks>
    /// UTF-16 Text Data
    /// </remarks>
    private static readonly byte[] UTF16TextData = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x03, 0x01, 0x02, 0x20, 0x03, 0x02, 0x00, 0x00];
    /// <summary>
    /// UTF-8 Text Data
    /// </summary>
    /// <remarks>
    /// UTF-8 Text Data
    /// </remarks>
    private static readonly byte[] UTF8TextData = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x03, 0x01, 0x02, 0x20, 0x03, 0x01, 0x00, 0x00];
    /// <summary>
    /// validateCPL Status
    /// </summary>
    /// <remarks>
    /// Error Code
    /// </remarks>
    private static readonly byte[] validateCPLStatus = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// validateKdm Status
    /// </summary>
    /// <remarks>
    /// Error Code
    /// </remarks>
    private static readonly byte[] validateKdmStatus = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x15, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Value
    /// </summary>
    /// <remarks>
    /// Effect or Transformation Constant Control Value
    /// </remarks>
    private static readonly byte[] Value = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x05, 0x30, 0x05, 0x07, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Variable Array Element Type
    /// </summary>
    /// <remarks>
    /// Specifies a reference to the underlying type used in the variable array type
    /// </remarks>
    private static readonly byte[] VariableArrayElementType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x07, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// VBE Byte Count
    /// </summary>
    /// <remarks>
    /// The count of bytes of the last essence element in the last Edit Unit indexed by the Index Table Segment
    /// </remarks>
    private static readonly byte[] VBEByteCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x06, 0x02, 0x05, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// VBI Line Count
    /// </summary>
    /// <remarks>
    /// Number of VBI lines stored in a Data Element
    /// </remarks>
    private static readonly byte[] VBILineCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x05, 0x02, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// VBI Payload Byte Array
    /// </summary>
    /// <remarks>
    /// An array of Uint8 samples containing the coded VBI data
    /// </remarks>
    private static readonly byte[] VBIPayloadByteArray = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x05, 0x02, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// VBI Payload Sample Coding
    /// </summary>
    /// <remarks>
    /// Enumerated sample coding of VBI payload
    /// </remarks>
    private static readonly byte[] VBIPayloadSampleCoding = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x05, 0x03, 0x0F, 0x00, 0x00, 0x00];
    /// <summary>
    /// VBI Payload Sample Count
    /// </summary>
    /// <remarks>
    /// A count of the number of samples stored in the payload byte array
    /// </remarks>
    private static readonly byte[] VBIPayloadSampleCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x05, 0x02, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// VBI Wrapping Type
    /// </summary>
    /// <remarks>
    /// Enumerated wrapping type of the VBI data payload
    /// </remarks>
    private static readonly byte[] VBIWrappingType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x05, 0x02, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// VC-1 Average Bit Rate
    /// </summary>
    /// <remarks>
    /// Specifies the average bit rate of VC-1 video elementary streams in bits-per-second.
    /// </remarks>
    private static readonly byte[] VC1AverageBitRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x04, 0x01, 0x06, 0x04, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// VC-1 B Picture Count
    /// </summary>
    /// <remarks>
    /// Specifies the maximum number of B pictures between P or I frames. BI pictures count as B pictures and skipped pictures count as P pictures.
    /// </remarks>
    private static readonly byte[] VC1BPictureCount = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x04, 0x01, 0x06, 0x04, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// VC-1 Coded Content Type
    /// </summary>
    /// <remarks>
    /// An enumerated value that tells if the underlying content was of a known VC-1 type. Enumerations are 0="Unknown", 1="Progressive, 2= "Interlaced," "3=Mixed."
    /// </remarks>
    private static readonly byte[] VC1CodedContentType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x04, 0x01, 0x06, 0x04, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// VC-1 Identical GOP
    /// </summary>
    /// <remarks>
    /// A boolean value, using TRUE to indicate that all GOPs in the sequence are constructed the same.
    /// </remarks>
    private static readonly byte[] VC1IdenticalGOP = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x04, 0x01, 0x06, 0x04, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// VC-1 Initialization Metadata
    /// </summary>
    /// <remarks>
    /// Encodes the metadata defined in SMPTE 421 annex J for Simple and Main Profile bitstreams.
    /// </remarks>
    private static readonly byte[] VC1InitializationMetadata = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x04, 0x01, 0x06, 0x04, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// VC-1 Level
    /// </summary>
    /// <remarks>
    /// Specifies the VC-1 video level. This is coded as per SMPTE 421M, Annex J.I.2.
    /// </remarks>
    private static readonly byte[] VC1Level = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x04, 0x01, 0x06, 0x04, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// VC-1 Maximum GOP
    /// </summary>
    /// <remarks>
    /// Specifies the maximum occuring spacing between I-frames. A value of '0", or the absence of this property implies no limit to the maximum GOP.
    /// </remarks>
    private static readonly byte[] VC1MaxGOP = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x04, 0x01, 0x06, 0x04, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// VC-1 Maximum Bit Rate
    /// </summary>
    /// <remarks>
    /// Specifies the maximum bit rate of VC-1 video elementary streams in bits-per-second.
    /// </remarks>
    private static readonly byte[] VC1MaximumBitRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x04, 0x01, 0x06, 0x04, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// VC-1 Picture Essence Descriptors
    /// </summary>
    /// <remarks>
    /// Defines the VC-1 Picture Essence Descriptor Set.
    /// </remarks>
    private static readonly byte[] VC1PictureEssenceDescriptors = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x04, 0x01, 0x06, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// VC-1 Profile
    /// </summary>
    /// <remarks>
    /// Specifies the VC-1 profile. Coded as per SMPTE 421M, Annex J.1.2.
    /// </remarks>
    private static readonly byte[] VC1Profile = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x04, 0x01, 0x06, 0x04, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// VC-1 Single Sequence
    /// </summary>
    /// <remarks>
    /// TRUE is the essence consists of a single VC-a sequence. FALSE if there are a number of sequences. This flag implies that the sequence header information is not varying in the essence stream.
    /// </remarks>
    private static readonly byte[] VC1SingleSequence = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0C, 0x04, 0x01, 0x06, 0x04, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// VC-2 Edit Units Are Complete Sequences
    /// </summary>
    /// <remarks>
    /// A flag to indicate whether every Edit Unit comprises a single valid VC-2 sequence in its entirety
    /// </remarks>
    private static readonly byte[] VC2EditUnitsAreCompleteSequences = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x07, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// VC-2 Level
    /// </summary>
    /// <remarks>
    /// VC-2 Level as defined in SMPTE ST 2042-1
    /// </remarks>
    private static readonly byte[] VC2Level = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x07, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// VC-2 Major Version
    /// </summary>
    /// <remarks>
    /// VC-2 Major Version Number as defined in SMPTE ST 2042-1
    /// </remarks>
    private static readonly byte[] VC2MajorVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x07, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// VC-2 Minor Version
    /// </summary>
    /// <remarks>
    /// VC-2 Minor Version Number as defined in SMPTE ST 2042-1
    /// </remarks>
    private static readonly byte[] VC2MinorVersion = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x07, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// VC-2 Profile
    /// </summary>
    /// <remarks>
    /// VC-2 Profile as defined in SMPTE ST 2042-1
    /// </remarks>
    private static readonly byte[] VC2Profile = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x07, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// VC-2 Properties
    /// </summary>
    /// <remarks>
    /// Properties of VC-2 streams
    /// </remarks>
    private static readonly byte[] VC2Properties = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// VC-2 Sequence Headers Identical
    /// </summary>
    /// <remarks>
    /// A flag to indicate whether all VC-2 Sequence Headers in the entire wrapped VC-2 stream are byte-for-byte identical
    /// </remarks>
    private static readonly byte[] VC2SequenceHeadersIdentical = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x07, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// VC-2 Wavelet Filters
    /// </summary>
    /// <remarks>
    /// The distinct values of state[wavelet_index] across the entire wrapped VC-2 stream(each value used in the wrapped VC-2 stream appears only once in this array). This identifies the wavelet filters used.
    /// </remarks>
    private static readonly byte[] VC2WaveletFilters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x07, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// VC-5 Alpha Sampling
    /// </summary>
    /// <remarks>
    /// VC-5 AlphaSampling codec state parameter defined in SMPTE ST 2073-4
    /// </remarks>
    private static readonly byte[] VC5AlphaSampling = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x08, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// VC-5 Bayer Component Black Level
    /// </summary>
    /// <remarks>
    /// Value of each Bayer component that corresponds to black
    /// </remarks>
    private static readonly byte[] VC5BayerComponentBlackLevel = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x08, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// VC-5 Bayer Component Pattern
    /// </summary>
    /// <remarks>
    /// Bayer component order and bit depth of each component (See SMPTE ST 377-1)
    /// </remarks>
    private static readonly byte[] VC5BayerComponentPattern = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x08, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// VC-5 Bayer Component White Level
    /// </summary>
    /// <remarks>
    /// Value of each Bayer component that corresponds to the white clipping point
    /// </remarks>
    private static readonly byte[] VC5BayerComponentWhiteLevel = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x08, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// VC-5 Parameters
    /// </summary>
    /// <remarks>
    /// VC-5 Parameters
    /// </remarks>
    private static readonly byte[] VC5Parameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x01, 0x06, 0x08, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Version
    /// </summary>
    /// <remarks>
    /// To define the version of the resource
    /// </remarks>
    private static readonly byte[] version = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1A, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Version Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a set of version information
    /// </remarks>
    private static readonly byte[] versionObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x02, 0x0F, 0x00, 0x00, 0x00];
    /// <summary>
    /// Version Text
    /// </summary>
    /// <remarks>
    /// The software version text
    /// </remarks>
    private static readonly byte[] VersionText = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x1D, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Version Text Length
    /// </summary>
    /// <remarks>
    /// The length of the version text
    /// </remarks>
    private static readonly byte[] VersionTextLength = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x1C, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Version Title
    /// </summary>
    /// <remarks>
    /// The version title
    /// </remarks>
    private static readonly byte[] VersionTitle = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x01, 0x05, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Version Title
    /// </summary>
    /// <remarks>
    /// The version title
    /// </remarks>
    private static readonly byte[] VersionTitle_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x01, 0x05, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Version Type Group Set
    /// </summary>
    /// <remarks>
    /// A reference to an attribute type group to specify the type of version information being provided
    /// </remarks>
    private static readonly byte[] versionTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1A, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Version Value Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to textual annotation expressing the version (e.g. TV, theatre, plane) optionally in different languages
    /// </remarks>
    private static readonly byte[] versionValueObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x1A, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Vertical Action Safe Percentage
    /// </summary>
    /// <remarks>
    /// Specifies the percentage of the image which lies outside the vertical safe area for action: expressed as the ratio of one side as a percentage of the total height of the scan.
    /// </remarks>
    private static readonly byte[] VerticalActionSafePercentage = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x01, 0x01, 0x01, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Vertical Datum
    /// </summary>
    /// <remarks>
    /// Identifies the Digital Geographic Information Exchange Standard (DIGEST) map datum used to derive the  coordinates (UTM or GEO).
    /// </remarks>
    private static readonly byte[] VerticalDatum_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x07, 0x01, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Vertical Graphics Safe Percentage
    /// </summary>
    /// <remarks>
    /// Specifies the percentage of the image which lies outside the vertical safe area for graphics: expressed as the ratio of one side as a percentage of the total height of the scan.
    /// </remarks>
    private static readonly byte[] VerticalGraphicsSafePercentage = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x01, 0x01, 0x01, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Vertical Parameters
    /// </summary>
    /// <remarks>
    /// Vertical scanning information
    /// </remarks>
    private static readonly byte[] VerticalParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Vertical Sub-sampling
    /// </summary>
    /// <remarks>
    /// Specifies ratio of luminance subsampling to chrominance subsampling in vertical direction
    /// </remarks>
    private static readonly byte[] VerticalSubsampling = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x01, 0x05, 0x01, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video 3D Flag
    /// </summary>
    /// <remarks>
    /// A flag to indicate if the video is for stereoscopic rendition
    /// </remarks>
    private static readonly byte[] video3DFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x0D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Active Lines
    /// </summary>
    /// <remarks>
    /// The number of active picture lines
    /// </remarks>
    private static readonly byte[] videoActiveLines = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video and Film Frame Relationship
    /// </summary>
    /// <remarks>
    /// Specifies temporal correlation between video fields/frames and film frames from which they were derived (ABCD Frame Sequence)
    /// </remarks>
    private static readonly byte[] VideoAndFilmFrameRelationship = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x08, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video and Image Essence Characteristics
    /// </summary>
    /// <remarks>
    /// All parametric aspects of the video/image essence
    /// </remarks>
    private static readonly byte[] VideoAndImageEssenceCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video and Image Scanning Parameters
    /// </summary>
    /// <remarks>
    /// Fundemental scanning and sequencing information
    /// </remarks>
    private static readonly byte[] VideoAndImageScanningParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Aspect Ratio Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to express aspect ratios of the image of different types
    /// </remarks>
    private static readonly byte[] videoAspectRatioObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x0E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Average Bit Rate
    /// </summary>
    /// <remarks>
    /// The Average bit rate in bits per second
    /// </remarks>
    private static readonly byte[] VideoAverageBitRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x01, 0x05, 0x01, 0x11, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Bit Rate Mode
    /// </summary>
    /// <remarks>
    /// the bitrate mode: constant, variable, or none if unknown
    /// </remarks>
    private static readonly byte[] videoBitRateMode = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Bit Rate Set
    /// </summary>
    /// <remarks>
    /// The average bit rate by default in bits per second
    /// </remarks>
    private static readonly byte[] videoBitRateObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Clip Duration
    /// </summary>
    /// <remarks>
    /// The amount of time elapsed between the start of capture and the end of capture of the video clip.
    /// </remarks>
    private static readonly byte[] VideoClipDuration = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x07, 0x02, 0x02, 0x01, 0x02, 0x05, 0x00, 0x00];
    /// <summary>
    /// Video Codec Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a codec object
    /// </remarks>
    private static readonly byte[] videoCodecObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x13, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Color Kind
    /// </summary>
    /// <remarks>
    /// The type of color of the video (B/W, color, etc)
    /// </remarks>
    private static readonly byte[] VideoColorKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x01, 0x02, 0x01, 0x01, 0x05, 0x00, 0x00];
    /// <summary>
    /// Video Compression Algorithm
    /// </summary>
    /// <remarks>
    /// Algorithm used to compress video content.
    /// </remarks>
    private static readonly byte[] VideoCompressionAlgorithm_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x40, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Compression History
    /// </summary>
    /// <remarks>
    /// Audit history of compression for video payload.
    /// </remarks>
    private static readonly byte[] VideoCompressionHistory = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Device Kind
    /// </summary>
    /// <remarks>
    /// Specific description for a device - eg for the film camera, film grading, video camera, variable gain amplifier etc
    /// </remarks>
    private static readonly byte[] VideoDeviceKind_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x20, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Device Parameter Name
    /// </summary>
    /// <remarks>
    /// Specific parameter for the specified device  eg.  Overall gain, Red lift, coring
    /// </remarks>
    private static readonly byte[] VideoDeviceParameterName_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x20, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Device Parameter Setting
    /// </summary>
    /// <remarks>
    /// The setting of the specific parameter for the specified device
    /// </remarks>
    private static readonly byte[] VideoDeviceParameterSetting_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x20, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Durations
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] VideoDurations = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x02, 0x01, 0x01, 0x04, 0x00, 0x00];
    /// <summary>
    /// Video Encoding Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an encoding object
    /// </remarks>
    private static readonly byte[] videoEncodingObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x12, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video File Formats
    /// </summary>
    /// <remarks>
    /// Information about the format of the subject file
    /// </remarks>
    private static readonly byte[] VideoFileFormats = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x01, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Filter Sets
    /// </summary>
    /// <remarks>
    /// To identify filters that have been applied to the video resource.
    /// </remarks>
    private static readonly byte[] videoFilterObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x28, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Fixed Bit Rate
    /// </summary>
    /// <remarks>
    /// Fixed = TRUE, variable = FALSE
    /// </remarks>
    private static readonly byte[] VideoFixedBitRate = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x03, 0x04, 0x01, 0x05, 0x01, 0x12, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Format
    /// </summary>
    /// <remarks>
    /// A set of attributes defining the video format of the material
    /// </remarks>
    private static readonly byte[] videoFormat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Format Definition
    /// </summary>
    /// <remarks>
    /// A definition associated with the video format
    /// </remarks>
    private static readonly byte[] videoFormatDefinition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Format ID
    /// </summary>
    /// <remarks>
    /// An identifier attributed to the video format
    /// </remarks>
    private static readonly byte[] videoFormatID = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Format Name
    /// </summary>
    /// <remarks>
    /// A name attributed to the video format
    /// </remarks>
    private static readonly byte[] videoFormatName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Format Profile
    /// </summary>
    /// <remarks>
    /// To define a profile of a video format
    /// </remarks>
    private static readonly byte[] videoFormatProfile = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x18, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Format Profile level
    /// </summary>
    /// <remarks>
    /// To define a level of a video format
    /// </remarks>
    private static readonly byte[] videoFormatProfileLevel = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x19, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Format Version ID
    /// </summary>
    /// <remarks>
    /// An identifier attributed to a version of the video format
    /// </remarks>
    private static readonly byte[] videoFormatVersionId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Frame Rate Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a rational object to define the frame rate
    /// </remarks>
    private static readonly byte[] videoFrameRateObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x0F, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Height Sets
    /// </summary>
    /// <remarks>
    /// A strong reference to a height object
    /// </remarks>
    private static readonly byte[] videoHeightObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x10, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Index Array
    /// </summary>
    /// <remarks>
    /// An ordered array of Video Indexes. Each Video Index is a concatenation of classes 1.1, 1.2, 1.3, 2.1 and 2.2 as defined in SMPTE 168M where each class is 3 bytes long. The CRCC bytes are not present in this data item
    /// </remarks>
    private static readonly byte[] VideoIndexArray = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x04, 0x04, 0x04, 0x03, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Index Parameters
    /// </summary>
    /// <remarks>
    /// Information derived from Video Index RP186
    /// </remarks>
    private static readonly byte[] VideoIndexParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x04, 0x04, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Line Map
    /// </summary>
    /// <remarks>
    /// Specifies the line numbers of the two top lines of the active picture
    /// </remarks>
    private static readonly byte[] VideoLineMap = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x01, 0x03, 0x02, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Max Bit Rate Set
    /// </summary>
    /// <remarks>
    /// The maximum bit rate by default in bits per second
    /// </remarks>
    private static readonly byte[] videoMaxBitRateObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Noise Filter
    /// </summary>
    /// <remarks>
    /// A structure to define the characteristics of a video noise filter
    /// </remarks>
    private static readonly byte[] videoNoiseFilter = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5B, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Noise Filter Flag
    /// </summary>
    /// <remarks>
    /// A flag to indicate if a noise filter was used
    /// </remarks>
    private static readonly byte[] videoNoiseFilterFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Noise Filter Vendor Id
    /// </summary>
    /// <remarks>
    /// An identifier associated with a noise filter vendor
    /// </remarks>
    private static readonly byte[] videoNoiseFilterObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Noise Filter Type Group Set
    /// </summary>
    /// <remarks>
    /// To specify the type of video noise filter
    /// </remarks>
    private static readonly byte[] videoNoiseFilterTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5B, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Noise Filter Vendor Id
    /// </summary>
    /// <remarks>
    /// To identify the vendor of a video noise filter
    /// </remarks>
    private static readonly byte[] videoNoiseFilterVendorId = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x5B, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Noise Reduction
    /// </summary>
    /// <remarks>
    /// Information about any video noise reduction process
    /// </remarks>
    private static readonly byte[] VideoNoiseReduction = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Noise Reduction Algorithm
    /// </summary>
    /// <remarks>
    /// Algorithm used in a noise reduction process
    /// </remarks>
    private static readonly byte[] VideoNoiseReductionAlgorithm_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Note
    /// </summary>
    /// <remarks>
    /// A contextual information note
    /// </remarks>
    private static readonly byte[] videoNote = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x1A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video or Image Capture Process
    /// </summary>
    /// <remarks>
    /// Information about how video content was captured
    /// </remarks>
    private static readonly byte[] VideoOrImageCaptureProcess = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x01, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video or Image Compression
    /// </summary>
    /// <remarks>
    /// Information about video or image compression.
    /// </remarks>
    private static readonly byte[] VideoOrImageCompression = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video or Image Compression Algorithm
    /// </summary>
    /// <remarks>
    /// Algorithm used to compress the video or image content.
    /// </remarks>
    private static readonly byte[] VideoOrImageCompressionAlgorithm_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Payload Identifier
    /// </summary>
    /// <remarks>
    /// SMPTE 352M-2001 Video Payload Identifier
    /// </remarks>
    private static readonly byte[] VideoPayloadIdentifier = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x01, 0x05, 0x04, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Payload Identifier 2002
    /// </summary>
    /// <remarks>
    /// SMPTE 352M-2002 Video Payload Identifier
    /// </remarks>
    private static readonly byte[] VideoPayloadIdentifier2002 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x01, 0x05, 0x04, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Presence Flag
    /// </summary>
    /// <remarks>
    /// A flag to signal the presence of video in the material
    /// </remarks>
    private static readonly byte[] videoPresenceFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x15, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Processor Settings
    /// </summary>
    /// <remarks>
    /// The settings of a specific device in the system
    /// </remarks>
    private static readonly byte[] VideoProcessorSettings = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x20, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Region Delim X Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a dimension object to define the abscisse coordinate of an area associated with width and height objects
    /// </remarks>
    private static readonly byte[] videoRegionDelimXObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x16, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Region Delim Y Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a dimension object to define the ordinate coordinate of an area associated with width and height objects
    /// </remarks>
    private static readonly byte[] videoRegionDelimYObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x17, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Scanning Characteristics
    /// </summary>
    /// <remarks>
    /// Information about the scanning of the essence
    /// </remarks>
    private static readonly byte[] VideoScanningCharacteristics = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x04, 0x01, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Scanning Format
    /// </summary>
    /// <remarks>
    /// A code that specifies the scanning structure e.g. progressive or interlaced
    /// </remarks>
    private static readonly byte[] videoScanningFormat = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Scanning Order
    /// </summary>
    /// <remarks>
    /// to express the scanning order from top or bottom
    /// </remarks>
    private static readonly byte[] videoScanningOrder = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Signal
    /// </summary>
    /// <remarks>
    /// PAL, NTSC etc
    /// </remarks>
    private static readonly byte[] VideoSignal = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x01, 0x04, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Technical Attribute AnyURI Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type AnyURI
    /// </remarks>
    private static readonly byte[] videoTechnicalAttributeAnyURIObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x26, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Technical Attribute Boolean Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Boolean
    /// </remarks>
    private static readonly byte[] videoTechnicalAttributeBooleanObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x27, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Technical Attribute Float Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Float
    /// </remarks>
    private static readonly byte[] videoTechnicalAttributeFloatObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x24, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Technical Attribute Int16 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int16
    /// </remarks>
    private static readonly byte[] videoTechnicalAttributeInt16Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x1D, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Technical Attribute Int32 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int32
    /// </remarks>
    private static readonly byte[] videoTechnicalAttributeInt32Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x1E, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Technical Attribute Int64 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int64
    /// </remarks>
    private static readonly byte[] videoTechnicalAttributeInt64Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x1F, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Technical Attribute Int8 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Int8
    /// </remarks>
    private static readonly byte[] videoTechnicalAttributeInt8Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x1C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Technical Attribute Rational Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type Rational
    /// </remarks>
    private static readonly byte[] videoTechnicalAttributeRationalObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x25, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Technical Attribute String Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type string
    /// </remarks>
    private static readonly byte[] videoTechnicalAttributeStringObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x1B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Technical Attribute UInt16 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt16
    /// </remarks>
    private static readonly byte[] videoTechnicalAttributeUInt16Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x21, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Technical Attribute UInt32 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt32
    /// </remarks>
    private static readonly byte[] videoTechnicalAttributeUInt32Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x22, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Technical Attribute UInt64 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt64
    /// </remarks>
    private static readonly byte[] videoTechnicalAttributeUInt64Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x23, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Technical Attribute UInt8 Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to technical attribute objects of type UInt8
    /// </remarks>
    private static readonly byte[] videoTechnicalAttributeUInt8Objects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x20, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Test Parameter
    /// </summary>
    /// <remarks>
    /// eg. Starting Bit Error Rate,  Maximum BER Tolerance Level,  Sharpness Quality Benchmark,  Scalar Based Quality Parameter,  Spatial Quality Information,  Temporal Quality Information,   Matrix Based Quality Parameter
    /// </remarks>
    private static readonly byte[] VideoTestParameter_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x10, 0x01, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Test Parameters
    /// </summary>
    /// <remarks>
    /// Video information from the original recording
    /// </remarks>
    private static readonly byte[] VideoTestParameters = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Test Result
    /// </summary>
    /// <remarks>
    /// The result from the specified test
    /// </remarks>
    private static readonly byte[] VideoTestResult_Float = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x10, 0x01, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Test Result
    /// </summary>
    /// <remarks>
    /// The result from the specified test
    /// </remarks>
    private static readonly byte[] VideoTestResult_Int32 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x10, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Track  Sets
    /// </summary>
    /// <remarks>
    /// A batch of strong references to define video track
    /// </remarks>
    private static readonly byte[] videoTrackObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x14, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Watermark Kind
    /// </summary>
    /// <remarks>
    /// Indicates the kind of video watermark
    /// </remarks>
    private static readonly byte[] VideoWatermarkKind = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x01, 0x09, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Video Width Sets
    /// </summary>
    /// <remarks>
    /// A strong reference to a width object
    /// </remarks>
    private static readonly byte[] videoWidthObjects = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x31, 0x11, 0x00, 0x00, 0x00];
    /// <summary>
    /// Viewport Aspect Ratio
    /// </summary>
    /// <remarks>
    /// Specifies the horizontal to vertical aspect ratio of the image viewport  - ie. The desired shot as it is framed for capture and thus the aspect ratio at which the image must be viewed to avoid geometric distortion.  May also therefore be a sub-selection of a larger image, possibly of a different aspect ratio.
    /// </remarks>
    private static readonly byte[] ViewportAspectRatio = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x04, 0x01, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Viewport Height
    /// </summary>
    /// <remarks>
    /// The height of the viewed area within a captured image (in pixels)
    /// </remarks>
    private static readonly byte[] ViewportHeight = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x09, 0x04, 0x01, 0x01, 0x01, 0x00];
    /// <summary>
    /// Viewport Image Center C Coordinate (Pixels)
    /// </summary>
    /// <remarks>
    /// The x position of the centre of the viewed image expressed as x/y coordinates of the viewed image
    /// </remarks>
    private static readonly byte[] ViewportImageCenterCCoordinatePixels = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x03, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Viewport Image Center Y Coordinate (Pixels)
    /// </summary>
    /// <remarks>
    /// The y position of the centre of the viewed image expressed as x/y coordinates of the viewed image
    /// </remarks>
    private static readonly byte[] ViewportImageCenterYCoordinatePixels = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x03, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Viewport Width
    /// </summary>
    /// <remarks>
    /// The width of the viewed area within a captured image (in pixels)
    /// </remarks>
    private static readonly byte[] ViewportWidth = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x09, 0x04, 0x01, 0x01, 0x02, 0x00];
    /// <summary>
    /// Voice Talent Name
    /// </summary>
    /// <remarks>
    /// Contains the name of the voice talent in the program
    /// </remarks>
    private static readonly byte[] VoiceTalentName = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x0B, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// WAVE Summary
    /// </summary>
    /// <remarks>
    /// Summary info according to WAVE Chunk format
    /// </remarks>
    private static readonly byte[] WAVESummary = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x03, 0x02, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Target Class of Weak Reference
    /// </summary>
    /// <remarks>
    /// Specifies a reference to the target class of a Weak Reference type
    /// </remarks>
    private static readonly byte[] WeakReferencedType = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x07, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// Weak References
    /// </summary>
    /// <remarks>
    /// References to Uniquely Identified Objects
    /// </remarks>
    private static readonly byte[] WeakReferences = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Weak References Arrays
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] WeakReferencesArrays = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Weak References Batches
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] WeakReferencesBatches = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x02, 0x06, 0x01, 0x01, 0x04, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// Weak Referencing to Descriptive Metadata Sets
    /// </summary>
    /// <remarks>
    /// No definition provided.
    /// </remarks>
    private static readonly byte[] WeakReferencingToDescriptiveMetadataSets = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x06, 0x01, 0x01, 0x04, 0x03, 0x40, 0x00, 0x00];
    /// <summary>
    /// Web Address
    /// </summary>
    /// <remarks>
    /// The address of a web site
    /// </remarks>
    private static readonly byte[] webAddress = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x25, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Weighting
    /// </summary>
    /// <remarks>
    /// The weighting used in measurements
    /// </remarks>
    private static readonly byte[] Weighting_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x10, 0x02, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// White Balance
    /// </summary>
    /// <remarks>
    /// White Balance value defined by the temperature in Kelvin
    /// </remarks>
    private static readonly byte[] WhiteBalance = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x20, 0x01, 0x03, 0x02, 0x02, 0x00, 0x00];
    /// <summary>
    /// White Reference Level
    /// </summary>
    /// <remarks>
    /// Specifies digital luminance associated with white
    /// </remarks>
    private static readonly byte[] WhiteRefLevel = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x03, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Width
    /// </summary>
    /// <remarks>
    /// A set of attributes to define a Width
    /// </remarks>
    private static readonly byte[] width = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x42, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Width Type Group Set
    /// </summary>
    /// <remarks>
    /// A strong reference to an attribute type group to specify the type of width
    /// </remarks>
    private static readonly byte[] widthTypeGroupObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x42, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Width Value Set
    /// </summary>
    /// <remarks>
    /// A strong reference to a dimension to define the value and unit of the width
    /// </remarks>
    private static readonly byte[] widthValueObject = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x42, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// Window Number
    /// </summary>
    /// <remarks>
    /// Identifier of the Processing Window
    /// </remarks>
    private static readonly byte[] WindowNumber = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x05, 0x31, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Working Title
    /// </summary>
    /// <remarks>
    /// The (possibly temporary) working title of a production or a production component
    /// </remarks>
    private static readonly byte[] WorkingTitle = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x0A, 0x01, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Working Title
    /// </summary>
    /// <remarks>
    /// The (possibly temporary) working title of a production or a production component
    /// </remarks>
    private static readonly byte[] WorkingTitle_ISO7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x04, 0x01, 0x05, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// Work-in-Progress Flag
    /// </summary>
    /// <remarks>
    /// Is the essence a work in progress? Work-in-progress = True
    /// </remarks>
    private static readonly byte[] WorkInProgressFlag = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x05, 0x01, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// XML BiM Constructs in Multiple Streams
    /// </summary>
    /// <remarks>
    /// Stream identification information for XML document text carried in mutilple simultaneous streams
    /// </remarks>
    private static readonly byte[] XMLBiMConstructsInMultipleStreams = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x07, 0x03, 0x01, 0x02, 0x20, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// XML Constructs and Interpretations
    /// </summary>
    /// <remarks>
    /// Defining information about XML constructs and interpretations
    /// </remarks>
    private static readonly byte[] XMLConstructsAndInterpretations = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x01, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// XML Document Text
    /// </summary>
    /// <remarks>
    /// An XML document in UTF-16 text encoding form
    /// </remarks>
    private static readonly byte[] XMLDocumentText = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x01, 0x02, 0x20, 0x01, 0x02, 0x00, 0x00];
    /// <summary>
    /// XML Document Text
    /// </summary>
    /// <remarks>
    /// An XML document in MPEG-7 BiM form
    /// </remarks>
    private static readonly byte[] XMLDocumentText_BiM = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x01, 0x02, 0x20, 0x01, 0x03, 0x00, 0x00];
    /// <summary>
    /// XML Document Text
    /// </summary>
    /// <remarks>
    /// An XML document as text. Data type is specified by the value.
    /// </remarks>
    private static readonly byte[] XMLDocumentText_Indirect = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x01, 0x02, 0x20, 0x01, 0x00, 0x00, 0x00];
    /// <summary>
    /// XML Document Text
    /// </summary>
    /// <remarks>
    /// An XML document in UTF-7 text encoding form
    /// </remarks>
    private static readonly byte[] XMLDocumentText_UTF7 = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x05, 0x03, 0x01, 0x02, 0x20, 0x01, 0x01, 0x00, 0x00];
    /// <summary>
    /// XML Report Data
    /// </summary>
    /// <remarks>
    /// XML report data
    /// </remarks>
    private static readonly byte[] XMLReportData = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x27, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// XML Report Data Length
    /// </summary>
    /// <remarks>
    /// XML report data length
    /// </remarks>
    private static readonly byte[] XMLReportDataLength = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x02, 0x40, 0x02, 0x26, 0x00, 0x00, 0x00, 0x00];
    /// <summary>
    /// XOsiz
    /// </summary>
    /// <remarks>
    /// Horizontal offset from the origin of the reference grid to the left side of the image area, as defined in ISO/IEC 15444-1 Annex A.5.1.
    /// </remarks>
    private static readonly byte[] XOsiz = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x06, 0x03, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Xsiz
    /// </summary>
    /// <remarks>
    /// Width of the reference grid, as defined in ISO/IEC 15444-1 Annex A.5.1.
    /// </remarks>
    private static readonly byte[] Xsiz = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x06, 0x03, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// XTOsiz
    /// </summary>
    /// <remarks>
    /// Horizontal offset from the origin of the reference grid to the left side of the first tile, as defined in ISO/IEC 15444-1 Annex A.5.1.
    /// </remarks>
    private static readonly byte[] XTOsiz = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x06, 0x03, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// XTsiz
    /// </summary>
    /// <remarks>
    /// Width of one reference tile with respect to the reference grid, as defined in ISO/IEC 15444-1 Annex A.5.1.
    /// </remarks>
    private static readonly byte[] XTsiz = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x06, 0x03, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Year Copyrighted
    /// </summary>
    /// <remarks>
    /// The year YYYY when the resource was copyrighted
    /// </remarks>
    private static readonly byte[] yearCopyrighted = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0C, 0x0C, 0x00, 0x00, 0x00];
    /// <summary>
    /// Year Created
    /// </summary>
    /// <remarks>
    /// The year YYYY when the resource was created
    /// </remarks>
    private static readonly byte[] yearCreated = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0C, 0x02, 0x00, 0x00, 0x00];
    /// <summary>
    /// Year Digitized
    /// </summary>
    /// <remarks>
    /// The year YYYY when the resource was digitized
    /// </remarks>
    private static readonly byte[] yearDigitized = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0C, 0x08, 0x00, 0x00, 0x00];
    /// <summary>
    /// Year Issued
    /// </summary>
    /// <remarks>
    /// The year YYYY when the resource was issued
    /// </remarks>
    private static readonly byte[] yearIssued = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0C, 0x04, 0x00, 0x00, 0x00];
    /// <summary>
    /// Year Modified
    /// </summary>
    /// <remarks>
    /// The year YYYY when the resource was modified
    /// </remarks>
    private static readonly byte[] yearModified = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0C, 0x06, 0x00, 0x00, 0x00];
    /// <summary>
    /// Year Released
    /// </summary>
    /// <remarks>
    /// The year YYYY when the resource was released
    /// </remarks>
    private static readonly byte[] yearReleased = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x02, 0x01, 0x0C, 0x0A, 0x00, 0x00, 0x00];
    /// <summary>
    /// YOsiz
    /// </summary>
    /// <remarks>
    /// Vertical offset from the origin of the reference grid to the top side of the image area, as defined in ISO/IEC 15444-1 Annex A.5.1.
    /// </remarks>
    private static readonly byte[] YOsiz = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x06, 0x03, 0x05, 0x00, 0x00, 0x00];
    /// <summary>
    /// Ysiz
    /// </summary>
    /// <remarks>
    /// Height of the reference grid, as defined in ISO/IEC 15444-1 Annex A.5.1.
    /// </remarks>
    private static readonly byte[] Ysiz = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x06, 0x03, 0x03, 0x00, 0x00, 0x00];
    /// <summary>
    /// YTOsiz
    /// </summary>
    /// <remarks>
    /// Vertical offset from the origin of the reference grid to the top side of the first tile, as defined in ISO/IEC 15444-1 Annex A.5.1.
    /// </remarks>
    private static readonly byte[] YTOsiz = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x06, 0x03, 0x09, 0x00, 0x00, 0x00];
    /// <summary>
    /// YTsiz
    /// </summary>
    /// <remarks>
    /// Height of one reference tile with respect to the reference grid, as defined in ISO/IEC 15444-1 Annex A.5.1.
    /// </remarks>
    private static readonly byte[] YTsiz = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x01, 0x06, 0x03, 0x07, 0x00, 0x00, 0x00];
    /// <summary>
    /// Zoom Ring Position
    /// </summary>
    /// <remarks>
    /// Zooming ring rotation angle in unsigned integer. 0 is for wide-end, and FFFFh is for tele-end
    /// </remarks>
    private static readonly byte[] ZoomRingPosition = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x04, 0x20, 0x02, 0x02, 0x0B, 0x00, 0x00, 0x00];
    /// <summary>
    /// Z-Position In Use
    /// </summary>
    /// <remarks>
    /// When non-zero, indicates that one or more subtitle instances in the enclosed XML resource make use of stereoscopic positioning features
    /// </remarks>
    private static readonly byte[] ZpositionInUse = [0x06, 0x0E, 0x2B, 0x34, 0x01, 0x01, 0x01, 0x0E, 0x06, 0x01, 0x01, 0x02, 0x06, 0x00, 0x00, 0x00];
}

